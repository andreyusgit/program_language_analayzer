language,code
C++,"#include <bits/stdc++.h>
using namespace std;
#define GET_MACRO(a, b, c, d, NAME, ...) NAME
#define REP2(i, n) REP3(i, 0, n)
#define REP3(i, a, b) REP4(i, a, b, 1)
#define REP4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += s)
#define RREP2(i, n) RREP3(i, 0, n)
#define RREP3(i, a, b) for (ll i = (b) - 1; i >= (ll)(a); i--)
#define rep(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)
#define rrep(...) GET_MACRO(__VA_ARGS__,, RREP3, RREP2)(__VA_ARGS__)
#define eb emplace_back
#define ef emplace_front
#define pb pop_back
#define pf pop_front
#define all(c) begin(c), end(c)
#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define popcnt __builtin_popcountll
#ifdef DEBUG
	#define dump(x) cerr << #x  << x << endl;
#else
	#define dump(x)
#endif
using uint = unsigned;
using ll = long long;
using ull = unsigned long long;
using ld = long double;
using vi = vector<int>;
using vvi = vector<vi>;
template<typename T>
using maxheap = priority_queue<T, vector<T>, less<T>>;
template<typename T>
using minheap = priority_queue<T, vector<T>, greater<T>>;
const int INF = 1e9 + 10;
const ll LLINF = 1e18 + 10;
const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1};
const int dy[] = {0, -1, 0, 1, -1, -1, 1, 1};
template<typename T>
inline T sq(T x){
	return x * x;
}
template<typename T, typename U>
inline bool chmax(T &x, U y){
	if (x >= y) return false;
	x = y;
	return true;
}
template<typename T, typename U>
inline bool chmin(T &x, U y){
	if (x <= y) return false;
	x = y;
	return true;
}
template<typename T>
inline T& sort(T &c){
	sort(all(c));
	return c;
}
template<typename T>
inline T& reverse(T &c){
	reverse(all(c));
	return c;
}
template<typename T>
inline T& unique(T &c){
	sort(all(c));
	c.erase(unique(all(c)), end(c));
	return c;
}
template<typename T>
inline T sorted(const T &c){
	T d = c;
	return move(sort(d));
}
template<typename T>
inline T reversed(const T &c){
	T d = c;
	return move(reverse(d));
}
template<typename T>
inline T uniqued(const T &c){
	T d = c;
	return move(unique(d));
}
ll modpow(ll x, ll e, ll mod = 1000000007){
	ll res = 1;
	e %= mod - 1;
	while (e){
		if (e & 1) res = res * x;
		x = x * x;
		e >>= 1;
	}
	return res;
}
inline ll in(){
	ll x;
	scanf(, &x);
	return x;
}
inline double inD(){
	double x;
	scanf(, &x);
	return x;
}
inline string inS(){
	static char s[1 << 20];
	scanf(, s);
	return s;
}
pair<ll, ll> rot45(ll x, ll y){
	return mp(x + y, x - y);
}
pair<ll, ll> rot45inv(ll u, ll v){
	return mp((u + v) / 2, (u - v) / 2);
}
template<typename T, size_t N>
struct print_tuple {
	static void print(const T &t, ostream &os){
		print_tuple<T, N - 1>::print(t, os);
		os <<  << get<N - 1>(t);
	}
};
template<typename T>
struct print_tuple<T, 1> {
	static void print(const T &t, ostream &os){
		os << get<0>(t);
	}
};
template<typename ...Args>
ostream& operator<<(ostream &os, const tuple<Args...> &t){
	print_tuple<tuple<Args...>, tuple_size<tuple<Args...>>::value>::print(t, os);
}
#include <string>
#include <cstdint>
template<unsigned MOD>
struct ModInt {
	static const unsigned Mod = MOD;
	ModInt(): v(0){}
	ModInt(long long x, bool need_mod = true): v(x){
		if (need_mod){
			if ((v = x % MOD + MOD) >= MOD) v -= MOD;
		}
	}
	ModInt(const std::string &s){
		bool neg = false;
		auto it = begin(s);
		if (*it == '-'){
			neg = true;
			++it;
		}
		v = 0;
		while (it != end(s)){
			v = (v * 10 + (*it++ - '0')) % MOD;
		}
		if (neg && v) v = MOD - v;
	}
	
	operator unsigned() const {
		return v;
	}
	ModInt operator+() const {
		return *this;
	}
	ModInt operator-() const {
		ModInt res = *this;
		if (res.v > 0) res.v = MOD - res.v;
		return res;
	}
	ModInt& operator+=(const ModInt &r){
		if ((v += r.v) >= MOD) v -= MOD;
		return *this;
	}
	ModInt& operator-=(const ModInt &r){
		if ((v += MOD - r.v) >= MOD) v -= MOD;
		return *this;
	}
	ModInt& operator*=(const ModInt &r){
		v = (unsigned long long)v * r.v % MOD;
		return *this;
	}
	ModInt& operator/=(const ModInt &r){
		v = (unsigned long long)v * r.inv() % MOD;
		return *this;
	}
	ModInt operator+(const ModInt &r) const {
		return ModInt(*this) += r;
	}
	ModInt operator-(const ModInt &r) const {
		return ModInt(*this) -= r;
	}
	ModInt operator*(const ModInt &r) const {
		return ModInt(*this) *= r;
	}
	ModInt operator/(const ModInt &r) const {
		return ModInt(*this) /= r;
	}
	
	ModInt pow(long long e) const {
		if ((e = e % (MOD - 1) + (MOD - 1)) >= (MOD - 1)) e -= MOD - 1;
		ModInt res = 1, x = *this;
		while (e > 0){
			if (e & 1) res *= x;
			x *= x;
			e >>= 1;
		}
		return res;
	}
	ModInt inv() const {
		return pow(MOD - 2);
	}
private:
	std::uint32_t v;
};
using mint = ModInt<1000000007>;
namespace mod {
	const int Mod = mint::Mod;
	const int N = 5000000;
	mint inv[N + 10];
	mint fact[N + 10];
	mint factinv[N + 10];
	
	mint C(int n, int k){
		if (k < 0 || n < k) return 0;
		return fact[n] * factinv[k] * factinv[n - k];
	}
	struct prepare {
		prepare(){
			inv[1] = 1;
			for (int i = 2; i <= N; i++){
				inv[i] = -(inv[Mod % i] * mint(Mod / i, false));
			}
			
			fact[0] = factinv[0] = 1;
			for (int i = 1; i <= N; i++){
				fact[i] = fact[i - 1] * mint(i);
				factinv[i] = factinv[i - 1] * inv[i];
			}
		}
	} prepare_;
}
int main()
{
	rep(i, 1, 10) rep(j, 1, 10){
		printf(, i, j, i * j);
	}
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <cstdio>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cstring>
#include <sstream>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <iomanip>
#include <queue>
#include <stack>
#include <list>
#include <bitset>
#include <deque>
#include <cmath>
#include <iomanip>
using namespace std;
inline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }
template<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)
#define CLR(a) memset((a), 0 ,sizeof(a))
#define MCLR(a) memset((a), -1 ,sizeof(a))
#define SZ(a) (sizeof(a))
#define FILL(a,v) fill((int*)a,(int*)(a+(SZ(a)/SZ(*(a)))),v)
#define SORT(c) sort((c).begin(),(c).end())
bool cheak(int x, int y, int xMax, int yMax)
{
	return x >= 0 && y >= 0 && xMax > x && yMax > y;
}
const int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, 1, 0, -1 };
typedef pair<int, int> P;
typedef long long ll;
typedef unsigned long long ull;
const int INF    = 2147483647;
const ll  LLINF  = 9223372036854775807;
const ull ULLINF = 18446744073709551615;
int main()
{
	REP(i, 9)REP(j, 9)
	{
		cout << i + 1 <<  << j + 1 <<  << (i + 1)*(j + 1) << endl;
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"/*#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<string>
#include<vector>
#include<math.h>
#include<queue>
#include <algorithm>
#include<functional>
#include<cstdlib>
#include<cmath>
#define REP(i, n) for(int i = 0;i < n;i++)
#define REPR(i, n) for(int i = n;i >= 0;i--)
#define FOR(i, m, n) for(int i = m;i < n;i++)
#define FORR(i, m, n) for(int i = m;i >= n;i--)
#define CI cin >>
#define CO cout <<
#define E << endl;
using namespace std;
typedef pair<int, int> P;
typedef pair<long, long> LP;
typedef pair<int, P> PP;
typedef pair<long, LP> LPP;
int dy[] = { 0, 0, 1, -1, 0 };
int dx[] = { 1, -1, 0, 0, 0 };
int A = 0, B = 0, K = 0, T = 0, W = 0, N = 0, H = 0;
int n = 0;
double L = 0;
double S = 0;
double ar = 0, br = 0, cr = 0;
int answer = 0;
string C;
string sA, strB;
vector<vector<char>> map;
vector<double> num;
vector<string> str;
int sum = 0;
vector<int> value;
vector<int> weight;
int dp[110][10010];
void input() {
	CI N >> W;
	int temp;
	for (int i = 0; i < N;i++) {
		CI temp;
		value.push_back(temp);
		CI temp;
		weight.push_back(temp);
	}
	return;
}
int main(void) {
	input();
	for (int i = 0; i < N;i++) {
		for (int j = 0; j <= W;j++) {
			dp[i + 1][j] = max(dp[i + 1][j], value[i] + dp[i][j - weight[i]]);
		}
	}
	CO dp[N][W] E
	return 0;
}
*/
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<string>
#include<vector>
#include<math.h>
#include<queue>
#include <algorithm>
#include<functional>
#include<cstdlib>
#include<cmath>
#define REP(i, n) for(int i = 0;i < n;i++)
#define REPR(i, n) for(int i = n;i >= 0;i--)
#define FOR(i, m, n) for(int i = m;i < n;i++)
#define FORR(i, m, n) for(int i = m;i >= n;i--)
#define CI cin >>
#define CO cout <<
#define E << endl;
using namespace std;
typedef pair<int, int> P;
typedef pair<long, long> LP;
typedef pair<int, P> PP;
typedef pair<long, LP> LPP;
int dy[] = { 0, 0, 1, -1, 0 };
int dx[] = { 1, -1, 0, 0, 0 };
int A = 0, B = 0, K = 0, T = 0, W = 0, N = 0, H = 0;
int n = 0;
double L = 0;
double S = 0;
double ar = 0, br = 0, cr = 0;
int answer = 0;
string C;
string sA, strB;
vector<vector<char>> map;
vector<double> num;
vector<string> str;
int sum = 0;
double tempd = 0.0;
void input() {
	
	return;
}
int main(void) {
	for (int i = 1; i <= 9; i++) {
		for (int j = 1; j <= 9; j++) {
			CO i <<  << j <<   << i * j E 
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
#ifdef _DEBUG
#define dump(x) cout << #x <<  << (x) << 
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << 
#else
#define dump(x)
#define debug(x)
#endif
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			dump( i );
			dump( j );
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <algorithm>
#include <bitset>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#define FOR(x,a,b) for(int x=a;x<b;x++)
#define REP(x,b) for(int x=0;x<b;x++)
#define FORSIZE(x,A) for(int x=0;x<A.size();x++)
#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)
#define SORT(x) sort(x.begin(),x.end())
#define RSORT(x) sort(x.rbegin(),x.rend())
#define rsort(x,n) sort(x, x+n, greater<int>())
#define REV(x) reverse(x.begin(),x.end())
using namespace std;
typedef long long ll;
inline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}
template<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}
int main( int argc, const char* argv[] )
{
    FOR(i, 1, 10) {
        FOR(j, 1, 10) {
            cout << i <<  << j <<  << i * j << endl;
        }
    }
    return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
inline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}
template<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}
template<class T> inline T sqr(T x) {return x*x;}
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<string> vs;
typedef pair<int, int> pii;
typedef long long ll;
#define all(a)  (a).begin(),(a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define pb push_back
#define mp make_pair
#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)
#define exist(s,e) ((s).find(e)!=(s).end())
#define range(i,a,b) for(int i=(a);i<(b);++i)
#define rep(i,n)  range(i,0,n)
#define clr(a,b) memset((a), (b) ,sizeof(a))
#define dump(x)  cerr << #x <<  << (x) << endl;
#define debug(x) cerr << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << endl;
const double eps = 1e-10;
const double pi  = acos(-1.0);
const ll INF =1LL << 62;
const int inf =1 << 24;
int main(void){
    range(i, 1, 10){
        range(j, 1, 10){
            cout << i <<  << j <<  << i * j << endl;
        }
    }
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
#ifdef _DEBUG
#define dump(x) cout << #x <<  << (x) << 
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << 
#else
#define dump(x)
#define debug(x)
#endif
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			dump( i );
			dump( j );
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
#ifdef _DEBUG
#define dump(x) cout << #x <<  << (x) << 
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << 
#else
#define dump(x)
#define debug(x)
#endif
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			dump( i );
			dump( j );
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++," 
 
#pragma comment(linker, )
#define LOCAL
#include <functional>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <numeric>
#include <cstring>
#include <climits>
#include <cassert>
#include <complex>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <ctime>
#include <list>
#include <set>
#include <map>
using namespace std;
#define REP(i, n) for (int i=0;i<n;++i)
#define REP_1(i, n) for (int i=1;i<=n;++i)
#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)
const int N = int(1e3) + 9;
int main(){
#ifndef ONLINE_JUDGE
    freopen(, , stdin);
    
#endif
    REP_2_1(i, j, 9, 9){
        printf(, i, j, i*j);
    }
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include<iostream>
#include<string>
#include<algorithm>
#include<map>
#include<set>
#include<utility>
#include<vector>
#include<cmath>
#include<cstdio>
#include<complex>
#define loop(i,a,b) for(int i=a;i<b;i++) 
#define rep(i,a) loop(i,0,a)
#define pb push_back
#define mp make_pair
#define it ::iterator
#define all(in) in.begin(),in.end()
const double PI=acos(-1);
const double EPS=1e-10;
using namespace std;
typedef complex<double> P;
typedef vector<P> G;
struct L : public vector<P> {
  L(const P &a, const P &b) {
    push_back(a); push_back(b);
  }
};
struct C{
	P c;double r;
	C(const P &c,double r):c(c),r(r){}
};
#define curr(P, i) P[i]
#define next(P, i) P[(i+1)%P.size()]
#define diff(P, i) (next(P, i) - curr(P, i))
namespace std {
	bool operator < (const P& a, const P& b) {
		return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);
		
	}
}
P pin(){
	double x,y;
	char d;
	cin>>x>>y;
	P p(x,y);
	return p;
}
void PIN(P* a,int n){
	rep(i,n)a[i]=pin();
}
double dot(P a,P b){
	return real(conj(a)*b);
}
double cross(P a,P b){
	return imag(conj(a)*b);
}
int ccw(P a, P b, P c) {
  b -= a; c -= a;
  if (cross(b, c) > 0)   return +1;       
  if (cross(b, c) < 0)   return -1;       
  if (dot(b, c) < 0)     return +2;       
  if (norm(b) < norm(c)) return -2;       
  return 0;
}
P projection(L a,P p){
	double t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);
	return a[0]+t*(a[0]-a[1]);
}
P reflection(L a,P p){
	return p+2.0*(projection(a,p)-p);
}
bool intersectLL(const L &l, const L &m) {
  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || 
         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   
}
bool intersectLS(const L &l, const L &s) {
  return cross(l[1]-l[0], s[0]-l[0])*       
         cross(l[1]-l[0], s[1]-l[0]) < EPS; 
}
bool intersectLP(const L &l, const P &p) {
  return abs(cross(l[1]-p, l[0]-p)) < EPS;
}
bool intersectSS(const L &s, const L &t) {
  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&
         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;
}
bool intersectSP(const L &s, const P &p) {
  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; 
}
P intersect_ls(L a,L b){
	double t1=abs(cross(a[1]-a[0],b[0]-a[0]));
	double t2=abs(cross(a[1]-a[0],b[1]-a[0]));
	return b[0]+(b[1]-b[0])*t1/(t1+t2);
}
double distanceLP(const L &l, const P &p) {
    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);
    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);
	return abs(p - projection(l, p));
}
double distanceLL(const L &l, const L &m) {
  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);
}
double distanceLS(const L &l, const L &s) {
  if (intersectLS(l, s)) return 0;
  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));
}
double distanceSP(const L &s, const P &p) {
  const P r = projection(s, p);
  if (intersectSP(s, r)) return abs(r - p);
  return min(abs(s[0] - p), abs(s[1] - p));
}
double distanceSS(const L &s, const L &t) {
  if (intersectSS(s, t)) return 0;
  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),
             min(distanceSP(t, s[0]), distanceSP(t, s[1])));
}
bool intersectCL(C c,const L &l){
    return (distanceLP(l,c.c) < c.r+EPS &&
            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));
}
L crosspointCL(C c,L l){
	P pr=projection(l,c.c);
	P e=(l[1]-l[0])/abs(l[1]-l[0]);
	double t=sqrt(c.r*c.r-norm(pr-c.c));
	P a=pr+t*e;
	P b=pr-t*e;
	if(b<a)swap(a,b);
	return L(a,b);
}
L crosspointCC(C a,C b){
	P tmp=b.c-a.c;
	double d=abs(tmp);
	double q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));
	double t=arg(tmp);
	P p1=a.c+polar(a.r,t+q);
	P p2=a.c+polar(a.r,t-q);
	if(p2<p1)swap(p1,p2);
	return L(p1,p2);
}
P crosspointLL(const L &l, const L &m) {
  double A = cross(l[1] - l[0], m[1] - m[0]);
  double B = cross(l[1] - l[0], l[1] - m[0]);
  if (abs(A) < EPS && abs(B) < EPS) return m[0]; 
  return m[0] + B / A * (m[1] - m[0]);
}
double area(const G &g){
    double S =0;
    for(int i =0;i <g.size();i++){
        S +=(cross(g[i],g[(i+1)%g.size()]));
    }
    return abs(S/2.0);
}
bool isconvex(const G &g){
	int n=g.size();
	rep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;
	return true;
}
int inconvex(const G& g, const P& p) {
	bool in = false;
	int n=g.size();
	rep(i,n){
		P a=g[i%n]-p;
		P b=g[(i+1)%n]-p;
		if(imag(a)>imag(b))swap(a, b);
		if(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;
		if(cross(a,b)==0&&dot(a,b)<=0)return 1;
	}
	return in?2:0;
}
G convex_hull(G &ps) {
    int n=ps.size(),k=0;
	sort(ps.begin(), ps.end());
	G ch(2*n);
	for(int i=0;i<n;ch[k++]=ps[i++])
		while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;
	for(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])
		while(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;
	ch.resize(k-1);
	return ch;
}
double convex_diameter(const G &pt) {
  const int n = pt.size();
  int is = 0, js = 0;
  for (int i = 1; i < n; ++i) {
    if (imag(pt[i]) > imag(pt[is])) is = i;
    if (imag(pt[i]) < imag(pt[js])) js = i;
  }
  double maxd = norm(pt[is]-pt[js]);
  int i, maxi, j, maxj;
  i = maxi = is;
  j = maxj = js;
  do {
    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;
    else i = (i+1) % n;
    if (norm(pt[i]-pt[j]) > maxd) {
      maxd = norm(pt[i]-pt[j]);
      maxi = i; maxj = j;
    }
  } while (i != is || j != js);
  return sqrt(maxd); 
}
G convex_cut(const G& g, const L& l) {
  G Q;
  for (int i = 0; i < g.size(); ++i) {
    P a= curr(g, i), b= next(g, i);
    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);
    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)
      Q.push_back(crosspointLL(L(a,b), l));
  }
  return Q;
}
P turn(P p,double t){
	return p*exp(P(.0,t*PI/180.0));
}
void printL(const L &out){
	printf(,out[0].real(),out[0].imag(),out[1].real(),out[1].imag());
}
int main(){
	loop(i,1,10)loop(j,1,10)cout<<i<<<<j<<<<i*j<<endl;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<utility>
#include<set>
#include<map>
#include<queue>
#include<vector>
#include<string>
#include<cstring>
#include<unordered_map>
#include<cassert>
#include<cmath>
#define ri(X) scanf(, &(X))
#define rii(X, Y) scanf(, &(X), &(Y))
#define riii(X, Y, Z) scanf(, &(X), &(Y), &(Z))
#define dri(X) int (X); scanf(, &X)
#define drii(X, Y) int X, Y; scanf(, &X, &Y)
#define driii(X, Y, Z) int X, Y, Z; scanf(, &X, &Y, &Z)
#define pb push_back
#define mp make_pair
#define rep(i, s, t) for ( int i=(s) ; i <(t) ; i++)
#define fill(x, v) memset (x, v, sizeof(x))
#define why(d) cout << (d) << 
#define whisp(X, Y) cout << (X) <<  << (Y) << 
#define exclam cout << 
typedef long long ll;
using namespace std;
typedef pair<int, int> pii;
const ll inf = (int)1e9 + 70;
const ll mod = 1e9 + 7;
const int maxn = 1e5 + 1000;
int main(){
	
	
	rep(i, 1, 10){
		rep(j, 1, 10){
			cout << i <<  << j <<  << i*j << ;
		}
	}
	return 0;
}"
C++,"#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <queue>
#include <map>
#define FOR(i,a,b) for (int i=(a);i<(b);i++)
#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)
#define REP(i,n) for (int i=0;i<(n);i++)
#define RREP(i,n) for (int i=(n)-1;i>=0;i--)
#define MAX_N 105
int vx [4]= {1,0,-1,0};
int vy [4]= {0,1,0,-1};
long long  dp[MAX_N][21]={};
int V[MAX_N],W[MAX_N];
int data[MAX_N],B[MAX_N];
int K ,N,a[MAX_N];
using namespace std;
void init(){
  /*cin >> N;
  cin >> a[1];
    dp[1][a[1]]=1;
  for(int l= 2;l<=N-1;l++){
    cin >> a[l];
    for(int i= 0;i<=20;i++){
      if(i-a[l]>=0&&i-a[l]<=20) dp[l][i] += dp[l-1][i-a[l]];
      if(i+a[l]>=0&&i+a[l]<=20) dp[l][i] += dp[l-1][i+a[l]];
    }
      
  }
  
  cin >> a[N];
  cout << dp[N-1][a[N]]<<endl;
  */
}
void solve(){
  init();
}
int main(){
  REP(i,9)REP(j,9)cout << i+1<<'x'<<j+1<<'='<<(i+1)*(j+1)<<endl;
    solve();
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <cstdlib>
#include <cmath>
#include <climits>
#include <cfloat>
#include <map>
#include <set>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <complex>
#include <stack>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iterator>
#include <bitset>
#include <unordered_set>
#include <unordered_map>
#include <fstream>
#include <iomanip>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vint;
typedef vector<vector<int> > vvint;
typedef vector<long long> vll, vLL;
typedef vector<vector<long long> > vvll, vvLL;
#define VV(T) vector<vector< T > >
template <class T>
void initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){
    v.assign(a, vector<T>(b, t));
}
template <class F, class T>
void convert(const F &f, T &t){
    stringstream ss;
    ss << f;
    ss >> t;
}
#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define reep(i,a,b) for(int i=(a);i<(b);++i)
#define rep(i,n) reep((i),0,(n))
#define ALL(v) (v).begin(),(v).end()
#define PB push_back
#define F first
#define S second
#define mkp make_pair
#define RALL(v) (v).rbegin(),(v).rend()
#define DEBUG
#ifdef DEBUG
#define dump(x)  cout << #x <<  << (x) << endl;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << endl;
#else
#define dump(x) 
#define debug(x) 
#endif
#define LDcout(x,n) fixed<<setprecision(n)<<x
#define MOD 1000000007LL
#define EPS 1e-8
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
#define maxs(x,y) x=max(x,y)
#define mins(x,y) x=min(x,y)
void mainmain(){
    reep(i,1,10){
        reep(j,1,10){
            cout<<i<<<<j<<<<i*j<<endl;
        }
    }
}
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
      cout<<fixed<<setprecision(20);
    mainmain();
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
#ifdef _DEBUG
#define dump(x) cout << #x <<  << (x) << 
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << 
#else
#define dump(x)
#define debug(x)
#endif
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			dump( i );
			dump( j );
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
#ifdef _DEBUG
#define dump(x) cout << #x <<  << (x) << 
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << 
#else
#define dump(x)
#define debug(x)
#endif
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			dump( i );
			dump( j );
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <queue>
#include <map>
#define FOR(i,a,b) for (int i=(a);i<(b);i++)
#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)
#define REP(i,n) for (int i=0;i<(n);i++)
#define RREP(i,n) for (int i=(n)-1;i>=0;i--)
#define MAX_N 105
int vx [4]= {1,0,-1,0};
int vy [4]= {0,1,0,-1};
long long  dp[MAX_N][21]={};
int V[MAX_N],W[MAX_N];
int data[MAX_N],B[MAX_N];
int K ,N,a[MAX_N];
using namespace std;
void init(){
  /*cin >> N;
  cin >> a[1];
    dp[1][a[1]]=1;
  for(int l= 2;l<=N-1;l++){
    cin >> a[l];
    for(int i= 0;i<=20;i++){
      if(i-a[l]>=0&&i-a[l]<=20) dp[l][i] += dp[l-1][i-a[l]];
      if(i+a[l]>=0&&i+a[l]<=20) dp[l][i] += dp[l-1][i+a[l]];
    }
      
  }
  
  cin >> a[N];
  cout << dp[N-1][a[N]]<<endl;
  */
}
void solve(){
  init();
}
int main(){
  REP(i,9)REP(j,9)cout << i+1<<'x'<<j+1<<'='<<(i+1)*(j+1)<<endl;
    solve();
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
#ifdef _DEBUG
#define dump(x) cout << #x <<  << (x) << 
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << 
#else
#define dump(x)
#define debug(x)
#endif
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			dump( i );
			dump( j );
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <array> 
#include <cstdio>
#include <type_traits>
template <std::size_t...>
struct index_tuple {};
 
namespace detail {
 
template <typename IndexTuple, std::size_t Next>
struct index_range_next;
template <std::size_t... Indices, std::size_t Next>
struct index_range_next<index_tuple<Indices...>, Next> {
 public:
  typedef index_tuple<Indices..., (Indices + Next)...> type;
};
 
template <typename IndexTuple, std::size_t Next, std::size_t Tail>
struct index_range_next2;
template <std::size_t... Indices, std::size_t Next, std::size_t Tail>
struct index_range_next2<index_tuple<Indices...>, Next, Tail> {
 public:
  typedef index_tuple<Indices..., (Indices + Next)..., Tail> type;
};
 
template <std::size_t First, std::size_t Step, std::size_t N,
          typename Enable = void>
struct index_range_impl;
template <std::size_t First, std::size_t Step, std::size_t N>
struct index_range_impl<First, Step, N,
                        typename std::enable_if<(N == 0)>::type> {
 public:
  typedef index_tuple<> type;
};
template <std::size_t First, std::size_t Step, std::size_t N>
struct index_range_impl<First, Step, N,
                        typename std::enable_if<(N == 1)>::type> {
 public:
  typedef index_tuple<First> type;
};
template <std::size_t First, std::size_t Step, std::size_t N>
struct index_range_impl<First, Step, N,
                        typename std::enable_if<(N > 1 && N % 2 == 0)>::
                            type> : public detail::
                                        index_range_next<
                                            typename detail::index_range_impl<
                                                First, Step, N / 2>::type,
                                            First + N / 2 * Step> {};
template <std::size_t First, std::size_t Step, std::size_t N>
struct index_range_impl<First, Step, N,
                        typename std::enable_if<(N > 1 && N % 2 == 1)>::
                            type> : public detail::
                                        index_range_next2<
                                            typename detail::index_range_impl<
                                                First, Step, N / 2>::type,
                                            First + N / 2 * Step,
                                            First + (N - 1) * Step> {};
 
template <std::size_t First, typename IndexTuple>
struct index_range_helper;
template <std::size_t First, std::size_t... Indices>
struct index_range_helper<First, index_tuple<Indices...>> {
 public:
  typedef index_tuple<(Indices + First)...> type;
};
 
}  
 
template <std::size_t First, std::size_t Last, std::size_t Step = 1>
struct index_range
    : public detail::index_range_helper<
          First, typename detail::index_range_impl<
                     0, Step, ((Last - First) + (Step - 1)) / Step>::type> {};
namespace detail {
template <std::size_t N, std::size_t... Indices>
std::array<int, 9> solve_impl(const index_tuple<Indices...>&) {
    return std::array<int, 9>{{printf(, (N + 1), (Indices + 1), ((N + 1) * (Indices + 1)))...}};
}
    
template <std::size_t... Indices>
std::array<std::array<int, 9>, 9> solve(const index_tuple<Indices...>& t) {
    return std::array<std::array<int, 9>, 9>{{solve_impl<Indices>(t)...}};
}
    
}  
std::array<std::array<int, 9>, 9> solve() {
    return detail::solve(typename index_range<0, 9>::type());
}
int main() { solve(); }"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include <fstream>
using namespace std;
inline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}
template<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}
template<class T> inline T sqr(T x) {return x*x;}
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef pair<long, long> PLL;
typedef long long LL;
#define ALL(a)  (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define PB push_back
#define MP make_pair
#define SZ(a) int((a).size())
#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)
const double EPS = 1e-10;
const double PI  = acos(-1.0);
#define CLR(a) memset((a), 0 ,sizeof(a))
int main(){
	FOR(i,1,10)FOR(j,1,10){
		cout<<i<<<<j<<<<i*j<<endl;
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j);
		}
	}
	return 0;
}"
C++,"#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <cstring>
#include <cctype>
#include <iostream>
#include <sstream>
#include <vector>
#include <list>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <functional>
using namespace std;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef long long ll;
const double PI = 3.141592653589793238462643383279502884L;
const int LARGE_INT = 1000000007;
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define tr(c, i) for(auto i = (c).begin(); i != (c).end(); i++)
#define rtr(c, i) for(auto i = (c).rbegin(); i != (c).rend(); i++)
#define repfn(i,a,cont,next) \\
  for(auto i = (a); [=](){return(cont);}(); i = [=](){return(next);}())
#define repby(i,a,b,s) repfn(i,a,i<b,i+s)
#define repab(i,a,b) repby(i,a,b,1)
#define rep(i,b) repab(i,0,b)
#define pb push_back
#define sz(c) int((c).size())
int main(int argc, char **argv)
{
  repab(i, 1, 10) {
    repab(j, 1, 10) {
      printf(, i, j, i*j);
    }
  }
  return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ll, int> li;
typedef pair<int, ll> il;
typedef vector<ii> vii;
typedef vector<il> vil;
typedef vector<li> vli;
#define F first
#define S second
#define pb(x) push_back(x)
#define mp(a,b) make_pair(a,b)
#define sz size()
#define all(A)    A.begin(), A.end()
#define mem(a, b) memset(a, b, sizeof(a))
#define f0(i,b)   for(int i=0;i<(b);i++)
#define f1(i,b)   for(int i=1;i<=(b);i++)
#define f2(i,a,b) for(int i=(a);i<=(b);i++)
#define fr(i,b,a) for(int i=(b);i>=(a);i--)
#define rep(i,a,b,c) for(int i=(a);i!=(b);i+=(c))
#define mod 1000000007
#define forr(i,n)    for(i=0; i<n; i++)
#define whilee(i,t)  while(i!=t)
#define  sl(a)  scanf(,&a)
#define  pl(a)  printf(,a)
ll i, j, k, a, b, c, d, f, g, h, l, m, n, p, q, r, s, t, w, x, y, z, maxx=INT_MIN, minn=INT_MAX, ans=0, sum=0, cnt=0;
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    for(i=1; i<10; i++)
    {
        for(j=1; j<10; j++)
        {
            cout<<i<<<<j<<<<i*j<<endl;
        }
    }
    return 0;
}"
C++,"#include <bits/stdc++.h> 
#define GET_MACRO(a, b, c, d, NAME, ...) NAME
#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)
#define REP2(i, a) REP3(i, 0, a)
#define REP3(i, a, b) REP4(i, a, b, 1)
#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))
#define REPR(...) GET_MACRO(__VA_ARGS__, REPR4, REPR3, REPR2)(__VA_ARGS__)
#define REPR2(i, a) REPR3(i, 0, a)
#define REPR3(i, a, b) REPR4(i, a, b, 1)
#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))
#define ALL(c) (c).begin(), (c).end()
#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')
#define TMPL_T template <typename T>
#define TMPL_TU template <typename T, typename U>
#define mut auto
#define let const auto
using Int = long long;
namespace extio {
std::string delimiter=,pdelimiter=;
std::string bracket_b=,bracket_e=;
void chdelim(const std::string&s){delimiter=s;}
void chpdelim(const std::string&s){pdelimiter=s;}
void chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}
TMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}
TMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}
}
namespace std {
TMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}
TMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}
TMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}
TMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}
TMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}
TMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}
}
TMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}
TMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}
inline int in(){int x;std::cin>>x;return x;}
struct Initializer_ {
  Initializer_(){
    std::cin.tie(0);
    std::ios::sync_with_stdio(0);
    std::cout << std::setprecision(10);
    std::cerr << std::setprecision(10);
  }
} precalc;
using namespace std;
signed main() {
  REP(i, 1, 10) {
    REP(j, 1, 10) { printf(, i, j, i * j); }
  }
  return 0;
}"
Python,"def main():
    N = int(input())
    for _ in range(N):
        n1 = input().strip()
        n2 = input().strip()
        
        if len(n1) > 80 or len(n2) > 80:
            print(""overflow"")
            continue
        print(add(n1, n2))
    return
def add(n1, n2):
    
    kotae = """"
    n1 = n1[::-1] 
    n2 = n2[::-1]
    if len(n1) < len(n2): 
        n1, n2 = n2, n1
    shorter = min(len(n1), len(n2))
    longer = max(len(n1), len(n2))
    idx, kuriagari = 0, 0
    while idx < longer:
        if idx >= shorter:
            tmp = int(n1[idx]) + kuriagari
            
            kuriagari = 1 if tmp >= 10 else 0
            kotae += str(tmp)[-1]
            idx += 1
        while idx < shorter:
            tmp = int(n1[idx]) + int(n2[idx]) + kuriagari
            
            kuriagari = 1 if tmp >= 10 else 0
            kotae += str(tmp)[-1]
            idx += 1
    if kuriagari:
        kotae += ""1""
    if len(kotae) > 80:
        return ""overflow""
    else:
        return kotae[::-1]
if __name__ == ""__main__"":
    main()"
Python,"sheet = [[0 for _ in range(10)] for _ in range(10)]
small_range = ((0, 0), (1, 0), (0, 1), (-1, 0), (0, -1))
middle_range = ((0, 0), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))
large_range = ((0, 0), (1, 0), (2, 0), (1, 1), (0, 1), (0, 2), (-1, 1), (-1, 0), (-2, 0), (-1, -1), (0, -1), (0, -2), (1, -1))
def drop(x, y, drop_range):
  for dx, dy in drop_range:
    newx, newy = x + dx, y + dy
    if 0 <= newx <= 9 and 0 <= newy <= 9:
      sheet[newx][newy] += 1
while True:
  try:
    x, y, s = map(int, input().split("",""))
    if s == 1:
      drop(x, y, small_range)
    elif s == 2:
      drop(x, y, middle_range)
    else:
      drop(x, y, large_range)
  except EOFError:
    break
zero_cnt = 0
max_ink = 0
for x in range(10):
  for y in range(10):
    ink = sheet[x][y]
    if ink == 0:
      zero_cnt += 1
    if max_ink < ink:
      max_ink = ink
print(zero_cnt)
print(max_ink)"
Python,"from math import sqrt
def circle(x1, y1, x2, y2, x3, y3):
    if x1 == 0:
        dx = 1
        x1 = x1 + dx
        x2 = x2 + dx
        x3 = x3 + dx
    else:
        dx = 0
    if y2 == 0:
        dy = 1
        y1 = y1 + dy
        y2 = y2 + dy
        y3 = y3 + dy
    else:
        dy = 0
    A = [[x1, y1, 1, 1, 0, 0],[x2, y2, 1, 0, 1, 0],[x3, y3, 1, 0, 0, 1]]
    for i in range(3):
        A[0] = [x/A[0][0] for x in A[0]]
        A[1] = [A[1][j] - A[1][0] * A[0][j] for j in range(6)]
        A[2] = [A[2][j] - A[2][0] * A[0][j] for j in range(6)]
        for j in range(3):
            A[j] = A[j][1:] + A[j][:1]
        A = A[1:] + A[:1]
    for i in range(3):
        A[i] = A[i][:3]
    V = [-x1**2-y1**2, -x2**2-y2**2, -x3**2-y3**2]
    M = [(A[i][0] * V[0] + A[i][1] * V[1] + A[i][2] * V[2]) for i in range(3)]
    xcenter = -0.5 * M[0] - dx
    ycenter = -0.5 * M[1] - dy
    radius = sqrt((M[0]**2) /4 + (M[1]**2) /4 - M[2])
    return xcenter, ycenter, radius
n = int(input())
for line in range(n):
    x1, y1, x2, y2, x3, y3 = map(float, input().split())
    xc, yc, ra = circle(x1, y1, x2, y2, x3, y3)
    print('%.3f %.3f %.3f' % (xc, yc, ra))"
Python,"import sys
import math
import array
class mymath:
    
    pi = 3.14159265358979323846264338
    
    def pnum_eratosthenes(self, n):
        ptable = [0 for i in range(n+1)]
        plist = []
        for i in range(2, n+1):
            if ptable[i]==0:
                plist.append(i)
                for j in range(i+i, n+1, i):
                    ptable[j] = 1
        return plist
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
    
    def mul(self, A, B):
        ans = []
        for a in A:
            c = 0
            for j, row in enumerate(a):
                c += row*B[j]
            ans.append(c)
        return ans
mymath = mymath()
class output:
    
    def list(self, l):
        l = list(l)
        
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
def main():
    W = int(input())
    N = int(input())
    AB = [[int(x)-1 for x in input().split(',')] for i in range(N)]
    
    ans = list(range(1, W+1))
    for ab in AB:
        ans[ab[0]], ans[ab[1]] = ans[ab[1]], ans[ab[0]]
    for i in ans:
        print(i)
if __name__ == '__main__':
    main()"
Python,"import sys
class math:
    
    pi = 3.14159265358979323846264338
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
math = math()
class output:
    
    def list(self, l):
        l = list(l)
        print("" "", end="""")
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
for line in sys.stdin.readlines():
    x, y = [int(temp) for temp in line.split()]
    print(""{} {}"".format(math.gcd(x,y), math.lcm(x,y)))
    "
Python,"paper = [[0 for i in range(10)] for j in range(10)]
while True :
    try :
        x, y, s = map(int, input().split("",""))
        
        paper[x][y] += 1
        if x > 0 :
            paper[x-1][y] += 1
        if y > 0 :
            paper[x][y-1] += 1
        if x < 9 :
            paper[x+1][y] += 1
        if y < 9 :
            paper[x][y+1] += 1
        if s > 1 :
            if x > 0 :
                if y > 0 :
                    paper[x-1][y-1] += 1
                if y < 9 :
                    paper[x-1][y+1] += 1
            if x < 9 :
                if y > 0 :
                    paper[x+1][y-1] += 1
                if y < 9 :
                    paper[x+1][y+1] += 1
        if s > 2 :
            if x > 1 :
                paper[x-2][y] += 1
            if y > 1 :
                paper[x][y-2] += 1
            if x < 8 :
                paper[x+2][y] += 1
            if y < 8 :
                paper[x][y+2] += 1
                
    except EOFError :
        break
S = 0
M = 0
for i in range(10) :
    for j in range(10) :
        if paper[i][j] == 0 :
            S += 1
        if paper[i][j] > M :
            M = paper[i][j]
        
print(S)
print(M)"
Python,"import sys
table = [[0 for j in range(10)] for i in range(10)]
def flag(x, y):
    if x > 9 or y > 9 or x < 0 or y < 0:
        return False
    else:
        return True
def small(x, y):
    table[x][y] += 1
    if flag(x+1, y):
        table[x+1][y] += 1
    if flag(x-1, y):
        table[x-1][y] += 1
    if flag(x, y+1):
        table[x][y+1] += 1
    if flag(x, y-1):
        table[x][y-1] += 1
def medium(x, y):
    small(x, y)
    if flag(x+1, y+1):
        table[x+1][y+1] += 1
    if flag(x+1, y-1):
        table[x+1][y-1] += 1
    if flag(x-1, y+1):
        table[x-1][y+1] += 1
    if flag(x-1, y-1):
        table[x-1][y-1] += 1
def large(x, y):
    medium(x, y)
    if flag(x+2, y):
        table[x+2][y] += 1
    if flag(x-2, y):
        table[x-2][y] += 1
    if flag(x, y+2):
        table[x][y+2] += 1
    if flag(x, y-2):
        table[x][y-2] += 1
def ink(x, y, s):
    if s == 1:
        small(x, y)
    if s == 2:
        medium(x, y)
    if s == 3:
        large(x, y)
def Search():
    counter = 0
    thickest = 0
    for i in range(10):
        for j in range(10):
            if table[i][j] == 0:
                counter += 1
            elif thickest < table[i][j]:
                thickest = table[i][j]
    print(counter)
    print(thickest)
for l in sys.stdin:
    data = list(map(int, l.split("","")))
    x, y, s = data
    ink(x, y, s)
Search()"
Python,"import sys
import math
prim_no = {2: True}                    
def is_prime(no):
    if no == 2 or no == 1:
        return True
    
    if no % 2 == 0:
        return False
    if prim_no.get(no) is not None:
        return prim_no.get(no)
    max_check = int(math.sqrt(no))
    for i in range(3, max_check+1, 2):
        if no % i == 0:
            prim_no[no] = False
            return False
    prim_no[no] = True
    return True
def main():
    prim_vals = {}                         
    num_data = []                          
    
    while True:
        num = sys.stdin.readline()
        if num is None or num.strip() == '':
            break
        num = int(num.strip())
        num_data.append(num)
    sorted_num_data = sorted(num_data)
    prim_num = {}
    
    for num in sorted_num_data:
        if prim_vals.get(num) is not None:
            cnt = prim_vals.get(num)
        else:
            if num == 1:
                cnt = 0
            else:
                cnt = 0
                if num % 2 == 0:
                    start_num = num -1
                else:
                    start_num = num
                    
                for i in range(start_num, 0, -2):
                    if prim_vals.get(i) is not None:
                        cnt += prim_vals.get(i)
                        break
                    
                    if is_prime(i):
                        cnt += 1
                        
                prim_vals[num] = cnt 
        prim_num[num] = cnt
    for num in num_data:
        print(prim_num[num])
if __name__ == '__main__':
    main()
    "
Python,"from math import *
def g(x):
    y = (int((1000 * abs(x)) * 2 + 1) // 2) / 1000
    if x < 0:
        y *= -1
    return y
'''
def f(x):
    a = (x[2] - x[4]) * (x[1] - x[3]) - (x[0] - x[2]) * (x[3] - x[5])
    b = (x[0] - x[2]) * (x[4] - x[0]) - (x[5] - x[1]) * (x[1] - x[3])
    l = 0.5 * b / a
    X = 0.5 * x[2] + 0.5 * x[4] + l * (x[3] - x[5])
    Y = 0.5 * x[3] + 0.5 * x[5] + l * (x[4] - x[2])
    R = sqrt((X - x[0]) ** 2 + (Y - x[1]) ** 2)
    X = g(X)
    Y = g(Y)
    R = g(R)
    print(""{0:.3f} {1:.3f} {2:.3f}"".format(X, Y, R))
'''
def f(x):
    x1, y1, x2, y2, x3, y3 = x
    X1 = x1 - x3
    Y1 = y1 - y3
    X2 = x2 - x3
    Y2 = y2 - y3
    k  = (X2 ** 2 + Y2 ** 2 -X1 * X2 - Y1 * Y2) / (2 * (X2 * Y1 - X1 * Y2))
    X  = X1 / 2 + k * Y1 + x3
    Y  = Y1 / 2 - k * X1 + y3
    R = sqrt((X - x1) ** 2 + (Y - y1) ** 2)
    X = g(X)
    Y = g(Y)
    R = g(R)
    print(""{0:.3f} {1:.3f} {2:.3f}"".format(X, Y, R))
n = int(input())
a = []
for _ in range(n):
    a.append(list((map(float, input().split()))))
for i in a:
    f(i)"
Python,"import math
class P(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def width(self, p):
        return math.sqrt((self.x - p.x)**2 + (self.y - p.y)**2)
    def __repr__(self):
        return '{0:.3f} {1:.3f}'.format(self.x, self.y)
def calc_cos(a,b,c):
    return (b**2 + c**2 - a**2) / (2*b*c)
def calc_sin(c):
    return math.sqrt(1 - c**2)
def calc_2sin(s,c):
    return 2 * s * c
def run():
    n = int(input())
    for _ in range(n):
        x1, y1, x2, y2, x3, y3 = list(map(float, input().split()))
        p1, p2, p3 = P(x1, y1), P(x2, y2), P(x3, y3)
        a, b, c = p1.width(p2), p2.width(p3), p3.width(p1)
        cosA, cosB, cosC = calc_cos(a,b,c), calc_cos(b,c,a), calc_cos(c,a,b)
        sinA, sinB, sinC = calc_sin(cosA), calc_sin(cosB), calc_sin(cosC)
        sin2A, sin2B, sin2C = calc_2sin(sinA, cosA), calc_2sin(sinB, cosB), calc_2sin(sinC, cosC)
        r = a / sinA / 2
        x = (p1.x * sin2B + p2.x * sin2C + p3.x * sin2A) / (sin2A + sin2B + sin2C)
        y = (p1.y * sin2B + p2.y * sin2C + p3.y * sin2A) / (sin2A + sin2B + sin2C)
        print('{0:.3f} {1:.3f} {2:.3f}'.format(x,y,r))
if __name__ == '__main__':
    run()"
Python,"class vector(object):
    def __init__(self,a,b):
        self.x=b.x-a.x
        self.y=b.y-a.y
    @staticmethod
    def cross_product(a,b):
        return a.x*b.y-a.y*b.x
class vertex(object):
    def __init__(self,a):
        self.x=a[0]
        self.y=a[1]
class circle(object):
    def __init__(self,p,r):
        self.px=p.x
        self.py=p.y
        self.r=r
class triangle(object):
    def __init__(self,a,b,c):
        self.a=a
        self.b=b
        self.c=c
        import math
        self.ab=math.sqrt((self.a.x-self.b.x)**2+(self.a.y-self.b.y)**2)
        self.bc=math.sqrt((self.b.x-self.c.x)**2+(self.b.y-self.c.y)**2)
        self.ca=math.sqrt((self.c.x-self.a.x)**2+(self.c.y-self.a.y)**2)
        c=self.ab
        a=self.bc
        b=self.ca
        self.cosA=(b**2+c**2-a**2)/(2*b*c)
        self.cosB=(a**2+c**2-b**2)/(2*a*c)
        self.cosC=(b**2+a**2-c**2)/(2*b*a)
        self.sinA=math.sqrt(1-self.cosA**2)
        self.sinB=math.sqrt(1-self.cosB**2)
        self.sinC=math.sqrt(1-self.cosC**2)
        self.sin2A=2*self.sinA*self.cosA
        self.sin2B=2*self.sinB*self.cosB
        self.sin2C=2*self.sinC*self.cosC
    def area(self):
        import math
        s=(self.ab+self.bc+self.ca)/2
        S=math.sqrt(s*(s-self.ab)*(s-self.bc)*(s-self.ca))
        return S
    def circumscribed(self):
        R=self.ab/(2*self.sinC)
        px=(self.sin2A*self.a.x+self.sin2B*self.b.x+self.sin2C*self.c.x)/(self.sin2A+self.sin2B+self.sin2C)
        py=(self.sin2A*self.a.y+self.sin2B*self.b.y+self.sin2C*self.c.y)/(self.sin2A+self.sin2B+self.sin2C)
        px=round(px,3)
        py=round(py,3)
        R=round(R,3)
        p=vertex((px,py))
        return circle(p,R)
    def isin(self,p):
        AB=vector(self.a,self.b)
        BC=vector(self.b,self.c)
        CA=vector(self.c,self.a)
        AP=vector(self.a,p)
        BP=vector(self.b,p)
        CP=vector(self.c,p)
        if (vector.cross_product(AB,AP)>0 and vector.cross_product(BC,BP)>0 and vector.cross_product(CA,CP)>0)or(vector.cross_product(AB,AP)<0 and vector.cross_product(BC,BP)<0 and vector.cross_product(CA,CP)<0):
            return 'YES'
        else:return 'NO'
A=[]
B=[]
C=[]
p=[]
import sys
for line in sys.stdin:
    a,b,c,d,e,f,g,h=list(map(float,line.split()))
    A.append(vertex((a,b)))
    B.append(vertex((c,d)))
    C.append(vertex((e,f)))
    p.append(vertex((g,h)))
for i in range(len(A)):
    Triangle=triangle(A[i],B[i],C[i])
    print(Triangle.isin(p[i]))"
Python,"import sys
import math
prim_no = {2: True}                    
def is_prime(no):
    if no == 2 or no == 1:
        return True
    
    if no % 2 == 0:
        return False
    if prim_no.get(no) is not None:
        return prim_no.get(no)
    max_check = int(math.sqrt(no))
    for i in range(3, max_check+1, 2):
        if no % i == 0:
            prim_no[no] = False
            return False
    prim_no[no] = True
    return True
def main():
    prim_vals = {}                         
    while True:
        num = sys.stdin.readline()
        if num is None or num.strip() == '':
            break
        num = int(num.strip())
        if prim_vals.get(num) is not None:
            cnt = prim_vals.get(num)
        else:
            if num == 1:
                cnt = 0
            else:
                cnt = 0
                if num % 2 == 0:
                    start_num = num -1
                else:
                    start_num = num
                    
                for i in range(start_num, 0, -2):
                    if prim_vals.get(i) is not None:
                        cnt += prim_vals.get(i)
                        break
                    
                    if is_prime(i):
                        cnt += 1
                        
                prim_vals[num] = cnt 
        print(cnt)
if __name__ == '__main__':
    main()
    "
Python,"import sys
from itertools import accumulate
def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
MOD = 10 ** 9 + 7
def eratosthenes_sieve(n):
    
    table = [0] * (n + 1)
    prime_list = []
    for i in range(2, n + 1):
        if table[i] == 0:
            prime_list.append(i)
            for j in range(i + i, n + 1, i):
                table[j] = 1
    return prime_list
N = 1000000
primes = eratosthenes_sieve(N)
A = [0] * 1000000
for p in primes:
    A[p] = 1
acc = list(accumulate(A))
while True:
    try:
        a = INT()
        print(acc[a])
    except:
        
        break"
Python,"class Solution(object):
    def combinationSum(self, target):
        candidates = []
        for i in range(10):
            candidates.append(i)
        stack = [(0, 0, [])]
        result = []
        while stack:
            total, start, res = stack.pop()
            if total == target and len(res) == 4:
                result.append(res)
            elif len(res) > 4:
            	continue
            if total == 0 and len(res) == 4:
            	continue
            for i in range(start, len(candidates)):
                t = total + candidates[i]
                if t > target:
                    break
                stack.append((t, i, res + [candidates[i]]))
        return result
    def duplicated(self, nums, i, j):
        for t in range(i, j):
            if nums[t] == nums[j]:
                return False
        return True
    def recursion(self, nums, i, n, result):
        if i == n - 1:
            temp = []
            for k in range(0, n):
                temp.append(nums[k])
            result.append(temp)
        else:
            for k in range(i, n):
                if self.duplicated(nums, i ,k):
                    temp = nums[k] 
                    nums[k] = nums[i]
                    nums[i] = temp
                    self.recursion(nums, i + 1, n, result)
                    temp = nums[k] 
                    nums[k] = nums[i]
                    nums[i] = temp
    def permuteUnique(self, nums):
        result = []
        self.recursion(nums, 0, len(nums), result)
        return result
while True:
    try:
        n = int(raw_input())
        s = Solution()
        combination = s.combinationSum(n)
        m = 0
        for i in range(len(combination)):
            m += len(s.permuteUnique(combination[i]))
        print m
    except (EOFError):
        break"
Python,"l = [['the', 'uif', 'vjg', 'wkh', 'xli', 'ymj', 'znk', 'aol', 'bpm', 'cqn', 'dro', 'esp', 'ftq', 'gur', 'hvs', 'iwt', 'jxu', 'kyv', 'lzw', 'max', 'nby', 'ocz', 'pda', 'qeb', 'rfc', 'sgd'], \\
['this', 'uijt', 'vjku', 'wklv', 'xlmw', 'ymnx', 'znoy', 'aopz', 'bpqa', 'cqrb', 'drsc', 'estd', 'ftue', 'guvf', 'hvwg', 'iwxh', 'jxyi', 'kyzj', 'lzak', 'mabl', 'nbcm', 'ocdn', 'pdeo', 'qefp', 'rfgq', 'sghr'], \\
['that', 'uibu', 'vjcv', 'wkdw', 'xlex', 'ymfy', 'zngz', 'aoha', 'bpib', 'cqjc', 'drkd', 'esle', 'ftmf', 'gung', 'hvoh', 'iwpi', 'jxqj', 'kyrk', 'lzsl', 'matm', 'nbun', 'ocvo', 'pdwp', 'qexq', 'rfyr', 'sgzs']]
while 1:
    try:
        s = raw_input()
        for w in l:
            for i in xrange(25):
                o = w[i]
                if s.find(w[i]) != -1:
                    r = ''
                    for c in s:
                        if c == ' ' or c == '.' : r+= c
                        else: r += chr((ord(c) - ord('a') - i) % 26 + ord('a'))
                    print r
                    break
            else:
                continue
            break
    except:
        break"
Python,"def func(a, b, c, d):
    k = (d - b) / (c - a)
    h = d - k * c
    return k, h
def fx(a, b, c, d, x):
    k, h = func(a, b, c, d)
    return k * x + h
def main():
    import sys
    for dataset in sys.stdin:
        ans = 'NO'
        try :
            a, b, c, d, e, f, px, py = map(float, dataset.split())
        except:
            break
        T = [(a, b), (c, d), (e, f)]
        T.sort(key=lambda x: (x[0], x[1]))
        a, b, c, d, e, f = T[0][0], T[0][1], T[1][0], T[1][1], T[2][0], T[2][1]
        
        if a == c:
            if  a < px and fx(a, b, e, f, px) < py and fx(c, d, e, f, px) > py:
                ans = 'YES'
        elif c == e:
            if px < e and fx(a, b, c, d, px) < py and fx(a, b, e, f, px) > py:
                ans = 'YES'
        else:  
            if fx(a, b, e, f, c) < d:  
                if fx(a, b, c, d, px) > py and fx(c, d, e, f, px) > py and fx(a, b, e, f, px) < py:
                    ans = 'YES'
            else:
                if fx(a, b, c, d, px) < py and fx(c, d, e, f, px) < py and fx(a, b, e, f, px) > py:
                    ans = 'YES'
        print(ans)
if __name__ == '__main__':
    main()"
Python,"import sys
def solve():
    while True:
        n = input()
        if n > 0:
            tmp_lst = []
            for i in xrange(n):
                tmp_lst.append(input())
            lst = compress(tmp_lst)
            accumurate_lst = calc_accumurate_lst(lst)
            max_value = - (10 ** 100)
            size = len(lst)
            for to in xrange(size):
                for frm in xrange(to + 1):
                    value = accumurate_lst[to] if frm == 0 else accumurate_lst[to] - accumurate_lst[frm - 1]
                    if max_value < value:
                        max_value = value
            print max_value
        else:
            sys.exit()
def calc_accumurate_lst(lst):
    accum = [0 for i in lst]
    accum[0] = lst[0]
    for i in xrange(1, len(lst)):
        accum[i] = accum[i - 1] + lst[i]
    return accum
        
def compress(tmp_lst):
    lim = len(tmp_lst)
    
    lst = []
    index = 0
    while index < lim:
        tmp = tmp_lst[index]
        index += 1
        while tmp > 0 and index < lim and tmp * tmp_lst[index] > 0:
            tmp += tmp_lst[index]
            index += 1
        lst.append(tmp)
    return lst
if __name__ == ""__main__"":
    solve()"
Python,"import sys
b = [ list(0 for i in range(14)) for j in range(14)]
def s(b,x,y):
    b[x][y]   += 1
    b[x+1][y] += 1
    b[x-1][y] += 1
    b[x][y+1] += 1
    b[x][y-1] += 1
def m(b,x,y):
    b[x-1][y-1] += 1
    b[x  ][y-1] += 1
    b[x+1][y-1] += 1
    b[x-1][y  ] += 1
    b[x  ][y  ] += 1
    b[x+1][y  ] += 1
    b[x-1][y+1] += 1
    b[x  ][y+1] += 1
    b[x+1][y+1] += 1
def l(b,x,y):
    b[x  ][y-2] += 1
    b[x-1][y-1] += 1
    b[x  ][y-1] += 1
    b[x+1][y-1] += 1
    b[x-2][y  ] += 1
    b[x-1][y  ] += 1
    b[x  ][y  ] += 1
    b[x+1][y  ] += 1
    b[x+2][y  ] += 1
    b[x-1][y+1] += 1
    b[x  ][y+1] += 1
    b[x+1][y+1] += 1
    b[x  ][y+2] += 1
for line in sys.stdin:
    d = list(map(int,line.split("","")))
    c = d[2]
    x = d[0] + 2
    y = d[1] + 2
    if c == 1:
        s(b,x,y)
    elif c == 2:
        m(b,x,y)
    elif c == 3:
        l(b,x,y)
ttl = 0
num = 0
max = 0
for x in range(2,12):
    for y in range(2,12):
        ttl += 1
        if b[x][y] == 0:
            num += 1
        if b[x][y] > max:
            max = b[x][y]
            
print(num)
print(max)"
Python,"while 1:
    try:
        n = int(input())
    except:break
    
    if(n == 0):break
    sum = 0
    arr = []
    isPlus = True
    maxValue = -100000
    for i in range (n):
        try:
            arr.append(int(input()))  
        except:break
           
        if arr[i] < 0:
            
            if sum > 0:
                
                if(isPlus):
                    
                    maxValue = max(maxValue,sum)
                    isPlus = False
                sum += arr[i]
                
                if sum < 0 :
                    sum = 0
        else :
            sum += arr[i]
            isPlus = True
    if sum != 0 :
        maxValue = max(maxValue,sum)
    
    else :
        for i in arr:
            maxValue = max(maxValue,i)
    print(maxValue)"
Python,"import sys
class math:
    
    pi = 3.14159265358979323846264338
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
math = math()
class output:
    
    def list(self, l):
        l = list(l)
        print("" "", end="""")
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
m = 100000
for i in range(int(input())):
    m *= 1.05
    if m%1000 != 0:
        m = (m//1000+1) * 1000
    else:
        m = (m//1000) * 1000
print(int(m))"
Python,"import sys
SIZE = 10
paper = []
def main():
    init()
    for line in sys.stdin:
        data = line.strip().split(',')
        i = int(data[0])
        j = int(data[1])
        size = int(data[2])
        if   size == 1:
            drop_small(i, j)
        elif size == 2:
            drop_medium(i, j)
        elif size == 3:
            drop_large(i, j)
    print count_white()
    print find_max()
def find_max():
    mx = 0
    for i in xrange(SIZE):
        for j in xrange(SIZE):
            mx = max(mx, paper[i][j])
    return mx
def count_white():
    c = 0
    for i in xrange(SIZE):
        for j in xrange(SIZE):
            if paper[i][j] == 0:
                c += 1
    return c
def init():
    global paper
    for i in xrange(SIZE):
        paper.append([0]*SIZE)
def check(i, j):
    if i < 0 or SIZE <= i:
        return False
    if j < 0 or SIZE <= j:
        return False
    return True
def drop(i, j):
    global paper
    if not check(i, j):
        return False
    paper[i][j] += 1
    return True
def drop_small(i, j):
    drop(i, j)
    drop(i - 1, j)
    drop(i + 1, j)
    drop(i, j - 1)
    drop(i, j + 1)
def drop_medium(i, j):
    drop_small(i, j)
    drop(i - 1, j - 1)
    drop(i - 1, j + 1)
    drop(i + 1, j - 1)
    drop(i + 1, j + 1)
def drop_large(i, j):
    drop_medium(i, j)
    drop(i - 2, j)
    drop(i, j - 2)
    drop(i, j + 2)
    drop(i + 2, j)
main()"
Python,"def stl1(x):
    if a == e:
        y = b
    else:
        y = (f-b)*(x-a)/(e-a) +b
    return(y)
def stl2(x):
    if c == e:
        y = f
    else:
        y = (d-f)*(x-e)/(c-e) +f
    return(y)
def stl3(x):
    if c == a:
        y = b
    else:
        y = (d-b)*(x-a)/(c-a) +b
        
    return(y)
while True:
    try:
        lst = list(map(float, input().split()))
        point1 = [lst[0], lst[1]]
        point2 = [lst[2], lst[3]]
        point3 = [lst[4], lst[5]]
        xp, yp = lst[6], lst[7]
        pointlst = [point1, point2, point3]
        pointlst.sort()
        a, b, e, f, c, d = pointlst[0][0], pointlst[0][1], pointlst[1][0], pointlst[1][1], pointlst[2][0], pointlst[2][1]
        if a <= xp and xp <= e:
            bdr1 = stl1(xp)
            bdr3 = stl3(xp)
            if min(bdr1, bdr3) <= yp and yp <= max(bdr1, bdr3):
                print(""YES"")
            else:
                print(""NO"")
        
        elif e < xp and xp <= c:
            bdr2 = stl2(xp)
            bdr3 = stl3(xp)
            if min(bdr2, bdr3) <= yp and yp <= max(bdr2, bdr3):
                print(""YES"")
            
            else:
                print(""NO"")
        else:
            print(""NO"")
    except EOFError:
        break"
Python,"def direction_vector(p1: list, p2: list)->list:
    return [p2[0]-p1[0], p2[1]-p1[1]]
def cross_product(v1: list, v2: list)->float:
    return v1[0]*v2[1] - v1[1]*v2[0]
if __name__ == '__main__':
    while True:
        try:
            points_receive = list(map(float, input().split()))
        except EOFError:
            break
        points_list = [[points_receive[2*i], points_receive[2 * i + 1]] for i in range(4)]
        p1_to_p2 = direction_vector(points_list[0], points_list[1])
        p2_to_p3 = direction_vector(points_list[1], points_list[2])
        p3_to_p1 = direction_vector(points_list[2], points_list[0])
        p1_to_pp = direction_vector(points_list[0], points_list[3])
        p2_to_pp = direction_vector(points_list[1], points_list[3])
        p3_to_pp = direction_vector(points_list[2], points_list[3])
        cp1 = cross_product(p1_to_p2, p1_to_pp)
        cp2 = cross_product(p2_to_p3, p2_to_pp)
        cp3 = cross_product(p3_to_p1, p3_to_pp)
        if cp1 > 0 and cp2 > 0 and cp3 > 0:
            print('YES')
        elif cp1 < 0 and cp2 < 0 and cp3 < 0:
            print('YES')
        else:
            print('NO')"
Python,"import sys
alpha = 'abcdefghijklmnopqrstuvwxyz'
def this(word):
    i=0
    t=[]
    for c in word:
        x=ord(c)-ord('this'[i])
        if x>=0:
            t.append(x)
        else:
            t.append(26+x)
    
        i+=1
    if(t[0]==t[1] and t[1]==t[2] and t[2]==t[3]):
        return t[0]
    return 30
def that(word):
    i=0
    t=[]
    for c in word:
        x=ord(c)-ord('that'[i])
        if x>=0:
            t.append(x)
        else:
            t.append(26+x)
    
        i+=1
    if(t[0]==t[1] and t[1]==t[2] and t[2]==t[3]):
        return t[0]
    return 30
def the(word):
    i=0
    t=[]
    for c in word:
        x=ord(c)-ord('the'[i])
        if x>=0:
            t.append(x)
        else:
            t.append(26+x)
    
        i+=1
    if(t[0]==t[1] and t[1]==t[2]):
        return t[0]
    return 30
for string in sys.stdin:
    for word in string.split("" ""):
        if(len(word)==3):
           if the(word) < 30:
               x=the(word)
               break
        if(len(word)==4):
           if this(word) <30:
               x=this(word)
               break
           if that(word) <30:
               x=that(word)
               break
    result=""""
    for c in string:
        if c in alpha:
            result+=alpha[alpha.find(c)-x]
        else:
            result+=c
    print result[:-1]"
Python,"import sys
def norm2d(vec):
    return (vec[0]**2 + vec[1]**2)**0.5
def normalize(vec):
    l = norm2d(vec)
    vec[0] /= l
    vec[1] /= l
    return vec
lineNumber = 0
for line in sys.stdin.readlines():
    lineNumber += 1
    if lineNumber == 1: continue
    
    List = map(float, line.strip().split("" ""))
    
    a = [List[0], List[1]]
    b = [List[2], List[3]]
    c = [List[4], List[5]]
    d = [List[6], List[7]]
    vec1 = [a[0]-b[0], a[1]-b[1]]
    vec2 = [c[0]-d[0], c[1]-d[1]]
    
    if vec1[0] < 0:
        vec1[0] *= -1
        vec1[1] *= -1
    if vec2[0] < 0:
        vec2[0] *= -1
        vec2[1] *= -1
    
    vec1 = normalize(vec1)
    vec2 = normalize(vec2)
    
    if     abs( vec1[0] - vec2[0] ) < 10**(-10) \\
       and abs( vec1[1] - vec2[1] ) < 10**(-10):
        print ""YES""
    else:
        print ""NO"""
Python,"from math import sqrt, fabs
def calcu_cirucumcenter(x1, y1, x2, y2, x3, y3):
    """"""
   ??????O?????§?¨????(x, y)??¨????????¨
   (x-x1)**2 + (y-y1)**2 = (x-x2)**2 + (y-y2)**2
   x**2 -2*x1*x + x1**2 + y**2 -2*y1*y + y1**2 = ... -2*x2*x, x2**2, -2*y2*y, y2**2
   ?????¨????????¨ (-2*x1 + 2*x2)x + (-2y1 + 2*y2)y + (x1**2 + y1**2 - x2**2 - y2**2) = 0
   x1, x3???????????????????§????
   (-2*x1 + 2*x3)x + (-2y1 + 2*y3)y + (x1**2 + y1**2 - x3**2 - y3**2) = 0
   
   ??????????????¢????????\\????????¢???????????£???????¨??????¨???????§£???
   | a b | = |e|
   | c d |   |f|
   """"""
    a = -2 * x1 + 2 * x2
    b = -2 * y1 + 2 * y2
    c = -2 * x1 + 2 * x3
    d = -2 * y1 + 2 * y3
    e = -1* (x1 ** 2 + y1 ** 2 - x2 ** 2 - y2 ** 2)
    f = -1 * (x1 ** 2 + y1 ** 2 - x3 ** 2 - y3 ** 2)
    x = 1 / (a * d - b * c) * (d * e - b * f)
    y = 1 / (a * d - b * c) * (-c * e + a * f)
    return x, y
if __name__ == '__main__':
    epsilon = 1e-9
    
    num = int(input())
    for i in range(num):
        x1, y1, x2, y2, x3, y3 = [float(x) for x in input().split(' ')]
        
        x, y = calcu_cirucumcenter(x1, y1, x2, y2, x3, y3)
        
        if fabs(x) < epsilon:
            x = 0.0
        if fabs(y) < epsilon:
            y = 0.0
        
        r = sqrt((x - x1)**2 + (y - y1)**2)
        print('{0:.3f} {1:.3f} {2:.3f}'.format(x, y, r))"
Python,"import math
def my_round(x,d=0):
    p = 10 ** d
    return float(math.floor((x * p) + math.copysign(0.5, x))) / p
class Equation():
    def __init__(self, a, b, c, d, e, f):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f
    def calc(self):
        temp = (self.a * self.e - self.b * self.d)
        temp_a = (self.c * self.e - self.b * self.f)
        temp_b = (self.a * self.f - self.c * self.d)
        try:
            x = round(temp_a / temp+0., 3)
        except ZeroDivisionError:
            x = round(temp_a / 1.0, 4)
        try:
            y = round(temp_b / temp+0., 3)
        except:
            y = round(temp_b / 1.0, 4)
        return x, y
    def print(self):
        ans = self.calc()
        print(""{0:.3f} {1:.3f}"".format(ans[0], ans[1]))
def main():
    data = []
    while 1:
        try:
            n = input().split()
            a = float(n[0])
            b = float(n[1])
            c = float(n[2])
            d = float(n[3])
            e = float(n[4])
            f = float(n[5])
            data.append(Equation(a, b, c, d, e, f))
        except EOFError:
            break
    for num in data:
        num.print()
if __name__ == ""__main__"":
    main()"
Python,"import sys
def small(grid, x, y):
    grid[x][y] += 1
    grid[x + 1][y] += 1
    grid[x][y + 1] += 1
    grid[x][y - 1] += 1
    grid[x - 1][y] += 1
    return grid
def middle(grid, x, y):
    grid[x][y] += 1
    grid[x + 1][y] += 1
    grid[x][y + 1] += 1
    grid[x][y - 1] += 1
    grid[x - 1][y] += 1
    grid[x - 1][y - 1] += 1
    grid[x - 1][y + 1] += 1
    grid[x + 1][y + 1] += 1
    grid[x + 1][y - 1] += 1
    return grid
def large(grid, x, y):
    grid[x][y] += 1
    grid[x + 1][y] += 1
    grid[x][y + 1] += 1
    grid[x][y - 1] += 1
    grid[x - 1][y] += 1
    grid[x - 1][y - 1] += 1
    grid[x - 1][y + 1] += 1
    grid[x + 1][y + 1] += 1
    grid[x + 1][y - 1] += 1
    grid[x][y + 2] += 1
    grid[x][y - 2] += 1
    grid[x + 2][y] += 1
    grid[x - 2][y] += 1
    return grid
grid = [[0 for _ in range(14)] for __ in range(14)]
for line in sys.stdin:
    d = list(map(int, line.split("","")))
    x = d[0] + 2
    y = d[1] + 2
    ink_size = d[2]
    if ink_size == 1:
        grid = small(grid, x, y)
    elif ink_size == 2:
        grid = middle(grid, x, y)
    else:
        grid = large(grid, x, y)
max_element = 0
count = 0
for i in range(2, 12):
    for j in range(2, 12):
        max_element = max(max_element, grid[i][j])
        if grid[i][j] == 0:
            count += 1
print(count)
print(max_element)"
Python,"from math import sqrt
n = int(input())
for i in range(n):
    tmp = input().split(' ')
    
    a, b, c = [(float(tmp[i]), float(tmp[i+1])) for i in range(0, len(tmp), 2)]
    
    
    
    
    A_tmp1 = 1/(a[0]*b[1] + a[1]*c[0] + b[0]*c[1] - b[1]*c[0] - a[1]*b[0] - a[0]*c[1])
    A_tmp2 = [[b[1]-c[1], -(a[1]-c[1]), a[1]-b[1]],
              [-(b[0]-c[0]),  (a[0]-c[0]), -(a[0]-b[0])],
              [b[0]*c[1] - b[1]*c[0], -(a[0]*c[1] - a[1]*c[0]), a[0]*b[1] - a[1]*b[0]]]
    A = [list(map(lambda x: A_tmp1*x, A_tmp2[i])) for i in range(3)]
    
    
    
    
    B = [[-(a[0]**2 + a[1]**2)],
         [-(b[0]**2 + b[1]**2)],
         [-(c[0]**2 + c[1]**2)]]
    
    
    tmp = [sum([A[i][j]*B[j][0] for j in range(3)]) for i in range(3)]
    
    
    x = -tmp[0]/2
    y = -tmp[1]/2
    r = sqrt((tmp[0]**2 + tmp[1]**2 - 4*tmp[2])/4)
    
    print('{:.3f} {:.3f} {:.3f}'.format(x, y, r))"
Python,"import cmath
class Point(object):
    def __init__(self, x, y):
        self.point = complex(x, y)
    def __str__(self):
        return ""x = {0}, y = {1}"".format(self.point.real, self.point.imag)
class Triangle(Point):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
        
        self.edgeA = abs(b.point-c.point)
        self.edgeB = abs(c.point-a.point)
        self.edgeC = abs(a.point-b.point)
        
        self.angleA = Triangle.angle(self.edgeA, self.edgeB, self.edgeC)
        self.angleB = Triangle.angle(self.edgeB, self.edgeC, self.edgeA)
        self.angleC = Triangle.angle(self.edgeC, self.edgeA, self.edgeB)
    
    def angle(A, B, C):
        return cmath.acos( (B*B+C*C-A*A)/(2*B*C) )
    
    def circumscribedCircleRadius(self):
        return abs((self.edgeA/cmath.sin(self.angleA))/2)
    
    def circumscribedCircleCenter(self):
        A = cmath.sin(2*self.angleA)
        B = cmath.sin(2*self.angleB)
        C = cmath.sin(2*self.angleC)
        X = (self.a.point.real*A + self.b.point.real*B + self.c.point.real*C) / (A+B+C)
        Y = (self.a.point.imag*A + self.b.point.imag*B + self.c.point.imag*C) / (A+B+C)
        return complex(X, Y)
n = int(input())
for i in range(n):
    line = list(map(float, input().split()))
    p1 = Point(line[0], line[1])
    p2 = Point(line[2], line[3])
    p3 = Point(line[4], line[5])
    T = Triangle(p1, p2, p3)
    center = T.circumscribedCircleCenter()
    print(""{0:.3f} {1:.3f} {2:.3f}"".format(center.real, center.imag, T.circumscribedCircleRadius()))"
Python,"import sys
import math
import array
class mymath:
    
    pi = 3.14159265358979323846264338
    
    def pnum_eratosthenes(self, n):
        ptable = [0 for i in range(n+1)]
        plist = []
        for i in range(2, n+1):
            if ptable[i]==0:
                plist.append(i)
                for j in range(i+i, n+1, i):
                    ptable[j] = 1
        return plist
    def pnum_fermat(self,n):
        pnum = 0
        for i in range(2,n+1):
            if i % 2 == 0 and i != 2:
                continue
            if pow(2,i-1,i) == 1:
                pnum += 1
        return pnum
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
mymath = mymath()
class output:
    
    def list(self, l):
        l = list(l)
        print("" "", end="""")
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
def main():
    for line in sys.stdin.readlines():
        n = int(line)
        n_pn = mymath.pnum_eratosthenes(n)
        print(len(n_pn))
if __name__ == '__main__':
    main()"
Python,"import collections
import math
LIMIT = 1e-10
class Vector2(collections.namedtuple(""Vector2"", ""x y"")):
    __slots__ = ()
    def __add__(self, other):
        return Vector2(self.x + other.x, self.y + other.y)
    def __sub__(self, other):
        return Vector2(self.x - other.x, self.y - other.y)
    def __mul__(self, other):
        return self.x * other.y - self.y * other.x
    def __neg__(self):
        return Vector2(-self.x, -self.y)
    def __pos__(self):
        return Vector2(+self.x, +self.y)
    def __abs__(self):
        return math.sqrt(float(self.x * self.x + self.y * self.y))
    def dotproduct(self, other):
        return self.x * other.x + self.y * other.y
def main():
    n = int(input())
    for i in range(n):
        [x1, y1, x2, y2, x3, y3, x4, y4] = [float(z) for z in input().split()]
        vector_ab = Vector2(x2 - x1, y2 - y1)
        vector_cd = Vector2(x4 - x3, y4 - y3)
        if abs(vector_ab * vector_cd) < LIMIT:
            print(""YES"")
        else:
            print(""NO"")
if __name__ == ""__main__"":
    main()"
Python,"import sys
def gcd(a, b):
    return gcd(b, a % b) if a % b else b
def lcm(a, b):
    return a * b / gcd(a, b)
for line in sys.stdin:
    data = map(int, line.split())
    a, b, c, d, e, f = data
    if a == 0:
        y = c * 1.0 / b
        x = (f - e * y) * 1.0 / d
        print ""%.3f %.3f"" % (round(x, 4), round(y, 4))
        continue
    if b == 0:
        x = c * 1.0 / a
        y = (f - d * x) * 1.0 / e
        print ""%.3f %.3f"" % (round(x, 4), round(y, 4))
        continue
    if d == 0:
        y = f * 1.0 / e
        x = (c - b * y) * 1.0 / a
        print ""%.3f %.3f"" % (round(x, 4), round(y, 4))
        continue
    if e == 0:
        x = f * 1.0 / d
        y = (c - a * x) * 1.0 / b
        print ""%.3f %.3f"" % (round(x, 4), round(y, 4))
        continue
    ix = lcm(a, d) / a
    jx = lcm(a, d) / d
    iy = lcm(b, e) / b
    jy = lcm(b, e) / e
    x = (c*1.0*iy - f*jy) / (a*iy - d*jy)
    y = (c*1.0*ix - f*jx) / (b*ix - e*jx)
    print ""%.3f %.3f"" % (round(x, 4), round(y, 4))"
Python,"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools
sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)
def distance(x1, y1, x2, y2):
    return math.sqrt((x1-x2)**2 + (y1-y2)**2)
def intersection(a1, a2, b1, b2):
    x1,y1 = a1
    x2,y2 = a2
    x3,y3 = b1
    x4,y4 = b2
    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)
    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)
    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)
    if delta == 0:
        return None
    ramda = ksi / delta;
    mu = eta / delta;
    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:
        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))
    return None
def circumcenters(a,b,c):
    t1 = [(a[0]+b[0])/2, (a[1]+b[1])/2]
    s1 = [t1[1]-a[1], a[0]-t1[0]]
    t2 = [(a[0]+c[0])/2, (a[1]+c[1])/2]
    s2 = [t2[1]-a[1], a[0]-t2[0]]
    p1 = [t1[0]+s1[0]*1e7, t1[1]+s1[1]*1e7]
    p2 = [t1[0]-s1[0]*1e7, t1[1]-s1[1]*1e7]
    p3 = [t2[0]+s2[0]*1e7, t2[1]+s2[1]*1e7]
    p4 = [t2[0]-s2[0]*1e7, t2[1]-s2[1]*1e7]
    return intersection(p1,p2,p3,p4)
def main():
    n = I()
    rr = []
    for _ in range(n):
        x1,y1,x2,y2,x3,y3 = LF()
        a = [x1,y1]
        b = [x2,y2]
        c = [x3,y3]
        t = circumcenters(a,b,c)
        rr.append('{:0.3f} {:0.3f} {:0.3f}'.format(t[0], t[1], distance(t[0],t[1],x1,y1)))
    return '\\n'.join(rr)
print(main())"
Python,"def solve(a, b, c, d, e, f):
    agn = a*e - b*d
    x = (e*c - b*f)/float(agn)
    y = (-d*c + a*f)/float(agn)
    if x == 0.: x = 0.
    if y == 0.: y = 0.
    return (x, y)
   
while 1:
    try:
        n = input()
        for i in xrange(n):
            x = [0 for i in xrange(3)]
            y = [0 for i in xrange(3)]
            a,b,t = [[0 for i in xrange(2)] for i in xrange(3)]
            p,q,s = [[0 for i in xrange(2)] for i in xrange(3)]
            x[0],y[0],x[1],y[1],x[2],y[2] = map(float, raw_input().split())
            for j in xrange(2):
                a[j] = (x[j+1] + x[j])/2
                b[j] = (y[j+1] + y[j])/2
                if x[j+1] - x[j] == 0.:
                    p[j] = 0.
                    q[j] = -1.
                    s[j] = -b[j]
                elif y[j+1] - y[j] == 0.:
                    p[j] = -1.
                    q[j] = 0.
                    s[j] = -a[j]
                else:
                    t[j] = (y[j+1] - y[j]) / (x[j+1] - x[j])
                    p[j] = -1./t[j]
                    q[j] = -1.
                    s[j] = -(a[j]/t[j])-b[j]
            c = solve(p[0], q[0], s[0], p[1], q[1], s[1])
            r = ((x[0]-c[0])**2 + (y[0]-c[1])**2)**0.5
            print ""%.3f %.3f %.3f"" % (c[0], c[1], r)
    except EOFError:
        break"
Python,"def check(x,i,y,j):
    flagx=True if (x+i>=0 and x+i<=9) else False
    flagy=True if (y+j>=0 and y+j<=9) else False
    return (flagx and flagy)
def main():
    LIST=[]
    for i in range(10):
        LIST.append([0,0,0,0,0,0,0,0,0,0])
        count=0
        M=0
    while True:
        try:
            x,y,size=map(int,input().split("",""))
            if size==1:
                for i in range(-1,2):
                    for j in range(-1,2):
                        if check(x,i,y,j) and abs(i)+abs(j)<=1:
                            LIST[y+j][x+i]+=1
            elif size==2:
                for i in range(-1,2):
                    for j in range(-1,2):
                        if check(x,i,y,j) and abs(i)+abs(j)<=2:
                            LIST[y+j][x+i]+=1
            elif size==3:
                for i in range(-2,3):
                    for j in range(-2,3):
                        if check(x,i,y,j) and abs(i)+abs(j)<=2:
                            LIST[y+j][x+i]+=1
            
        except:
            break
    for item in LIST:
        tmp=max(x for x in item)
        M=max(tmp,M)
    for item in LIST:
        count+=item.count(0)
    print(count)
    print(M)
    
        
if __name__ == '__main__':
    main()"
Python,"import sys
def prod_mat_vec(A, vec):
    ret = [0 for i in xrange(3)]
    for i in xrange(3):
        for j in xrange(3):
            ret[i] += A[i][j] * vec[j]
    return ret
def changerow(A, i1, i2):
    for j in xrange(3):
        buf = A[i1][j]
        A[i1][j] = A[i2][j]
        A[i2][j] = buf
    return A
def MatrixInverse3x3(A_src):
    A = [ [A_src[i][j] for j in xrange(3)] for i in xrange(3) ] 
    B = [ [1, 0, 0], \\
          [0, 1, 0], \\
          [0, 0, 1]  ]
    
    for i in xrange(3):
        if A[i][i] == 0:
            for k in xrange(i+1, 3):
                if A[k][k] != 0:
                    A = changerow(A, i, k)
                    B = changerow(B, i, k)
        a = A[i][i]
        for j in xrange(3):
            A[i][j] /= a
            B[i][j] /= a
        for k in xrange(3):
            if i == k: continue
            a = A[k][i]
            for j in xrange(3):
                A[k][j] -= A[i][j] * a
                B[k][j] -= B[i][j] * a
    return B
def output3x3(A):
    for i in xrange(3):
        print ""%7.3f %7.3f %7.3f"" % (A[i][0], A[i][1], A[i][2])
    return
for line in sys.stdin.readlines():
    List = map(float, line.strip().split())
    if len(List) == 1: continue
    [x1, y1, x2, y2, x3, y3] = List
    A = [ [x1, y1, 1.0] ,\\
          [x2, y2, 1.0] ,\\
          [x3, y3, 1.0]  ]
    vec = [x1**2+y1**2, x2**2+y2**2, x3**2+y3**2]
    B = MatrixInverse3x3(A)
    lmn = prod_mat_vec(B, vec)
    ans = [0.5*lmn[0], 0.5*lmn[1], (lmn[2]+0.25*lmn[0]**2+0.25*lmn[1]**2)**0.5]
    print ""%.3f %.3f %.3f"" % (ans[0], ans[1], ans[2])
    
    
    "
Python,"import string
import sys
def check_exists(word_set, rotate_dict, search):
    for word in word_set:
        rotated_word = ''.join(rotate_dict[s] for s in word)
        if rotated_word == search:
            return True
    return False
for line in sys.stdin:
    alphabets = string.ascii_lowercase
    frequency = [t[1] for t in sorted([(line.count(s), ord(s)) for s in alphabets], reverse=True)]
    freq_chr_offset = (4, 0, 19, 8, 14)
    ss = list(map(lambda word: word.strip('.\\n'), line.split()))
    sl3, sl4 = set(s for s in ss if len(s) == 3), set(s for s in ss if len(s) == 4)
    i, rotate_dict = 0, None
    for order in frequency:
        for offset in freq_chr_offset:
            i = 97 + offset - order
            rotate_dict = {a: b for a, b in zip(alphabets, alphabets[i:] + alphabets[:i])}
            if (check_exists(sl3, rotate_dict, 'the')
                    + check_exists(sl4, rotate_dict, 'this')
                    + check_exists(sl4, rotate_dict, 'that')) > 0:
                break
        else:
            continue
        break
    print(''.join(rotate_dict[s] if s.isalpha() else s for s in line), end='')"
Python,"import sys
def small_inc(x, y, cells):
    cells[x][y] += 1
    if y > 0:
        cells[x][y-1] += 1
    if x > 0:
        cells[x-1][y] += 1
    if x < MAPSIZE-1:
        cells[x+1][y] += 1
    if y < MAPSIZE-1:
        cells[x][y+1] += 1
def medium_inc(x, y, cells):
    if y > 0:
        cells[x][y-1] += 1
        if x > 0:
            cells[x-1][y-1] += 1
        if x < MAPSIZE-1:
            cells[x+1][y-1] += 1
    cells[x][y] += 1
    if x > 0:
        cells[x-1][y] += 1
    if x < MAPSIZE-1:
        cells[x+1][y] += 1
    if y < MAPSIZE-1:
        cells[x][y+1] += 1
        if x > 0:
            cells[x-1][y+1] += 1
        if x < MAPSIZE-1:
            cells[x+1][y+1] += 1
def large_inc(x, y, cells):
    if y > 1:
        cells[x][y-2] += 1
    if y > 0:
        cells[x][y-1] += 1
        if x > 0:
            cells[x-1][y-1] += 1
        if x < MAPSIZE-1:
            cells[x+1][y-1] += 1
    cells[x][y] += 1
    if x > 1:
        cells[x-2][y] += 1
    if x > 0:
        cells[x-1][y] += 1
    if x < MAPSIZE-1:
        cells[x+1][y] += 1
    if x < MAPSIZE-2:
        cells[x+2][y] += 1
    if y < MAPSIZE-1:
        cells[x][y+1] += 1
        if x > 0:
            cells[x-1][y+1] += 1
        if x < MAPSIZE-1:
            cells[x+1][y+1] += 1
    if y < MAPSIZE-2:
        cells[x][y+2] += 1
SMALL = 1
MEDIUM = 2
LARGE = 3
MAPSIZE = 10
cells = [[0 for i in range(MAPSIZE)] for j in range(MAPSIZE)]
for line in sys.stdin:
    x , y, size = map(int, line.split(','))
    if size == SMALL:
        small_inc(x, y, cells)
    elif size == MEDIUM:
        medium_inc(x, y, cells)
    elif size == LARGE:
        large_inc(x, y, cells)
count = max_d = 0
for i in range(MAPSIZE):
    for j in range(MAPSIZE):
        if cells[i][j] == 0:
            count += 1
        else:
            max_d = max(max_d, cells[i][j])
print count
print max_d"
Python,"def check(x, y):
    return 0 <= x <= 9 and 0 <= y <= 9
def small(x, y, area):
    if check(x+1, y):
        area[x+1][y] += 1
    if check(x, y+1):
        area[x][y+1] += 1
    if check(x-1, y):
        area[x-1][y] += 1
    if check(x, y-1):
        area[x][y-1] += 1
    area[x][y] += 1
    return area
def mediam(x, y, area):
    area = small(x, y, area)
    if check(x+1, y+1):
        area[x+1][y+1] += 1
    if check(x+1, y-1):
        area[x+1][y-1] += 1
    if check(x-1, y+1):
        area[x-1][y+1] += 1
    if check(x-1, y-1):
        area[x-1][y-1] += 1
    return area
def large(x, y, area):
    area = mediam(x, y, area)
    if check(x+2, y):
        area[x+2][y] += 1
    if check(x, y+2):
        area[x][y+2] += 1
    if check(x-2, y):
        area[x-2][y] += 1
    if check(x, y-2):
        area[x][y-2] += 1
    return area
area = [[0 for i in range(10)] for j in range(10)]
while True:
    try:
        x, y, s = map(int, input().split(','))
    except:
        break
    if s == 1:
        area = small(x, y, area)
    if s == 2:
        area = mediam(x, y, area)
    if s == 3:
        area = large(x, y, area)
max = 0
cnt = 0
for i in range(10):
    for j in range(10):
        if area[i][j] == 0:
            cnt += 1
        if area[i][j] > max:
            max = area[i][j]
print(cnt)
print(max)"
Python,"import sys
class Point(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def isLeft(self, vector):
        tmpVector = DirectedVector(vector.start, self)
        sin = tmpVector * vector
        if sin > 0:
            return True
        else:
            return False
class DirectedVector(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
    @property
    def x(self):
        return self.end.x - self.start.x
    @property
    def y(self):
        return self.end.y - self.start.y
    def __mul__(self, other):
        return self.x * other.y - self.y * other.x
def getDataSets():
    for line in sys.stdin.readlines():
        line = line.strip()
        x1, y1, x2, y2, x3, y3, xp, yp = [float(x) for x in line.split()]
        p1 = Point(x1, y1)
        p2 = Point(x2, y2)
        p3 = Point(x3, y3)
        px = Point(xp, yp)
        yield p1, p2, p3, px
def main():
    for p1, p2, p3, px in getDataSets():
        evaluate = [
                px.isLeft(DirectedVector(p1, p2)),
                px.isLeft(DirectedVector(p2, p3)),
                px.isLeft(DirectedVector(p3, p1)),
                ]
        if(all(evaluate) or not any(evaluate)):
            print 'YES'
        else:
            print 'NO'
if __name__ == ""__main__"":
    main()"
Python,"answermap=[0]*51
answermap[0] = 1
answermap[1] = 4
answermap[2] = 10
answermap[3] = 20
answermap[4] = 35
answermap[5] = 56
answermap[6] = 84
answermap[7] = 120
answermap[8] = 165
answermap[9] = 220
answermap[10] = 282
answermap[11] = 348
answermap[12] = 415
answermap[13] = 480
answermap[14] = 540
answermap[15] = 592
answermap[16] = 633
answermap[17] = 660
answermap[18] = 670
answermap[19] = 660
answermap[20] = 633
answermap[21] = 592
answermap[22] = 540
answermap[23] = 480
answermap[24] = 415
answermap[25] = 348
answermap[26] = 282
answermap[27] = 220
answermap[28] = 165
answermap[29] = 120
answermap[30] = 84
answermap[31] = 56
answermap[32] = 35
answermap[33] = 20
answermap[34] = 10
answermap[35] = 4
answermap[36] = 1
answermap[37] = 0
answermap[38] = 0
answermap[39] = 0
answermap[40] = 0
answermap[41] = 0
answermap[42] = 0
answermap[43] = 0
answermap[44] = 0
answermap[45] = 0
answermap[46] = 0
answermap[47] = 0
answermap[48] = 0
answermap[49] = 0
answermap[50] = 0
inputs = []
while True:
  try:
    inputs.append(int(input()))
  except EOFError:
    break
for i in inputs:
  print(answermap[i])"
Python,"import sys
import cmath
import math
class Point(object):
    def __init__(self, x, y):
        self.point = complex(x, y)
    def __str__(self):
        return ""x = {0}, y = {1}"".format(self.point.real, self.point.imag)
class Triangle(Point):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
        
        self.edgeA = abs(b.point-c.point)
        self.edgeB = abs(c.point-a.point)
        self.edgeC = abs(a.point-b.point)
        
        self.angleA = Triangle.angle(self.edgeA, self.edgeB, self.edgeC)
        self.angleB = Triangle.angle(self.edgeB, self.edgeC, self.edgeA)
        self.angleC = Triangle.angle(self.edgeC, self.edgeA, self.edgeB)
    
    def angle(A, B, C):
        return cmath.acos( (B*B+C*C-A*A)/(2*B*C) ).real
eps = 0.0001
for line in sys.stdin:
    line = [float(x) for x in line.split()]
    p1 = Point(line[0], line[1])
    p2 = Point(line[2], line[3])
    p3 = Point(line[4], line[5])
    P  = Point(line[6], line[7])
    t1 = Triangle(p1, p2, P)
    t2 = Triangle(p2, p3, P)
    t3 = Triangle(p3, p1, P)
    if (math.degrees(t1.angleC + t2.angleC + t3.angleC) <= 360+eps) and (math.degrees(t1.angleC + t2.angleC + t3.angleC) >= 360-eps):
        print(""YES"")
    else:
        print(""NO"")"
Python,"def get_input():
    while True:
        try:
            yield """".join(input())
        
        except EOFError:
            break
            
def calcGCD(a,b):
    if a>b:
        large = a
        small = b
    elif a<b:
        large = b
        small = a
    else:
        return a
        
    
    while True:
        
        if large == small:
            return large
        
        temp_small = large - small
        
        if temp_small < small:
            large = small
            small = temp_small 
        else:
            large = temp_small
            small = small
def calcLCM(a,b,gcd):
    lcm = a*b/gcd
    
    return lcm
    
if __name__  == ""__main__"":
    array = list(get_input())
    for i in range(len(array)):
    
        temp_a,temp_b = array[i].split()
    
        a,b = int(temp_a),int(temp_b)
    
        gcd = calcGCD(a,b)
        lcm = calcLCM(a,b,gcd)
        lcm = int(lcm)
        
        print(""{} {}"".format(gcd,lcm))"
Python,"pap = [[0 for x in range(10)] for y in range(10)]
def brot(x,y,s):
    if s==1:
        for dx in range(-1,+1+1):
            for dy in range(-1,+1+1):
                px = x + dx    
                py = y + dy
                if abs(dx)+abs(dy)<2 and px in range(0,10) and py in range(0,10):
                    pap[py][px] += 1
    elif s==2:
        for dx in range(-1,+1+1):
            for dy in range(-1,+1+1):
                px = x + dx    
                py = y + dy
                if px in range(0,10) and py in range(0,10):
                    pap[py][px] += 1
    elif s==3:
        for dx in range(-2,+2+1):
            for dy in range(-2,+2+1):
                px = x + dx    
                py = y + dy
                if abs(dx)+abs(dy)<3 and px in range(0,10) and py in range(0,10):
                    pap[py][px] += 1
    else:
        raise(ValueError) 
def ans():
    bmax = 0
    wcount = 0
    for y in range(0,+9+1):
        for x in range(0,+9+1):
            b = pap[y][x]
            if b > bmax:
                bmax = b
            elif b == 0:
                wcount += 1
    return(wcount,bmax)
while True:
    try:
        x,y,s = list(map(int, input().split(',')))
        brot(x,y,s)
    except EOFError:
       break
print(""%d\\n%d"" % ans())"
Python,"import sys
import math
class mymath:
    
    pi = 3.14159265358979323846264338
    
    def pnum_eratosthenes(self, n):
        ptable = [0 for i in range(n+1)]
        plist = []
        for i in range(2, n+1):
            if ptable[i]==0:
                plist.append(i)
                for j in range(i+i, n+1, i):
                    ptable[j] = 1
        return plist
    def pnum_check(self, n):
        if (n==1):
            return False
        elif (n==2):
            return True
        else:
            for x in range(2,n):
                if(n % x==0):
                    return False
            return True
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
    
    def mul(self, A, B):
        ans = []
        for a in A:
            c = 0
            for j, row in enumerate(a):
                c += row*B[j]
            ans.append(c)
        return ans
    
    
    def is_integer(self, n):
        try:
            float(n)
        except ValueError:
            return False
        else:
            return float(n).is_integer()
    
    def dist(self, A, B):
        d = 0
        for i in range(len(A)):
            d += (A[i]-B[i])**2            
        d = d**(1/2)
        return d
    
    def abs(self, n):
        if n >= 0:
            return n
        else:
            return -n   
mymath = mymath()
class output:
    
    def list(self, l):
        l = list(l)
        
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
def printA(A):
    N = len(A)
    for i, n in enumerate(A):
        print(n, end='')
        if i != N-1:
            print(' ', end='')
    print()
def get_input():
    N = []
    while True:
        try:
            
            
            
            N.append([int(x) for x in input().split()])
        except EOFError:
            break
    return N
s = input()
print(str.upper(s))"
Python,"if __name__ == '__main__':
    while True:
        
        loop = int(input())
        if loop == 0:
            break
        data = [int(input()) for _ in range(loop)]
        
        max_total = max(data)  
        total = 0
        for d in data:
            if d > 0:  
                total += d  
                if total > max_total:
                    max_total = total
            else:  
                if total > abs(d):  
                    total += d
                    
                else:
                    total = 0  
        
        print(max_total)"
Python,"import sys
import math
class mymath:
    
    pi = 3.14159265358979323846264338
    
    def pnum_eratosthenes(self, n):
        ptable = [0 for i in range(n+1)]
        plist = []
        for i in range(2, n+1):
            if ptable[i]==0:
                plist.append(i)
                for j in range(i+i, n+1, i):
                    ptable[j] = 1
        return plist
    def pnum_check(self, n):
        if (n==1):
            return False
        elif (n==2):
            return True
        else:
            for x in range(2,n):
                if(n % x==0):
                    return False
            return True
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
    
    def mul(self, A, B):
        ans = []
        for a in A:
            c = 0
            for j, row in enumerate(a):
                c += row*B[j]
            ans.append(c)
        return ans
    
    
    def is_integer(self, n):
        try:
            float(n)
        except ValueError:
            return False
        else:
            return float(n).is_integer()
    
    def dist(self, A, B):
        d = 0
        for i in range(len(A)):
            d += (A[i]-B[i])**2            
        d = d**(1/2)
        return d
    
    def abs(self, n):
        if n >= 0:
            return n
        else:
            return -n   
mymath = mymath()
class output:
    
    def list(self, l):
        l = list(l)
        
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
def printA(A):
    N = len(A)
    for i, n in enumerate(A):
        print(n, end='')
        if i != N-1:
            print(' ', end='')
    print()
def get_input():
    N = []
    while True:
        try:
            
            
            
            N.append([int(x) for x in input().split()])
        except EOFError:
            break
    return N
n = int(input())
ans = 1
for i in range(1,n+1):
    ans *= i
print(ans)"
Python,"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy
 
sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7
 
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
 
 
class Matrix():
    def __init__(self, A):
        self.A = A
        self.row = len(A)
        self.col = len(A[0])
 
    def __iter__(self):
        return self.A.__iter__()
 
    def __getitem__(self, i):
        return self.A.__getitem__(i)
 
    def __add__(self, B):
        aa = self.A
        bb = B.A
        return Matrix([[aa[i][j] + bb[i][j] for j in range(self.col)] for i in range(self.row)])
 
    def __sub__(self, B):
        aa = self.A
        bb = B.A
        return Matrix([[aa[i][j] - bb[i][j] for j in range(self.col)] for i in range(self.row)])
 
    def __mul__(self, B):
        aa = self.A
        bb = B.A
        a = []
        for i in range(self.row):
            ai = aa[i]
            r = []
            for j in range(B.col):
                r.append(sum([ai[k] * bb[k][j] for k in range(self.col)]))
            a.append(r)
        return Matrix(a)
 
    def __truediv__(self, x):
        pass
 
    def lu(self):
        size = self.row
        T = copy.deepcopy(self.A)
        L = [[0]*size for _ in range(size)]
        U = [[0]*size for _ in range(size)]
        for i in range(size):
            for j in range(i,size):
                L[j][i] = T[j][i]
            for j in range(i,size):
                U[i][j] = T[i][j] / T[i][i]
            for j in range(i+1,size):
                for k in range(i+1,size):
                    T[j][k] -= L[j][i] * U[i][k]
 
        return Matrix(L),Matrix(U)
 
    def __str__(self):
        return self.A.__str__()
 
def solve_se(A, b):
    n = A.row
    L,U = A.lu()
    y = []
    for i in range(n):
        t = b[i]
        for k in range(i):
            t -= L[i][k] * y[k]
        y.append(t / L[i][i])
 
    x = [0] * n
    for i in range(n-1,-1,-1):
        t = y[i]
        for k in range(i+1,n):
            t -= U[i][k] * x[k]
        x[i] = t
    return x
 
 
def main():
    sa = [s for s in sys.stdin.read().split('\\n') if s]
    r = []
    for s in sa:
        a,b,c,d,e,f = [int(c) for c in s.split()]
        A = Matrix([[a,b],[d,e]])
        B = [c,f]
        x = solve_se(A,B)
        r.append(' '.join(map(lambda t: '{:01.3f}'.format(1.0*t), x)))
 
    return '\\n'.join(r)
 
print(main())"
Python,"while True:
	try:
		x1, y1, x2, y2, x3, y3, xp, yp = map(float, raw_input().split())
		xg = 1./3 * (x1 + x2 + x3)
		yg = 1./3 * (y1 + y2 + y3)
		
		def line(xi, yi, xj, yj, x, y):
			return (yi-yj)*x/(xi-xj) + (xi*yj-xj*yi)/(xi-xj)
		
		if x1 != x2:
			def line12(x, y):
				if y < line(x1, y1, x2, y2, x, y):
					return 2
				elif y > line(x1, y1, x2, y2, x, y):
					return 3
				else:
					return 0
		else:
			def line12(x, y):
				if x1 < x:
					return 2
				elif x1 > x:
					return 3
				else:
					return 0
		if x2 != x3:
			def line23(x, y):
				if y < line(x2, y2, x3, y3, x, y):
					return 5
				elif y > line(x2, y2, x3, y3, x, y):
					return 7
				else:
					return 0
		else:
			def line23(x, y):
				if x2 < x:
					return 5
				elif x2 > x:
					return 7
				else:
					return 0
		if x1 != x3:
			def line13(x, y):
				if y < line(x1, y1, x3, y3, x, y):
					return 11
				elif y > line(x1, y1, x3, y3, x, y):
					return 13
				else:
					return 0
		else:
			def line13(x, y):
				if x1 < x:
					return 11
				elif x1 > x:
					return 13
				else:
					return 0
		if line12(xp, yp)*line23(xp, yp)*line13(xp, yp) == line12(xg, yg)*line23(xg, yg)*line13(xg, yg):
			print(""YES"")
		else:
			print(""NO"")
	except EOFError:
		break"
Python,"import sys
def prod2d(vec1, vec2):
    return vec1[0]*vec2[1] - vec1[1]*vec2[0]
lineNumber = 0
for line in sys.stdin.readlines():
    lineNumber += 1
    
    List = map(float, line.strip().split())
    
    nodes = [ [List[0], List[1]], [List[2], List[3]], [List[4], List[5]] ]
    point = [List[6], List[7]]
    
    ABvec = [ nodes[1][0] - nodes[0][0], nodes[1][1] - nodes[0][1] ]
    BCvec = [ nodes[2][0] - nodes[1][0], nodes[2][1] - nodes[1][1] ]
    CAvec = [ nodes[0][0] - nodes[2][0], nodes[0][1] - nodes[2][1] ]
    APvec = [ point[0] - nodes[0][0], point[1] - nodes[0][1] ]
    BPvec = [ point[0] - nodes[1][0], point[1] - nodes[1][1] ]
    CPvec = [ point[0] - nodes[2][0], point[1] - nodes[2][1] ]
    a = prod2d(CAvec, APvec)
    b = prod2d(ABvec, BPvec)
    c = prod2d(BCvec, CPvec)
    if   a > 0 and b > 0 and c > 0: print ""YES""
    elif a < 0 and b < 0 and c < 0: print ""YES""
    else                          : print ""NO"""
Python,"if __name__ == '__main__':
	DI = [[0 for _ in range(10)] for _ in range(10)]
	while True:
		try:
			x,y,s = map(int,input().split("",""))
			if s == 0:
				break
			if s == 1:
				
				DI[x][y] += 1
				
				if y >= 1 :
					DI[x][y-1] += 1
				
				if y <= 8:
					DI[x][y+1] += 1
				
				if x >= 1:
					DI[x-1][y] += 1
				
				if x <= 8:
					DI[x+1][y] += 1
			elif s == 2:
				
				DI[x][y] += 1
				
				if y >= 1 :
					DI[x][y-1] += 1
				
				if x >= 1 and y >= 1:
					DI[x-1][y-1] += 1
				
				if x <= 8 and y >= 1 :
					DI[x+1][y-1] += 1
				
				if y <= 8:
					DI[x][y+1] += 1
				
				if x >= 1 and y <= 8:
					DI[x-1][y+1] += 1
				
				if x <= 8 and y <= 8 :
					DI[x+1][y+1] += 1
				
				if x >= 1:
					DI[x-1][y] += 1
				
				if x <= 8:
					DI[x+1][y] += 1
			else:
				
				DI[x][y] += 1
				
				if y >= 1 :
					DI[x][y-1] += 1
				
				if x >= 1 and y >= 1:
					DI[x-1][y-1] += 1
				
				if x <= 8 and y >= 1 :
					DI[x+1][y-1] += 1
				
				if y >= 2 :
					DI[x][y-2] += 1
				
				if y <= 8:
					DI[x][y+1] += 1
				
				if x >= 1 and y <= 8:
					DI[x-1][y+1] += 1
				
				if x <= 8 and y <= 8 :
					DI[x+1][y+1] += 1
				
				if y <= 7:
					DI[x][y+2] += 1
				
				if x >= 1:
					DI[x-1][y] += 1
				
				if x >= 2:
					DI[x-2][y] += 1
				
				if x <= 8:
					DI[x+1][y] += 1
				
				if x <= 7:
					DI[x+2][y] += 1
		except EOFError:
			break
	cnt = 0
	maxcnt = 0
	for k in DI:
		cnt += k.count(0)
		if maxcnt < max(k):
			maxcnt = max(k)
	print(cnt)
	print(maxcnt)"
Python,"E = 10**-10
def cp(a, b):
    c = [a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]]
    return c
while True:
    try:
        x1,y1,x2,y2,x3,y3,xp,yp = [float(i) for i in input().split()]
        ax = x3-x1
        ay = y3-y1
        bx = x1-x2
        by = y1-y2
        cx = x2-x3
        cy = y2-y3
        pax = xp-x1
        pay = yp-y1
        pbx = xp-x2
        pby = yp-y2
        pcx = xp-x3
        pcy = yp-y3
        ca = [bx,by,0]
        ab = [cx,cy,0]
        bc = [ax,ay,0]
        pa = [pax,pay,0]
        pb = [pbx,pby,0]
        pc = [pcx,pcy,0]
        cp1 = cp(ca,pa)[2]
        cp2 = cp(ab,pb)[2]
        cp3 = cp(bc,pc)[2]
        if abs(cp1 - abs(cp1)) < E:
            sig1 = 1
        elif abs(cp1 + abs(cp1)) < E:
            sig1 = -1
        if abs(cp2 - abs(cp2)) < E:
            sig2 = 1
        elif abs(cp2 + abs(cp2)) < E:
            sig2 = -1
        if abs(cp3 - abs(cp3)) < E:
            sig3 = 1
        elif abs(cp3 + abs(cp3)) < E:
            sig3 = -1
        if abs(sig1 + sig2 + sig3) == 3:
            print('YES')
        else:
            print('NO')
    except EOFError:
        break"
Python,"class Paper:
    def __init__(self, x, y):
        
        self.A = [[0 for i in range(x)] for j in range(y)]
        self.size = (x, y)
    def drop(self, x, y, s):
        if s == 1:
            if y+1 <= self.size[1]-1:
                self.A[y+1][x] += 1            
            for i in range(max(0, x-1) , 1 + min(self.size[0]-1, x+1)):
                self.A[y][i] += 1
            if y-1 >= 0:
                self.A[y-1][x] += 1
        if s == 2:
            if y+1 <= self.size[1]-1:
                for i in range(max(0, x-1) , 1 + min(self.size[0]-1, x+1)):
                    self.A[y+1][i] += 1
            for i in range(max(0, x-1) , 1 + min(self.size[0]-1, x+1)):
                self.A[y][i] += 1
            if y-1 >= 0:
                for i in range(max(0, x-1) , 1 + min(self.size[0]-1, x+1)):
                    self.A[y-1][i] += 1
        if s == 3:
            if y+2 <= self.size[1]-1:
                self.A[y+2][x] += 1
            if y+1 <= self.size[1]-1:
                for i in range(max(0, x-1) , 1 + min(self.size[0]-1, x+1)):
                    self.A[y+1][i] += 1
            for i in range(max(0, x-2) , 1 + min(self.size[0]-1, x+2)):
                self.A[y][i] += 1
            if y-1 >= 0:
                for i in range(max(0, x-1) , 1 + min(self.size[0]-1, x+1)):
                    self.A[y-1][i] += 1
            if y-2 >= 0:
                self.A[y-2][x] += 1
if __name__ == ""__main__"":
    import sys 
    p = Paper(10, 10)
    L = sys.stdin.readlines()
    for l in L:
        x, y, s = map(int, l.split(','))
        p.drop(x, y, s)
    temp = []
    for y in p.A:
        temp.extend(y)
    A1 = temp.count(0)
    A2 = max(temp)
    print(A1)
    print(A2)
        
            
    
    "
Python,"import sys
count = int(raw_input())
while 0 < count:
    count -=1
    
    a = map(int,raw_input().split())
    
    if a[1]< a[2]:
        tmp = a[1]
        a[1] = a[2]
        a[2] = tmp
    if a[0] < a[1]:
        tmp = a[0]
        a[0] = a[1]
        a[1] = tmp
    n = a[1]*a[1] + a[2]*a[2]
    if a[0]*a[0] == n:
        print ""YES""
    else:
        print ""NO"""
Python,"class vertex(object):
    def __init__(self,a):
        self.x=a[0]
        self.y=a[1]
class circle(object):
    def __init__(self,p,r):
        self.px=p.x
        self.py=p.y
        self.r=r
class triangle(object):
    def __init__(self,a,b,c):
        self.a=a
        self.b=b
        self.c=c
        import math
        self.ab=math.sqrt((self.a.x-self.b.x)**2+(self.a.y-self.b.y)**2)
        self.bc=math.sqrt((self.b.x-self.c.x)**2+(self.b.y-self.c.y)**2)
        self.ca=math.sqrt((self.c.x-self.a.x)**2+(self.c.y-self.a.y)**2)
        c=self.ab
        a=self.bc
        b=self.ca
        self.cosA=(b**2+c**2-a**2)/(2*b*c)
        self.cosB=(a**2+c**2-b**2)/(2*a*c)
        self.cosC=(b**2+a**2-c**2)/(2*b*a)
        self.sinA=math.sqrt(1-self.cosA**2)
        self.sinB=math.sqrt(1-self.cosB**2)
        self.sinC=math.sqrt(1-self.cosC**2)
        self.sin2A=2*self.sinA*self.cosA
        self.sin2B=2*self.sinB*self.cosB
        self.sin2C=2*self.sinC*self.cosC
    def area(self):
        import math
        s=(self.ab+self.bc+self.ca)/2
        S=math.sqrt(s*(s-self.ab)*(s-self.bc)*(s-self.ca))
        return S
    def circumscribed(self):
        R=self.ab/(2*self.sinC)
        px=(self.sin2A*self.a.x+self.sin2B*self.b.x+self.sin2C*self.c.x)/(self.sin2A+self.sin2B+self.sin2C)
        py=(self.sin2A*self.a.y+self.sin2B*self.b.y+self.sin2C*self.c.y)/(self.sin2A+self.sin2B+self.sin2C)
        px=round(px,3)
        py=round(py,3)
        R=round(R,3)
        p=vertex((px,py))
        return circle(p,R)
n=eval(input())
p1=[]
p2=[]
p3=[]
for i in range(n):
    a,b,c,d,e,f=list(map(float,input().split()))
    p1.append(vertex((a,b)))
    p2.append(vertex((c,d)))
    p3.append(vertex((e,f)))
for i in range(n):
    Triangle=triangle(p1[i],p2[i],p3[i])
    Circle=Triangle.circumscribed()
    print('%.3f %.3f %.3f'%(Circle.px,Circle.py,Circle.r))"
Python,"import sys
def Print(array):
    for r in range(len(array)):
        print(array[r])
    print()
def Gauss(array):
    
    
    for r in range(len(array)):
        
        div = array[r][r]
        for c in range(r, len(array) + 1):
            array[r][c] /= div
        for r2 in range(r + 1, len(array)):
            head = array[r2][r]
            for c in range(r, len(array) + 1):
                array[r2][c] -= head * array[r][c]
    result = [0] * len(array)
    for r in range(len(array) - 1, -1, -1):
        result[r] = array[r][
            len(array)] - sum([result[x] * array[r][x] for x in range(r + 1, len(array))])
    return result
for line in sys.stdin:
    [a, b, c, d, e, f] = [int(x) for x in line.split()]
    result = Gauss([[a, b, c], [d, e, f]])
    for i in range(len(result) - 1):
        print(""{0:.3f}"".format(result[i]), end="" "")
    print(""{0:.3f}"".format(result[-1]))"
Python,"max_number = 1000000
prime_flag_list = [True] * max_number
prime_flag_list[0] = False
prime_flag_list[1] = False
prime_flag_list[4::2] = [False] * len(prime_flag_list[4::2])
for i in range(3, int(max_number**0.5) + 1, 2):
    prime_flag_list[i*i::i] = [False] * len(prime_flag_list[i*i::i])
prime_list = [i for i in range(2, max_number) if prime_flag_list[i]]
while True:
    try:
        input = int(raw_input())
    except EOFError:
        break
    for i in range(0, len(prime_list)):
        if prime_list[i] > input:
            print i
            break
    if i >= len(prime_list) - 1:
        print len(prime_list)"
Python,"arr = [0]*100
while True:
    try:
        x,y,s = map(int, input().split("",""))
        if s==3:
            if x <= 7:
                arr[10*y+x+2] += 1
            if x >= 2:
                arr[10*y+x-2] += 1
            if y <= 7:
                arr[10*y+x+20] += 1
            if y >= 2:
                arr[10*y+x-20] += 1
        if s>=2:
            if x != 9 and y != 9:
                arr[10*y+x+11] += 1
            if x != 9 and y != 0:
                arr[10*y+x-9] += 1
            if x != 0 and y != 0:
                arr[10*y+x-11] += 1
            if x != 0 and y != 9:
                arr[10*y+x+9] += 1
        if True:
            if x != 9:
                arr[10*y+x+1] += 1
            if x != 0:
                arr[10*y+x-1] += 1
            if y != 9:
                arr[10*y+x+10] += 1
            if y != 0:
                arr[10*y+x-10] += 1
        if True:
            if True:
                arr[10*y+x] += 1
    except EOFError:
        break
print(arr.count(0))
print(max(arr))"
Python,"import sys
import math
prim_no = {2: True}                    
def is_prime(no):
    if no == 2 or no == 1:
        return True
    
    if no % 2 == 0:
        return False
    if prim_no.get(no) is not None:
        return prim_no.get(no)
    max_check = int(math.sqrt(no))
    for i in range(3, max_check+1, 2):
        if no % i == 0:
            prim_no[no] = False
            return False
    prim_no[no] = True
    return True
def main():
    prim_vals = {}                         
    while True:
        num = sys.stdin.readline()
        if num is None or num.strip() == '':
            break
        num = int(num.strip())
        if prim_vals.get(num) is not None:
            cnt = prim_vals.get(num)
        else:
            
            if num == 1:
                cnt = 0
            else:
                cnt = 0
                
                if num % 2 == 0:
                    start_num = num -1
                else:
                    start_num = num
                    
                for i in range(start_num, 0, -2):
                    
                    if prim_vals.get(i) is not None:
                        cnt += prim_vals.get(i)
                        
                        break
                    
                    if is_prime(i):
                        cnt += 1
                        
                
                prim_vals[num] = cnt 
        print(cnt)
if __name__ == '__main__':
    main()
    "
Python,"from bisect import bisect_right
max_number = 1000000
prime_flag_list = [True] * max_number
prime_flag_list[0] = False
prime_flag_list[1] = False
prime_flag_list[4::2] = [False] * len(prime_flag_list[4::2])
for i in range(3, int(max_number**0.5) + 1, 2):
    prime_flag_list[i*i::i] = [False] * len(prime_flag_list[i*i::i])
prime_list = [i for i in range(2, max_number) if prime_flag_list[i]]
while True:
    try:
        input = int(raw_input())
    except EOFError:
        break
        
    
    
    print bisect_right(prime_list, input)"
Python,"import sys
MAX = 999999
L = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
def is_prime(n):
  if n == 2:return True
  if n % 2 == 0:return False
  for i in range(3,int(n**0.5)+1,2):
    if n % i == 0:return False
  return True
def is_prime_2(n):
  a = int(n ** 0.5)
  for i in L:
    if i > a:return True
    if n % i == 0:return False
  return True
def prime_count(n):
  result = 0
  if n >= 2:result+=1
  for i in range(3,n+1,2):
    if is_prime_2(i):result+=1
  return result
def prime_list(n):
  result = []
  if n >= 2:result.append(2)
  for i in range(3,n+1,2):
    if is_prime(i):result.append(i)
  return result
L2 = prime_list(MAX)
def prime_count_2(n):
  for i,v in enumerate(L2):
    if v > n:return i
  return len(L2)
for n in sys.stdin:
  print(prime_count_2(int(n)))"
Python,"""""""Enumerates primes in an interval.
Verification: [0009](https://onlinejudge.u-aizu.ac.jp/status/users/hamukichi/submissions/1/0009/judge/4571021/Python3)
""""""
import math
import sys
def segment_sieve(begin, end):
    """"""Enumerates the prime numbers in [`begin`, `end`).
    Returns (as a tuple):
    - `is_prime`: a list of bool values.
      If an integer `i` is a prime number, then `is_prime[i - begin]` is True.
      Otherwise `is_prime[i -begin]` is False.
    - `primes`: a list of prime numbers in [`begin`, `end`).
    """"""
    assert 1 < begin <= end
    sqrt_end = math.ceil(math.sqrt(end))
    is_prime_small = [True for i in range(sqrt_end)]
    is_prime_small[0] = False
    is_prime_small[1] = False
    is_prime = [True for i in range(end - begin)]
    for i in range(2, sqrt_end):
        if is_prime_small[i]:
            for j in range(2 * i, sqrt_end, i):
                is_prime_small[j] = False
            for k in range(max(2, (begin + i - 1) // i) * i, end, i):
                is_prime[k - begin] = False
    primes = [i for i, cond in enumerate(is_prime, begin) if cond]
    return is_prime, primes
def main():
    ns = [int(n) for n in sys.stdin.readlines()]
    max_n = max(ns)
    begin = 2
    is_prime, _ = segment_sieve(begin, max_n + 1)
    for n in ns:
        print(sum(is_prime[:n + 1 - begin]))
if __name__ == '__main__':
    main()"
Python,"import sys
def main():
    data = []
    lines = sys.stdin.readlines()
    for line in lines:
        data.append(line.split())  
    
    
    
    N = len(data)
    for i in range(N):
        for k in range(6):
            data[i][k] = int(data[i][k])
        det = data[i][0] * data[i][4] - data[i][1] * data[i][3]
        gx = data[i][2] * data[i][4] - data[i][1] * data[i][5]
        gy = data[i][0] * data[i][5] - data[i][2] * data[i][3]
        if det < 0:
            det = -det;
            if gx != 0: gx = -gx
            if gy != 0: gy = -gy
        print(""{0:.3f}"".format(gx / det) + "" "" + ""{0:.3f}"".format(gy / det))
if __name__ == ""__main__"":
    main()"
Python,"import sys
class P(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __repr__(self):
        return 'P:{0:.3f} {1:.3f}'.format(self.x, self.y)
class Line(object):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.epsilon = 1e-8
    def is_over(self, p):
        if abs(self.p2.x - self.p1.x) < self.epsilon:
            return self.p1.x > p.x
        elif abs(self.p2.y - self.p1.y) < self.epsilon:
            return self.p1.y > p.y
        else:
            a = (self.p2.y - self.p1.y) / (self.p2.x - self.p1.x)
            b = self.p1.y
            y = a * (p.x - self.p1.x) + b
            return y > p.y
def run():
    for i in sys.stdin:
        x1, y1, x2, y2, x3, y3, xp, yp = list(map(float, i.split()))
        p1, p2, p3, p = P(x1, y1), P(x2, y2), P(x3, y3), P(xp, yp)
        l_12 = Line(p1, p2)
        l_23 = Line(p2, p3)
        l_31 = Line(p3, p1)
        res = l_12.is_over(p3) == l_12.is_over(p)
        res &= l_23.is_over(p1) == l_23.is_over(p)
        res &= l_31.is_over(p2) == l_31.is_over(p)
        if res:
            print('YES')
        else:
            print('NO')
if __name__ == '__main__':
    run()"
Python,"from math import cos, sin, sqrt, radians, degrees, acos, fabs
if __name__ == '__main__':
    epsilon = 1e-9
    
    num = int(input())
    for i in range(num):
        x1, y1, x2, y2, x3, y3 = [float(x) for x in input().split(' ')]
        
        a = sqrt((x1-x2)**2 + (y1-y2)**2)
        b = sqrt((x2-x3)**2 + (y2-y3)**2)
        c = sqrt((x1-x3)**2 + (y1-y3)**2)
        cosA = (b**2+c**2-a**2)/(2*b*c)
        
        r = a / sin(acos(cosA)) / 2
        """"""
       ??????O?????§?¨????(x, y)??¨????????¨
       (x-x1)**2 + (y-y1)**2 = (x-x2)**2 + (y-y2)**2
       x**2 -2*x1*x + x1**2 + y**2 -2*y1*y + y1**2 = ... -2*x2*x, x2**2, -2*y2*y, y2**2
       ?????¨????????¨ (-2*x1 + 2*x2)x + (-2y1 + 2*y2)y + (x1**2 + y1**2 - x2**2 - y2**2) = 0
       x1, x3???????????????????§????
       (-2*x1 + 2*x3)x + (-2y1 + 2*y3)y + (x1**2 + y1**2 - x3**2 - y3**2) = 0
       """"""
        A = -2*x1 + 2*x2
        B = -2*y1 + 2*y2
        C = -2*x1 + 2*x3
        D = -2*y1 + 2*y3
        E = x1**2 + y1**2 - x2**2 - y2**2
        F = x1**2 + y1**2 - x3**2 - y3**2
        x = 1/(A*D-B*C) * (D*E - B*F)
        y = 1/(A*D-B*C) * (-C*E + A*F)
        
        if fabs(x) < epsilon:
            x = 0.0
        if fabs(y) < epsilon:
            y = 0.0
        print('{0:.3f} {1:.3f} {2:.3f}'.format(-x, -y, r))"
Python,"A=[[int(0) for i in range(10)]for j in range(10)]
count=0
while 1:
    try:
        x,y,s = map(int, input().split(','))
        if s==1:
            for i in range(x-1,x+2):
                if i>=0 and i<=9:
                    A[i][y]=A[i][y]+1
            for i in range(y-1,y+2):
                if i>=0 and i<=9:
                    A[x][i]=A[x][i]+1
            A[x][y]=A[x][y]-1 
        elif s==2:
            for i in range(x-1,x+2):
                for j in range(y-1,y+2):
                    if i>=0 and i<=9 and j>=0 and j<=9:
                        A[i][j]=A[i][j]+1
        else:
            for i in range(x-2,x+3):
                if i>=0 and i<=9:
                    A[i][y]=A[i][y]+1
            for i in range(y-2,y+3):
                if i>=0 and i<=9:
                    A[x][i]=A[x][i]+1
            for i in range(x-1,x+2):
                if i>=0 and i<=9:
                    A[i][y]=A[i][y]-1
            for i in range(y-1,y+2):
                if i>=0 and i<=9:
                    A[x][i]=A[x][i]-1
            for i in range(x-1,x+2):
                for j in range(y-1,y+2):
                    if i>=0 and i<=9 and j>=0 and j<=9:
                        A[i][j]=A[i][j]+1
    except:
        break
num=0
for i in range(10):
    for j in range(10):
        if A[i][j]==0:
            count=count+1
        if A[i][j]!=0:
            if num<A[i][j]:
                num=A[i][j]
print(count)
print(num)"
Python,"import sys
class Paper:
    def __init__(self):
        self.paper = [[0 for x in range(10)] for y in range(10)]
    def white_space(self):
        s = 0
        for x in range(10):
            for y in range(10):
                if self.paper[x][y] == 0:
                    s += 1
        return s
    def most_dark(self):
        s = 0
        for x in range(10):
            for y in range(10):
                if self.paper[x][y] > s:
                    s = self.paper[x][y]
        return s
    def drop(self, x, y, size):
        r = []
        if size == 1:
            r.append((x,y))
            r.append((x-1,y))
            r.append((x+1,y))
            r.append((x,y-1))
            r.append((x,y+1))
        elif size == 2:
            r = [(i,j) for i in range(x-1, x+2) for j in range(y-1, y+2)]
        elif size == 3:
            r = [(i,j) for i in range(x-1, x+2) for j in range(y-1, y+2)]
            r.append((x-2, y))
            r.append((x+2, y))
            r.append((x, y-2))
            r.append((x, y+2))
        else:
            pass
        r = filter(self.out_of_paper, r)
        try:
            for p in r:
                self.paper[p[0]][p[1]] += 1
        except:
            pass
        return self
    def out_of_paper(self, p):
        if 0 <= p[0] < 10 and 0 <= p[1] < 10:
            return True
        else:
            return False
paper = Paper()
for line in sys.stdin:
    (x, y, size) = tuple(map(int, line.split(',')))
    paper.drop(x, y, size)
print paper.white_space()
print paper.most_dark()"
Python,"import math
def calc_digit(data1, data2):
    if(data1 == 0):
        data_size2 = int(len(str(data2)))
        data_size1 = 1
    elif(data2 == 0):
        data_size1 = int(len(str(data2)))
        data_size2 = 1
    else:
        data_size1 = int(len(str(data1)))
        data_size2 = int(len(str(data2)))
    return(data_size1, data_size2)
def two_number_sum(data1, data2):
    result = data1 + data2
    if int(len(str(result))) > 80:
        print(""overflow"")
    else:
        print(result)
def main():
    a = []
    N = int(input())
    for i in range(N*2):
        a.append(input())
    for i in range(0, N*2):
        if i % 2 == 0:
            continue
        else:
            data1 = int(a[i-1])
            data2 = int(a[i])
            if(data1 == None):
                data1 = 0
            elif(data2 == None):
                data2 = 0
            x, y = calc_digit(data1, data2)
            if(x > 80 or y > 80):
                print(""overflow"")
                continue
            two_number_sum(data1, data2)
if __name__ == '__main__':
    main()"
Python,"a = [[0 for i2 in range(10)] for i1 in range(10)]
def small_ink(x,y):
    a[x][y] += 1
    a[x-1][y] += 1
    try:
        a[x+1][y] += 1
    except:
        pass
    a[x][y-1] += 1
    try:
        a[x][y+1] += 1
    except:
        pass
    if x-1 < 0:
        a[x-1][y] -= 1
    if y-1 < 0:
        a[x][y-1] -= 1
    return 0
def mid_ink(x,y):
    for i in [-1,0,1]:
        for j in [-1,0,1]:
            if 9 >= x+i >= 0 and 9>= y+j >= 0:
                a[x+i][y+j] += 1
    return 0
def big_ink(x,y):
    mid_ink(x,y)
    a[x-2][y] += 1
    try:
        a[x+2][y] += 1
    except:
        pass
    a[x][y-2] += 1
    try:
        a[x][y+2] += 1
    except:
        pass
    if x-2 < 0:
        a[x-2][y] -= 1
    if y-2 < 0:
        a[x][y-2] -= 1
    return 0
def ink(x,y,s):
    if s == 1:
        small_ink(x,y)
    if s == 2:
        mid_ink(x,y)
    if s == 3:
        big_ink(x,y)
    return 0
while True:
    try:
        x,y,s = map(int,input().split(','))
        ink(x,y,s)
    except EOFError:
        break
nu = 0
for i in range(10):
    for j in range(10):
        if a[i][j] == 0:
            nu += 1
print(nu)
max_val = 0
for i in range(10):
    for j in range(10):
        if a[i][j] > max_val:
            max_val = a[i][j]
print(max_val)"
Python,"import math
PI = math.pi
EPS = 10**-10
def edge(a, b):
    return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5
def area(a, b, c):
    s = (a+b+c)/2
    return (s*(s-a)*(s-b)*(s-c))**.5
def LawOfCosines(a, b, c): 
    return math.acos( (b*b+c*c-a*a) / (2.0*b*c) );
def is_same(x, y): 
    return abs(x-y) < EPS
class Triangle:
    def __init__(self, p):
        a, b, c = p
        self.a = a
        self.b = b
        self.c = c
        self.edgeA = edge(b, c)
        self.edgeB = edge(c, a)
        self.edgeC = edge(a, b)
        self.area = area(self.edgeA, self.edgeB, self.edgeC)
        self.angleA = LawOfCosines(self.edgeA, self.edgeB, self.edgeC)
        self.angleB = LawOfCosines(self.edgeB, self.edgeC, self.edgeA)
        self.angleC = LawOfCosines(self.edgeC, self.edgeA, self.edgeB)
    def circumscribeadCircleRadius(self): 
        return self.edgeA / math.sin(self.angleA) / 2.0
    def circumscribedCircleCenter(self): 
        a = math.sin(2.0*self.angleA);
        b = math.sin(2.0*self.angleB);
        c = math.sin(2.0*self.angleC);
        X = (self.a[0] * a + self.b[0] * b + self.c[0] * c) / (a+b+c);
        Y = (self.a[1] * a + self.b[1] * b + self.c[1] * c) / (a+b+c);
        return X, Y
    def inscribedCircleRadius(self): 
        return 2 * self.area / (self.edgeA + self.edgeB + self.edgeC)
    def inscribedCircleCenter(self): 
        points = [self.a, self.b, self.c]
        edges = [self.edgeA, self.edgeB, self.edgeC]
        s = sum(edges)
        return [sum([points[j][i]*edges[j] for j in range(3)])/s for i in range(2)]
    def isInner(self, p): 
        cross = lambda a, b: a[0]*b[1]-a[1]*b[0]
        c1 = 0
        c2 = 0
        points = [self.a, self.b, self.c]
        for i in range(3):
            a = [points[i][0]-points[(i+1)%3][0], points[i][1]-points[(i+1)%3][1]]
            b = [points[i][0]-p[0],  points[i][1]-p[1]]
            c = cross(a, b)
            if c > 0:
                c1 += 1
            elif c < 0:
                c2 += 1
        if c1 == 3 or c2 == 3:
            return True
        else:
            return c1+c2 != 3 and (c1 == 0 or c2 == 0)
if __name__ == ""__main__"":
    n = int(input())
    for _ in range(n):
        points = []
        c = list(map(float, input().split()))
        points = [(c[i], c[i+1]) for i in range(0, 6, 2)]
        t = Triangle(points)
        
        x, y = t.circumscribedCircleCenter()
        r = t.circumscribeadCircleRadius()
        print(""{:.3f} {:.3f} {:.3f}"".format(x,y,r))"
Python,"import math
PI = math.pi
EPS = 10**-10
def edge(a, b):
    return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5
def area(a, b, c):
    s = (a+b+c)/2
    return (s*(s-a)*(s-b)*(s-c))**.5
def LawOfCosines(a, b, c): 
    return math.acos( (b*b+c*c-a*a) / (2.0*b*c) );
def is_same(x, y): 
    return abs(x-y) < EPS
class Triangle:
    def __init__(self, p):
        a, b, c = p
        self.a = a
        self.b = b
        self.c = c
        self.edgeA = edge(b, c)
        self.edgeB = edge(c, a)
        self.edgeC = edge(a, b)
        self.area = area(self.edgeA, self.edgeB, self.edgeC)
        self.angleA = LawOfCosines(self.edgeA, self.edgeB, self.edgeC)
        self.angleB = LawOfCosines(self.edgeB, self.edgeC, self.edgeA)
        self.angleC = LawOfCosines(self.edgeC, self.edgeA, self.edgeB)
    def circumscribeadCircleRadius(self): 
        return self.edgeA / math.sin(self.angleA) / 2.0
    def circumscribedCircleCenter(self): 
        a = math.sin(2.0*self.angleA);
        b = math.sin(2.0*self.angleB);
        c = math.sin(2.0*self.angleC);
        X = (self.a[0] * a + self.b[0] * b + self.c[0] * c) / (a+b+c);
        Y = (self.a[1] * a + self.b[1] * b + self.c[1] * c) / (a+b+c);
        return X, Y
    def inscribedCircleRadius(self): 
        return 2 * self.area / (self.edgeA + self.edgeB + self.edgeC)
    def inscribedCircleCenter(self): 
        points = [self.a, self.b, self.c]
        edges = [self.edgeA, self.edgeB, self.edgeC]
        s = sum(edges)
        return [sum([points[j][i]*edges[j] for j in range(3)])/s for i in range(2)]
    def isInner(self, p): 
        cross = lambda a, b: a[0]*b[1]-a[1]*b[0]
        c1 = 0
        c2 = 0
        points = [self.a, self.b, self.c]
        for i in range(3):
            a = [points[i][0]-points[(i+1)%3][0], points[i][1]-points[(i+1)%3][1]]
            b = [points[i][0]-p[0],  points[i][1]-p[1]]
            c = cross(a, b)
            if c > 0:
                c1 += 1
            elif c < 0:
                c2 += 1
        if c1 == 3 or c2 == 3:
            return True
        else:
            return c1+c2 != 3 and (c1 == 0 or c2 == 0)
if __name__ == ""__main__"":
    while True:
        try:
            c = list(map(float, input().split()))
            points = [(c[i], c[i+1]) for i in range(0, 6, 2)]
            point = [c[6], c[7]] 
            t = Triangle(points)
            print([""NO"",""YES""][t.isInner(point)])
        except:
            break"
Python,"import heapq
from collections import deque
from enum import Enum
import sys
import math
from _heapq import heappush, heappop
import copy
BIG_NUM = 2000000000
HUGE_NUM = 99999999999999999
MOD = 1000000007
EPS = 0.000000001
sys.setrecursionlimit(100000)
num_query = int(input())
for _ in range(num_query):
    A = list(map(int,input()))
    B = list(map(int,input()))
    if len(A) > 80 or len(B) > 80:
        print(""overflow"")
        continue
    if len(B) > len(A): 
        A,B = B,A
    A.reverse()
    B.reverse()
    ANS = deque()
    add = 0
    for digit in range(len(A)):
        if digit >= len(B):
            tmp = add+A[digit]
            add = tmp//10
            ANS.append(tmp%10)
        else:
            tmp = add+B[digit]+A[digit]
            add = tmp//10
            ANS.append(tmp%10)
    if len(A) == 80 and add == 1:
        print(""overflow"")
    else:
        if add == 1:
            ANS.append(1)
        while len(ANS) > 0:
            print(""%d""%(ANS.pop()),end="""")
        print()"
Python,"Masu = []
def access(x,y):
    if x < 0 or y < 0 or x > 9 or y > 9:
        return
    Masu[y][x] += 1
for i in range(10):
    Masu.append([0,0,0,0,0,0,0,0,0,0])
kosu = 0
komax = 0
while True:
    try:
        
        x,y,s = map(int,input().split("",""))
        if s == 1:
            for j in range(3):
                access(y +1 - j,x)
            access(y,x - 1)
            access(y,x + 1)
        elif s == 2:
            for k in range(3):
                for l in range(3):
                    access(y + 1 - k,x + 1 -l)
        elif s == 3:
            for k in range(3):
                for l in range(3):
                    access(y + 1 - k,x + 1 -l)
            access(y - 2,x)
            access(y + 2,x)
            access(y,x + 2)
            access(y,x - 2)
               
    except (EOFError,ValueError):
        for i in range(10):
            kosu += Masu[i].count(0)
        for j in range(10):
            if komax < max(Masu[j]):
                komax = max(Masu[j])
        print(kosu)
        print(komax)
        break"
Python,"mass = [[0 for p in xrange(14)] for q in xrange(14)]
while True:
	try:
		x,y,size = map(int,raw_input().split(','))
		x += 2 ; y += 2
		if   size == 1:
			mass[x-2][y-2]+=0;mass[x-1][y-2]+=0;mass[x][y-2]+=0;mass[x+1][y-2]+=0;mass[x+2][y-2]+=0
			mass[x-2][y-1]+=0;mass[x-1][y-1]+=0;mass[x][y-1]+=1;mass[x+1][y-1]+=0;mass[x+2][y-1]+=0
			mass[x-2][y]  +=0;mass[x-1][y]  +=1;mass[x][y]  +=1;mass[x+1][y]  +=1;mass[x+2][y]  +=0
			mass[x-2][y+1]+=0;mass[x-1][y+1]+=0;mass[x][y+1]+=1;mass[x+1][y+1]+=0;mass[x+2][y+1]+=0
			mass[x-2][y+2]+=0;mass[x-1][y+2]+=0;mass[x][y+2]+=0;mass[x+1][y+2]+=0;mass[x+2][y+2]+=0
		elif size == 2:
			mass[x-2][y-2]+=0;mass[x-1][y-2]+=0;mass[x][y-2]+=0;mass[x+1][y-2]+=0;mass[x+2][y-2]+=0
			mass[x-2][y-1]+=0;mass[x-1][y-1]+=1;mass[x][y-1]+=1;mass[x+1][y-1]+=1;mass[x+2][y-1]+=0
			mass[x-2][y]  +=0;mass[x-1][y]  +=1;mass[x][y]  +=1;mass[x+1][y]  +=1;mass[x+2][y]  +=0
			mass[x-2][y+1]+=0;mass[x-1][y+1]+=1;mass[x][y+1]+=1;mass[x+1][y+1]+=1;mass[x+2][y+1]+=0
			mass[x-2][y+2]+=0;mass[x-1][y+2]+=0;mass[x][y+2]+=0;mass[x+1][y+2]+=0;mass[x+2][y+2]+=0
		elif size == 3:
			mass[x-2][y-2]+=0;mass[x-1][y-2]+=0;mass[x][y-2]+=1;mass[x+1][y-2]+=0;mass[x+2][y-2]+=0
			mass[x-2][y-1]+=0;mass[x-1][y-1]+=1;mass[x][y-1]+=1;mass[x+1][y-1]+=1;mass[x+2][y-1]+=0
			mass[x-2][y]  +=1;mass[x-1][y]  +=1;mass[x][y]  +=1;mass[x+1][y]  +=1;mass[x+2][y]  +=1
			mass[x-2][y+1]+=0;mass[x-1][y+1]+=1;mass[x][y+1]+=1;mass[x+1][y+1]+=1;mass[x+2][y+1]+=0
			mass[x-2][y+2]+=0;mass[x-1][y+2]+=0;mass[x][y+2]+=1;mass[x+1][y+2]+=0;mass[x+2][y+2]+=0
	except: break
white = 0
max = 0
for p in xrange(2,12):
	for q in xrange(2,12):
		if mass[p][q] == 0: white += 1
		if mass[p][q] > max: max = mass[p][q]
print white
print max"
Python,"import sys
from decimal import Decimal
def main():
    for input_line in sys.stdin:
        x1 = int(input_line.split(' ')[0])
        y1 = int(input_line.split(' ')[1])
        p = int(input_line.split(' ')[2])
        x2 = int(input_line.split(' ')[3])
        y2 = int(input_line.split(' ')[4])
        q = int(input_line.split(' ')[5])
        multiplicand1, multiplicand2 = calculate1(x1, x2)
        after_y1, after_y2, after_p, after_q = calculate2(y1, y2, p, q, multiplicand1, multiplicand2)
        calculate3(after_y1, after_y2, after_p, after_q, x1, y1, p)
    
def calculate1(x1, x2):
    if (x1 >= 0 and x2 >= 0) or (x1 < 0 and x2 < 0):
        multiplicand1 = -x2
        multiplicand2 = x1
        return multiplicand1, multiplicand2
    else:
        multiplicand1 = abs(x2)
        multiplicand2 = abs(x1)
        return multiplicand1, multiplicand2
    
def calculate2(y1, y2, p, q, multiplicand1, multiplicand2):
    after_y1 = Decimal(y1 * multiplicand1)
    after_y2 = Decimal(y2 * multiplicand2)
    after_p = Decimal(p * multiplicand1)
    after_q = Decimal(q * multiplicand2)
    return after_y1, after_y2, after_p, after_q
def calculate3(after_y1, after_y2, after_p, after_q, x1, y1, p):
    y = Decimal(after_p + after_q) / Decimal(after_y1 + after_y2)
    y = round(y, 3)
    x = Decimal(p - y1 * y) / Decimal(x1)
    x = round(x, 3)
    print('%.3f %.3f' % (x, y))
    
if __name__ == '__main__':
    main()"
Python,"if __name__ == ""__main__"":
    num = int(input())
    inputline = [""""]*num
    for i in range(0,num):
        inputline[i] = input()
    for line in inputline:
        a = int(line.split("" "")[0])
        b = int(line.split("" "")[1])
        c = int(line.split("" "")[2])
        if (a*a+b*b == c*c or b*b+c*c == a*a or c*c+a*a == b*b):
            print(""YES"")
        else:
            print(""NO"")"
Python,"p = [[0 for j in range(10)] for i in range(10)]
s1i = [-1, 0, 0, 1]
s1j = [0, -1, 1, 0]
s2i = [-1, -1, -1, 0, 0, 1, 1, 1]
s2j = [-1, 0, 1, -1, 1, -1, 0, 1]
s3i = [-2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 2]
s3j = [0, -1, 0, 1, -2, -1, 1, 2, -1, 0, 1, 0]
while True:
  try:
    x, y, s = map(int, input().split("",""))
  except:
    break
  p[y][x] += 1
  if s == 1:
    for k in range(len(s1i)):
      xx = x + s1j[k]
      yy = y + s1i[k]
      if 0 <= xx and xx < 10 and 0 <= yy and yy < 10:
        p[yy][xx] += 1
  elif s == 2:
    for k in range(len(s2i)):
      xx = x + s2j[k]
      yy = y + s2i[k]
      if 0 <= xx and xx < 10 and 0 <= yy and yy < 10:
        p[yy][xx] += 1
  else:
    for k in range(len(s3i)):
      xx = x + s3j[k]
      yy = y + s3i[k]
      if 0 <= xx and xx < 10 and 0 <= yy and yy < 10:
        p[yy][xx] += 1
    
cnt = 0
m = 0
for i in range(10):
  
  for j in range(10):
    if p[i][j] == 0:
      cnt += 1
    else:
      pass
    m = max(p[i][j], m)
print(cnt)
print(m)"
Python,"import sys
paper = [[0] * 10 for x in xrange(10)]
def dropInc(coord, size):
    x, y = coord
    if size == 1:
        paper[y][x] += 1
        if y > 0:
            paper[y-1][x] += 1
        if y < 9:
            paper[y+1][x] += 1
        if x > 0:
            paper[y][x-1] += 1
        if x < 9:
            paper[y][x+1] += 1
    elif size == 2:
        dropInc(coord, 1)
        if y > 0 and x > 0:
            paper[y-1][x-1] += 1
        if x < 9 and y > 0:
            paper[y-1][x+1] += 1
        if x > 0 and y < 9:
            paper[y+1][x-1] += 1
        if x < 9 and y < 9:
            paper[y+1][x+1] += 1
    elif size == 3:
        dropInc(coord, 2)
        if x > 1:
            paper[y][x-2] += 1
        if x < 8:
            paper[y][x+2] += 1
        if y > 1:
            paper[y-2][x] += 1
        if y < 8:
            paper[y+2][x] += 1
for line in sys.stdin.readlines():
    line = line.strip()
    x,y,size = map(int, line.split("",""))
    dropInc((x,y), size)
print sum([1 if x == 0  else 0 for y in paper for x in y])
print max([x for y in paper for x in y])"
Python,"p = [[0 for a in range(10)] for b in range(10)]
def smallink(x,y):
    return [(x+i,y+j) for i in range(-1,2,1) for j in range(-1,2,1)\\
            if abs(i)+abs(j)<=1 and x+i>=0 and x+i<=9 and y+j>=0\\
            and y+j<=9]
def ink(x,y):
    return [(x+i,y+j) for i in range(-1,2,1) for j in range(-1,2,1)\\
            if x+i>=0 and y+j>=0 and x+i<=9 and y+j<=9]
def bigink(x,y):
    return [(x+i,y+j) for i in range(-2,3,1) for j in range(-2,3,1)\\
            if abs(i)+abs(j)<=2 and x+i>=0 and y+j>=0 and x+i<=9\\
            and y+j<=9]
while True:
    try:
        x,y,size=map(int,raw_input().split("",""))
        if size==1:
            L=smallink(x,y)
        elif size==2:
            L=ink(x,y)
        else:
            L=bigink(x,y)
        while len(L)!=0:
            point=L.pop(0)
            p[point[0]][point[1]]+=1
    except:
        break
count=0
max=0
for i in range(10):
    for j in range(10):
        if(p[i][j]>max):
            max=p[i][j]
        if(p[i][j]==0):
            count+=1
print count
print max"
Python,"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from fractions import gcd
from bisect import bisect_left
from heapq import heappush, heappop
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7
def primes_for(n):
   is_prime = [True] * (n + 1)
   is_prime[0] = False
   is_prime[1] = False
   for i in range(2, n + 1):
       for j in range(i * 2, n + 1, i):
           is_prime[j] = False
   return [i for i in range(n + 1) if is_prime[i]]
prime_list = primes_for(10**6)
is_prime = [0]*10**6
for n in prime_list:
  is_prime[n] = 1
cnt = [0] * 10**6
for i in range(2, 10**6):
  if is_prime[i]:
    cnt[i] = cnt[i-1] + 1
  else:
    cnt[i] = cnt[i-1]
while 1:
  try:
    n = INT()
    print(cnt[n])
  except:
    sys.exit()"
Python,"from __future__ import (division, absolute_import, print_function,
                        unicode_literals)
from sys import stdin
from operator import attrgetter
from collections import namedtuple
Point = namedtuple('Point', 'x y')
def linear(p1, p2):
    gradient = (p1.y - p2.y) / (p1.x - p2.x)
    y_intercept = p1.y - gradient * p1.x
    return lambda x: gradient * x + y_intercept
def takeout(seq):
    gen = (Point(next(seq), next(seq)) for _ in xrange(3))
    for p in sorted(gen, key=attrgetter('x')):
        yield p
    yield Point(next(seq), next(seq))
for line in stdin:
    A, B, C, P = takeout(float(s) for s in line.split())
    assert A.x <= B.x <= C.x
    if P.x <= A.x or C.x <= P.x:
        print('NO')
        continue
    if A.x == B.x or B.x <= P.x <= C.x:
        L = (linear(B, C), linear(A, C))
    elif B.x == C.x or A.x <= P.x <= B.x:
        L = (linear(A, B), linear(A, C))
    else:
        print('NO')
        continue
    y1, y2 = sorted(f(P.x) for f in L)
    if y1 < P.y < y2:
        print('YES')
    else:
        print('NO')"
Python,"def main():
    if size == 1:
        index_lis = [(0,0),(0,-1),(0,1),(-1,0),(1,0)]
    elif size == 2:
        index_lis = [(0,0),(0,-1),(0,1),(-1,-1),(-1,0),(-1,1),(1,-1),(1,0),(1,1)]
    elif size == 3:
        index_lis = [(0,0),(0,-1),(0,-2),(0,1),(0,2),(-1,-1),(-1,0),(-1,1),
                     (1,-1),(1,0),(1,1),(-2,0),(2,0)]
    drop(index_lis, x, y)
    
def drop(index_lis, x, y):
    for add_x, add_y in index_lis:
        _x = x + add_x
        _y = y + add_y
        if 0 <= _x <= 9 and 0 <= _y <= 9:
            sheet[_x][_y] = sheet[_x][_y] + 1
            
def check():
    total = 0
    max_num = 0
    for x in range(10):
        for y in range(10):
            if sheet[x][y] == 0:
                total += 1
            else:
                if sheet[x][y] > max_num:
                    max_num = sheet[x][y]
    print total
    print max_num
sheet = []
for i in range(10):
    lis = []
    for i in range(10):
        lis.append(0)
    sheet.append(lis)
    
while True:
    try:
        x, y, size = map(int, raw_input().split(','))
        main()
    except EOFError:
        check()
        break"
Python,"import sys
def length(a, b):
    return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5
def solve_sim_equ(a, b, c, d, e, f):
    '''
    From Problem 0004.
    This function solves following equation.
    ax + by = c
    dx + ey = f
    '''
    if a==0 and d==0:
        if b==0 and e==0:
            return 0., 0.
        if b != 0:
            return 0., c/b+0.
        else:
            return 0., f/e+0.
    elif b==0 and e==0:
        if a != 0:
            return 0., d/a+0.
        else:
            return 0., a/d+0.
    if b == 0:
        a, d = d, a
        b, e = e, b
        c, f = f, c
    g = e / b
    x = (g*c - f) / (g*a - d)
    y = (c - a*x) / b
    return x+0., y+0.
def circumscribed_circle(x, y, z):
    def get_equ_coef(p, q):
        h_x = (p[0] + q[0]) / 2
        h_y = (p[1] + q[1]) / 2
        a = q[1] - p[1]
        b = p[0] - q[0]
        c = b * h_x - a * h_y
        return b, -a, c
    coef = get_equ_coef(x, y) + get_equ_coef(y, z)
    center = solve_sim_equ(*coef)
    r = length(center, x)
    return center, r
def main():
    N = int(input())
    for i in range(N):
        vs = [float(v) for v in input().split()]
        a = (vs[0], vs[1])
        b = (vs[2], vs[3])
        c = (vs[4], vs[5])
        center, r = circumscribed_circle(a, b, c)
        print('{0:.3f} {1:.3f} {2:.3f}'.format(center[0], center[1], r))
if __name__ == '__main__':
    main()"
Python,"MAX = 1000000
s = [1] * MAX
s[0] = 0
s[1] = 0
start = 2
while True:
    
    pmb = 0
    for i in range(start, MAX):
        if s[i] == 1: 
            pmb = i
            break 
    
   
    if pmb == 0:
        break 
   
    
    for i in range(pmb ** 2, MAX, pmb):
        s[i] = 0  
    start += 1
    
   
   
   
while True:
    try:
        n = int(input())
        
        c = 0
        for i in range(2, n + 1):
            if s[i] == 1:
                c += 1
        print(c)
    except EOFError:
        break
    
      
      
      
      
      "
Python,"p = [[0 for i in range(14)] for j in range(14)]
while True:
    try:
        x_inp, y_inp, s = map(int, input().split("",""))
        x = x_inp + 2
        y = y_inp + 2
        if s == 1:
            p[y-1][x] = p[y-1][x] + 1
            p[y][x-1] = p[y][x-1] + 1
            p[y][x]   = p[y][x]   + 1
            p[y][x+1] = p[y][x+1] + 1
            p[y+1][x] = p[y+1][x] + 1
        elif s == 2:
            p[y-1][x-1] = p[y-1][x-1] + 1
            p[y-1][x]   = p[y-1][x]   + 1
            p[y-1][x+1] = p[y-1][x+1] + 1
            p[y][x-1]   = p[y][x-1]   + 1
            p[y][x]     = p[y][x]     + 1
            p[y][x+1]   = p[y][x+1]   + 1
            p[y+1][x-1] = p[y+1][x-1] + 1
            p[y+1][x]   = p[y+1][x]   + 1
            p[y+1][x+1] = p[y+1][x+1] + 1
        else:
            p[y-2][x] += 1
            p[y-1][x-1] = p[y-1][x-1] + 1
            p[y-1][x]   = p[y-1][x]   + 1
            p[y-1][x+1] = p[y-1][x+1] + 1
            p[y][x-2]   = p[y][x-2]   + 1
            p[y][x-1]   = p[y][x-1]   + 1
            p[y][x]     = p[y][x]     + 1
            p[y][x+1]   = p[y][x+1]   + 1
            p[y][x+2]   = p[y][x+2]   + 1
            p[y+1][x-1] = p[y+1][x-1] + 1
            p[y+1][x]   = p[y+1][x]   + 1
            p[y+1][x+1] = p[y+1][x+1] + 1
            p[y+2][x] += 1
    except:
        break
p_trim = [p[i][2:12] for i in range(2,12)]
p_flatten = sum(p_trim,[])
print(sum(x==0 for x in p_flatten))
print(max(p_flatten))"
Python,"import sys
import math
prim_no = {2: True}                    
def is_prime(no):
    if no == 2 or no == 1:
        return True
    
    if no % 2 == 0:
        return False
    if prim_no.get(no) is not None:
        return prim_no.get(no)
    max_check = int(math.sqrt(no))
    for i in range(3, max_check+1, 2):
        if no % i == 0:
            prim_no[no] = False
            return False
    prim_no[no] = True
    return True
def main():
    prim_vals = {}                         
    num_data = []                          
    
    while True:
        num = sys.stdin.readline()
        if num is None or num.strip() == '':
            break
        num = int(num.strip())
        num_data.append(num)
    sorted_num_data = sorted(num_data)
    prim_num = {}
    
    for num in sorted_num_data:
        if prim_vals.get(num) is not None:
            cnt = prim_vals.get(num)
        else:
            if num == 1:
                cnt = 0
            else:
                cnt = 0
                if num % 2 == 0:
                    start_num = num -1
                else:
                    start_num = num
                    
                for i in range(start_num, 0, -2):
                    if prim_vals.get(i) is not None:
                        cnt += prim_vals.get(i)
                        break
                    
                    if is_prime(i):
                        cnt += 1
                        
                prim_vals[num] = cnt 
        prim_num[num] = cnt
    for num in num_data:
        print(prim_num[num])
if __name__ == '__main__':
    main()
    "
Python,"import sys
import math
class mymath:
    
    pi = 3.14159265358979323846264338
    
    def pnum_eratosthenes(self, n):
        ptable = [0 for i in range(n+1)]
        plist = []
        for i in range(2, n+1):
            if ptable[i]==0:
                plist.append(i)
                for j in range(i+i, n+1, i):
                    ptable[j] = 1
        return plist
    
    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a%b)
    
    def lcm(self, a, b):
        return (a*b)//self.gcd(a,b)
    
    def mul(self, A, B):
        ans = []
        for a in A:
            c = 0
            for j, row in enumerate(a):
                c += row*B[j]
            ans.append(c)
        return ans
mymath = mymath()
class output:
    
    def list(self, l):
        l = list(l)
        
        for i, num in enumerate(l):
            print(num, end="""")
            if i != len(l)-1:
                print("" "", end="""")
        print()
output = output()
def get_input():
    N = []
    while True:
        try:
            
            N.append(int(input()))
        except EOFError:
            break
    return N
N = [int(x) for x in input().split()]
N = sorted(N)
S = ''
for i in N[::-1]:
    S += str(i)+' ' 
print(S[:-1])"
Python,"import math
if __name__ == '__main__':
    n = int(input())
    for i in range(n):
        x1, y1, x2, y2, x3, y3 = map(float, input().split())
        points_list = [[x1, y1], [x2, y2], [x3, y3]]
        points_list.sort()
        if points_list[0][0] == points_list[1][0]:
            py = (points_list[0][1] + points_list[1][1])/2
            if points_list[2][1] == points_list[0][1]:
                px = (points_list[0][0] + points_list[2][0])/2
            else:
                a2_s = (points_list[2][1] - points_list[0][1])/(points_list[2][0] - points_list[0][0])
                a2 = -1/a2_s
                m13x = (points_list[0][0] + points_list[2][0])/2
                m13y = (points_list[0][1] + points_list[2][1])/2
                b2 = m13y - a2*m13x
                px = (py - b2)/a2
        elif points_list[1][0] == points_list[2][0]:
            py = (points_list[1][1] + points_list[2][1])/2
            if points_list[2][1] == points_list[0][1]:
                px = (points_list[0][0]+points_list[2][0])/2
            else:
                a2_s = (points_list[2][1] - points_list[0][1])/(points_list[2][0] - points_list[0][0])
                a2 = -1/a2_s
                m13x = (points_list[0][0] + points_list[2][0])/2
                m13y = (points_list[0][1] + points_list[2][1])/2
                b2 = m13y - a2*m13x
                px = (py - b2)/a2
        elif points_list[0][1] == points_list[1][1]:
            px = (points_list[0][0] + points_list[1][0])/2
            a2_s = (points_list[2][1] - points_list[0][1]) / (points_list[2][0] - points_list[0][0])
            a2 = -1 / a2_s
            m13x = (points_list[0][0] + points_list[2][0]) / 2
            m13y = (points_list[0][1] + points_list[2][1]) / 2
            b2 = m13y - a2 * m13x
            py = a2*px + b2
        elif points_list[0][1] == points_list[2][1]:
            px = (points_list[0][0] + points_list[2][0])/2
            a1_s = (points_list[1][1] - points_list[0][1]) / (points_list[1][0] - points_list[0][0])
            a1 = -1 / a1_s
            m12x = (points_list[0][0] + points_list[1][0]) / 2
            m12y = (points_list[0][1] + points_list[1][1]) / 2
            b1 = m12y - a1 * m12x
            py = a1 * px + b1
        else:
            a1_s = (points_list[1][1] - points_list[0][1])/(points_list[1][0] - points_list[0][0])
            a1 = -1/a1_s
            a2_s = (points_list[2][1] - points_list[0][1])/(points_list[2][0] - points_list[0][0])
            a2 = -1/a2_s
            m12x = (points_list[0][0] + points_list[1][0]) / 2
            m12y = (points_list[0][1] + points_list[1][1]) / 2
            m13x = (points_list[0][0] + points_list[2][0]) / 2
            m13y = (points_list[0][1] + points_list[2][1]) / 2
            b1 = m12y - a1 * m12x
            b2 = m13y - a2 * m13x
            px = (b2 - b1)/(a1 - a2)
            py = a1*px + b1
        r = math.sqrt(math.pow((px-points_list[0][0]), 2) + math.pow((py-points_list[0][1]), 2))
        print('{0:.3f} {1:.3f} {2:.3f}'.format(px, py, r))"
Python,"import sys
import math
def solve(x1,y1,x2,y2,x3,y3):
    z1 = -1 * (x1**2 + y1**2)
    z2 = -1 * (x2**2 + y2**2)
    z3 = -1 * (x3**2 + y3**2)
    a11,a12,a13 = x1,y1,1
    a21,a22,a23 = x2,y2,1
    a31,a32,a33 = x3,y3,1
    det = a11*a22*a33 + a21*a32*a13 + a31*a12*a23 - a11*a32*a23 - a31*a22*a13 - a21*a12*a33
    l = ((a22*a33 - a23*a32)*z1 + (a13*a32 - a12*a33)*z2 + (a12*a23 - a13*a22)*z3)/det
    m = ((a23*a31 - a21*a33)*z1 + (a11*a33 - a13*a31)*z2 + (a13*a21 - a11*a23)*z3)/det
    n = ((a21*a32 - a22*a31)*z1 + (a12*a31 - a11*a32)*z2 + (a11*a22 - a12*a21)*z3)/det
    x,y,r = round(-l/2,3),round(-m/2,3),round(math.sqrt((l**2)/4+(m**2)/4-n),3)
    sol = [x, y, r]
    return sol
n,count = int(input()),0
array = []
for i in sys.stdin:
    array.append(i)
    count += 1
    if count == n:
        break
    
for i in range(len(array)):
    x = array[i]
    p = x.split()
    res = solve(float(p[0]),float(p[1]),float(p[2]),float(p[3]),float(p[4]),float(p[5]))
    print('{:.3f} {:.3f} {:.3f}'.format(res[0], res[1], res[2]))"
C#,"using System;
using System.Collections.Generic;
namespace AOJ.Volume0
{
    class Program0004
    {
        static void Main(string[] args)
        {
            const int N = 6;
            string input;
            Queue<double[]> queue = new Queue<double[]>();
            while ((input = Console.ReadLine()) != null)
            {
                string[] splitedInput = input.Split(' ');
                double[,] param = new double[2,3];
                for (int i = 0; i < 2; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        param[i, j] = double.Parse(splitedInput[i * 3 + j]);
                    }
                }
                queue.Enqueue(SolveEquation(param));
            }
            foreach (var ans in queue)
            {
                Console.WriteLine(, ans[0], ans[1]);
            }
        }
        static double[] SolveEquation(double[,] parameters)
        {
            double x, y;
            double a = parameters[1, 0] / parameters[0, 0];
            for (int i = 0; i < 3; i++)
            {
                parameters[1, i] -= parameters[0, i] * a;
            }
            y = parameters[1, 2] / parameters[1, 1];
            x = (parameters[0, 2] - parameters[0, 1] * y) / parameters[0, 0];
            return new[] { x, y };
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string a;
                a = Console.ReadLine();
                if (a == null) break;
                string d = ;
                string b = ;
                int c = 0;
                for (int i = 0; i <= a.Length - 1; i++)
                {
                    if (a.Substring(i, 1) != )
                    {
                        d = d + a.Substring(i, 1);
                        c += 1;
                    }
                    else
                    {
                        break;
                    }
                }
                for (int i = c + 1; i <= a.Length - 1; i++)
                {
                    b = b + a.Substring(i, 1);
                }
                c = int.Parse(b) + int.Parse(d);
                int z = 0;
                while (c != 0)
                {
                    c = c / 10;
                    z += 1;
                }
                Console.WriteLine(z);
            }
        }
    }
}"
C#,"using System;
namespace V0003{
    public class Program{
        public static void Main(string[] args){
            var sr = new StreamReader();
            
            foreach(var tri in sr.Next<int>(sr.Next<int>(), 3)){
                Array.Sort(tri);
                var ans = tri[0] * tri[0] + tri[1] * tri[1] == tri[2] * tri[2];
                Console.WriteLine(ans ?  : );
            }
            
        }
    }
    public class StreamReader{
        private readonly char[] _c = {' '};
        private int _index = -1;
        private string[] _input = new string[0];
        public T Next<T>(){
            if(_index == _input.Length - 1){
                _index = -1;
                while(true){
                    string rl = Console.ReadLine();
                    if(rl == null){
                        if(typeof(T).IsClass) return default(T);
                        return (T)typeof(T).GetField().GetValue(null);
                    }
                    if(rl != ){
                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);
                        break;
                    }
                }
            }
            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);
        }
        public T[][] Next<T>(int y, int x){
            var result = new T[y][];
            for(var i = 0; i < y; ++i){
                result[i] = new T[x];
                for(var j = 0; j < x; ++j){
                    result[i][j] = Next<T>();
                }
            }
            return result;
        }
    }
}"
C#,"using System;
class _0003
{
    public static void Main()
    {
        int dataNum = int.Parse(Console.ReadLine());
        double[] a = new double[dataNum];
        double[] b = new double[dataNum];
        double[] c = new double[dataNum];
        char[] splitChar = { ' ' };
        for (int i = 0; i < dataNum; i++)
        {
            string[] nums = Console.ReadLine().Split(splitChar);
            a[i] = double.Parse(nums[0]);
            b[i] = double.Parse(nums[1]);
            c[i] = double.Parse(nums[2]);
        }
        for (int i = 0; i < dataNum; i++)
        {
            double angle_A = Math.Acos((Math.Pow(b[i], 2.0) + Math.Pow(c[i], 2.0) - Math.Pow(a[i], 2.0)) / (2 * b[i] * c[i])) * 180.0 / Math.PI;
            double angle_B = Math.Acos((Math.Pow(c[i], 2.0) + Math.Pow(a[i], 2.0) - Math.Pow(b[i], 2.0)) / (2 * c[i] * a[i])) * 180.0 / Math.PI;
            double angle_C = Math.Acos((Math.Pow(a[i], 2.0) + Math.Pow(b[i], 2.0) - Math.Pow(c[i], 2.0)) / (2 * a[i] * b[i])) * 180.0 / Math.PI;
            if (angle_A == 90.0 || angle_B == 90.0 || angle_C == 90.0)
            {
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine();
            }
        }
    }
}"
C#,"using System;
using System.Linq;
namespace V0001{
    public class Program{
        public static void Main(string[] args){
            var sr = new StreamReader();
            
            sr.Next<int>(10).OrderByDescending(x => x).Take(3).ToList().ForEach(Console.WriteLine);
            
        }
    }
    public class StreamReader{
        private readonly char[] _c = {' '};
        private int _index = -1;
        private string[] _input = new string[0];
        public T Next<T>(){
            if(_index == _input.Length - 1){
                _index = -1;
                while(true){
                    string rl = Console.ReadLine();
                    if(rl == null){
                        if(typeof(T).IsClass) return default(T);
                        return (T) typeof(T).GetField().GetValue(null);
                    }
                    if(rl != ){
                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);
                        break;
                    }
                }
            }
            return (T) Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);
        }
        public T[] Next<T>(int x){
            var result = new T[x];
            for(var i = 0; i < x; ++i){
                result[i] = Next<T>();
            }
            return result;
        }
        public T[,] Next<T>(int y, int x){
            var result = new T[y, x];
            for(var i = 0; i < y; ++i){
                for(var j = 0; j < x; ++j){
                    result[i, j] = Next<T>();
                }
            }
            return result;
        }
    }
}"
C#,"using System;
    class Program
    {
        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            double [,]hen=new double[n,3];
            for (int i = 0; i < n; i++)
            {
                string[] s = Console.ReadLine().Split(' ');
                hen[i, 0] = int.Parse(s[0]);
                hen[i, 1] = int.Parse(s[1]);
                hen[i, 2] = int.Parse(s[2]);
            }
            for (int i = 0; i < n; i++)
            {
                hen[i, 0] = Math.Pow(hen[i, 0], 2);
                hen[i, 1] = Math.Pow(hen[i, 1], 2);
                hen[i, 2] = Math.Pow(hen[i, 2], 2);
                if (hen[i, 0] == (hen[i, 1] + hen[i, 2]) || hen[i, 1] == (hen[i, 0] + hen[i, 2])||hen[i, 2] == (hen[i, 0] + hen[i, 1])) 
                { 
                    Console.WriteLine(); 
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
    }"
C#,"using System.Linq;
using System.Collections.Generic;
using System;
namespace AOJ
{
    class Program
    {
        static void Main(string[] args)
        {
            var result = Volume0.IsItARightTriangle();
            System.Diagnostics.Trace.WriteLine(result);
            Console.WriteLine(result);
        }
    }
    public static class Volume0
    {
        public static string IsItARightTriangle()
        {
            var count = int.Parse(Console.ReadLine());
            var result = new List<string>();
            foreach (var i in Enumerable.Range(1, count))
            {
                var inputs = Console.ReadLine().Split(' ').Select(x => int.Parse(x)).OrderByDescending(x => x).ToArray();
                if (Math.Pow(inputs[0], 2) == Math.Pow(inputs[1], 2) + Math.Pow(inputs[2], 2))
                {
                    result.Add();
                }
                else
                {
                    result.Add();
                }
                
            }
            return string.Join(, result.ToArray());
        }
    }
}"
C#,"using System;
namespace AOJ.Volume0
{
    public class SimultaneousEquation
    {
        public static void Main()
        {
            while (true)
            {
                string input = Console.ReadLine();
                if (string.IsNullOrEmpty(input)) { break; }
                var data = input.Split(' ');
                double a, b, c, d, e, f;
                a = double.Parse(data[0]);
                b = double.Parse(data[1]);
                c = double.Parse(data[2]);
                d = double.Parse(data[3]);
                e = double.Parse(data[4]);
                f = double.Parse(data[5]);
                
                
                double v1 = (a * e) - (b * d);
                double x = ((c * e) - (b * f)) / v1;
                double y = ((a * f) - (c * d)) / v1;
                
                x += 0.0005d;
                y += 0.0005d;
                x = Math.Floor(x * 1000) / 1000;
                y = Math.Floor(y * 1000) / 1000;
                Console.WriteLine(string.Format(, x, y));
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace Volume0003
{
    class Program
    {
        static int _NumOfData;
        static List<double> _sides = new List<double>();
        static double _longestSide;
        static double _shortSide1;
        static double _shortSide2;
        static void Main(string[] args)
        {
            _NumOfData = int.Parse(Console.ReadLine());
            for (int i = 0; i < _NumOfData; ++i)
            {
                _sides = Console.ReadLine().Split(' ').Select(double.Parse).ToList();
                _sides.Sort();
                _longestSide = Math.Pow(_sides[2], 2);
                _shortSide1 = Math.Pow(_sides[1], 2);
                _shortSide2 = Math.Pow(_sides[0], 2);
                if (_longestSide == _shortSide1 + _shortSide2)
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
    }
}"
C#,"using System;
namespace Prob0003
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.ReadLine();
            
            string line;
            while((line = Console.ReadLine()) != null)
            {
                string[] tokens = line.Split(' ');
                
                int[] sides = new int[tokens.Length];
                for(int i = 0; i < tokens.Length; i++)
                {
                    sides[i] = int.Parse(tokens[i]);
                    sides[i] *= sides[i];
                }
                
                bool flag = false;
                for(int i = 0; i < tokens.Length; i++)
                {
                    int sum = 0;
                    for(int j = 0; j < tokens.Length; j++)
                    {
                        if(i != j)
                        {
                            sum += sides[j];
                        }
                    }
                    if(sides[i] == sum)
                    {
                        flag = true;
                    }
                }
                Console.WriteLine((flag ?  : ));
            }
        }
    }
}"
C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using System.Text.RegularExpressions;
using System.Linq;
using System.IO;
class Program
{
    static private Magatro M = new Magatro();
    static private void Main(string[]args)
    {
        M.Scan();
        M.Solve();
    }
}
public class Scanner
{
    private string[] S;
    private int Index;
    private char Separator;
    public Scanner(char separator = ' ')
    {
        Index = 0;
        Separator = separator;
        S = new string[0];
    }
    private string[] Line()
    {
        return Console.ReadLine().Split(Separator);
    }
    public string Next()
    {
        string result;
        if (Index >= S.Length)
        {
            S = Line();
            Index = 0;
        }
        result = S[Index];
        Index++;
        return result;
    }
    public int NextInt()
    {
        return int.Parse(Next());
    }
    public double NextDouble()
    {
        return double.Parse(Next());
    }
    public long NextLong()
    {
        return long.Parse(Next());
    }
}
public class Magatro
{
    public void Scan()
    {
    }
    public void Solve()
    {
        for (int i = 1; i <= 9; i++)
        {
            for (int j = 1; j <= 9; j++)
            {
                Console.WriteLine(Anser(i, j));
            }
        }
    }
    private string Anser(int i,int j)
    {
        return string.Format(, i,j,i*j);
    }
}"
C#,"using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
public class Program
{
    public void Proc()
    {
        int[] list = new int[10];
        for (int i = 0; i < 10; i++) {
            list[i] = int.Parse(Reader.ReadLine());
        }
        list = list.OrderByDescending(a => a).ToArray();
        System.Text.StringBuilder ans = new System.Text.StringBuilder();
        for (int i = 0; i < 3; i++) {
            ans.AppendLine(list[i].ToString());
        }
        Console.Write(ans.ToString());
    }
    public class Reader
	{
		private static StringReader sr;
		public static bool IsDebug = false;
		public static string ReadLine()
		{
			if (IsDebug)
			{
				if (sr == null)
				{
					sr = new StringReader(InputText.Trim());
				}
				return sr.ReadLine();
			}
			else
			{
				return Console.ReadLine();
			}
		}
		private static string InputText = @""
1819
2003
876
2840
1723
1673
3776
2848
1592
922
"";
	}
	public static void Main(string[] args)
	{
#if DEBUG
		Reader.IsDebug = true;
#endif
		Program prg = new Program();
		prg.Proc();
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace contest
{
    class Program
    {
        static int Main(string[] args)
        {
            int MAX = 200;
            char text_split = ' ';
            for (int i = 0; i < MAX; i++)
            {
                string read = Console.ReadLine();
                if (read == null) break;
                else
                {
                    string[] words = read.Split(text_split);
                    if( words[1] == null) break;
                    
                    int a_num = int.Parse(words[0]);
                    int b_num = int.Parse(words[1]);
                    
                    int ab = a_num + b_num;
                    int count = 1;
                    while (ab >= 10)
                    {
                        ab /= 10;
                        count++;
                    }
                    Console.WriteLine(, count);
                }
            }
            
            return 0;
        }
    }
}"
C#,"using System;
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] ans = { 0, 0, 0 };
            for (int i = 0; i < 10; i++)
            {
                string a = Console.ReadLine();
                int aa = int.Parse(a);
                if (ans[0] < aa)
                {
                    ans[2] = ans[1];
                    ans[1] = ans[0];
                    ans[0] = aa;
                }
                else if (ans[1] < aa)
                {
                    ans[2] = ans[1];
                    ans[1] = aa;
                }
                else if (ans[2] < aa)
                {
                    ans[2] = aa;
                }
            }
            Console.WriteLine(ans[0]);
            Console.WriteLine(ans[1]);
            Console.WriteLine(ans[2]);
            Console.ReadLine();
            
            
            
            
            
            
            
            
            
            
        }
    }
}"
C#,"using System;
    class Program
    {
        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            double [,]hen=new double[n,3];
            for (int i = 0; i < n; i++)
            {
                string[] s = Console.ReadLine().Split(' ');
                hen[i, 0] = int.Parse(s[0]);
                hen[i, 1] = int.Parse(s[1]);
                hen[i, 2] = int.Parse(s[2]);
            }
            for (int i = 0; i < n; i++)
            {
                hen[i, 0] = Math.Pow(hen[i, 0], 2);
                hen[i, 1] = Math.Pow(hen[i, 1], 2);
                hen[i, 2] = Math.Pow(hen[i, 2], 2);
                if (hen[i, 0] == (hen[i, 1] + hen[i, 2]) || hen[i, 1] == (hen[i, 0] + hen[i, 2])||hen[i, 2] == (hen[i, 0] + hen[i, 1])) 
                { 
                    Console.WriteLine(); 
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
    }"
C#,"using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
public class Program
{
    public void Proc()
    {
        System.Text.StringBuilder ans = new System.Text.StringBuilder();
        while(true) {
            string inpt = Reader.ReadLine();
            if(inpt == null) {
                break;
            }
            decimal[] ret = GetAns(inpt.Split(' ').Select(a => decimal.Parse(a)).ToArray());
            ans.AppendLine(ret[0] +  + ret[1]);
        }
        Console.Write(ans.ToString());
        
    }
    private decimal[] GetAns(decimal[] inpt) {
        decimal[] ret = new decimal[2];
        decimal x = GetX(inpt, -5000, 5000);
        decimal y = GetY(inpt, x);
        ret[0] = Math.Round(x, 3, MidpointRounding.AwayFromZero);
        ret[1] = Math.Round(y, 3, MidpointRounding.AwayFromZero);
        return ret;
    }
    private decimal GetX(decimal[] list, decimal min, decimal max) {
        if(max - min < 0.0000001m) {
            return Math.Round(min, 6, MidpointRounding.ToEven);
        }
        decimal md1 = min + (max - min) / 3;
        decimal md2 = min + (max - min) / 3 * 2;
        decimal[] vals = new decimal[4];
        vals[0] = GetYDiff(list, min);
        vals[1] = GetYDiff(list, md1);
        vals[2] = GetYDiff(list, md2);
        vals[3] = GetYDiff(list, max);
        decimal valMin = vals.Min();
        if(valMin == vals[0]) {
            return GetX(list, min, md1);
        } else if(valMin == vals[1]) {
            return GetX(list, min, md2);
        } else if(valMin == vals[2]) {
            return GetX(list, md1, max);
        } else {
            return GetX(list, md2, max);
        }
    }
    private decimal GetY(decimal[] list, decimal x) {
		decimal y = (list[2] - x * list[0]) / list[1];
        return y;
	}
    private decimal GetYDiff(decimal[] list, decimal x) {
        decimal y = GetY(list, x);
        decimal tmp = Math.Abs((x * list[3] + y * list[4]) - list[5]);
        return tmp;
    }
    public class Reader
	{
		private static StringReader sr;
		public static bool IsDebug = false;
		public static string ReadLine()
		{
			if (IsDebug)
			{
				if (sr == null)
				{
					sr = new StringReader(InputText.Trim());
				}
				return sr.ReadLine();
			}
			else
			{
				return Console.ReadLine();
			}
		}
		private static string InputText = @""
1 2 3 4 5 6
2 -1 -2 -1 -1 -5
"";
	}
	public static void Main(string[] args)
	{
#if DEBUG
		Reader.IsDebug = true;
#endif
		Program prg = new Program();
		prg.Proc();
	}
}"
C#,"using System;
using System.Text;
namespace Simultaneous_Equation
{
    class Program
    {
        static void Main(string[] args)
        {
            var sb = new StringBuilder();
            try
            {
                
                while (true)
                {
                    double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);
                    input[1] = input[1] / input[0];
                    input[2] = input[2] / input[0];
                    input[4] = input[4] - input[3] * input[1];
                    input[5] = input[5] - input[3] * input[2];
                    input[5] = input[5] / input[4];
                    input[2] = input[2] - input[5] * input[1];
                    sb.AppendLine(string.Format(, input[2], input[5]));
                }
                
                
                
            }
            catch
            {
                sb.Remove(sb.Length - 1, 1);
                Console.WriteLine(sb);
                Console.ReadLine();
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
class Program {
    static void Main(string[] args) {
        int n = Cin.Ni();
        for (int i = 0; i < n; i++) {
            int a = Cin.Ni();
            int b = Cin.Ni();
            int c = Cin.Ni();
            int a2 = a * a;
            int b2 = b * b;
            int c2 = c * c;
            Console.WriteLine(
                a2 + b2 == c2 ||
                b2 + c2 == a2 ||
                a2 + c2 == b2
                ?  : );
        }
    }
}
public class Cin {
    private static string[] s = new string[0];
    private static int i = 0;
    private static char[] cs = new char[] { ' ' };
    public static string Next() {
        if (i < s.Length) return s[i++];
        string st = Console.ReadLine();
        while (st == ) st = Console.ReadLine();
        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);
        i = 0;
        return Next();
    }
    public static int Ni() {
        return int.Parse(Next());
    }
    public static long NextLong() {
        return long.Parse(Next());
    }
    public static double NextDouble() {
        return double.Parse(Next());
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
   class Program
    {
        static void Main(string[] args)
        {
            List<string> I = new List<string>();
            string[] I1;
            double[] A = new double[6];
            double[] X = new double[2];
            string s;
            for (int i = 0; true; i++)
            {
                s = Console.ReadLine();
                if (string.IsNullOrEmpty(s)) break;
                I.Add(s);
            }
            for (int i = 0;i<I.Count; i++)
            {
                I1 = I[i].Split();
                for (short j = 0; j < 6; j++) {
                    A[j] = double.Parse(I1[j]);
                }
                X = Solve(A);
                Console.WriteLine(string.Format(,X[0],X[1]));
            }
        }
        public static double[] Solve(params double[] A) {
            double[] A1 = new double[6];
            double[] A2 = new double[6];
            double X, Y;
            int j;
            for (int i = 0; i < 6; i++) {
                j = i < 3 ? 4 : 1;
                A1[i] = A[i] * A[j];
                j = i < 3 ? 3 : 0;
                A2[i] = A[i] * A[j];
            }
            X = (A1[2] - A1[5]) / (A1[0] - A1[3]);
            Y = (A2[2] - A2[5]) / (A2[1] - A2[4]);
            return new double[] {X,Y};
        }
    }"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
class Program {
    static void Main(string[] args) {
        int[] monts = new int[10];
        for (int i = 0; i < 10; i++) {
            monts[i] = Cin.Ni();
        }
        Array.Sort(monts);
        Array.Reverse(monts);
        for (int i = 0; i < 3; i++) {
            Console.WriteLine(monts[i]);
        }                                              
    }
}
public class Cin {
    private static string[] s = new string[0];
    private static int i = 0;
    private static char[] cs = new char[] { ' ' };
    public static string Next() {
        if (i < s.Length) return s[i++];
        string st = Console.ReadLine();
        while (st == ) st = Console.ReadLine();
        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);
        i = 0;
        return Next();
    }
    public static int Ni() {
        return int.Parse(Next());
    }
    public static long NextLong() {
        return long.Parse(Next());
    }
    public static double NextDouble() {
        return double.Parse(Next());
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
namespace CSharpSample01
{
    class Program
    {
        static void Triangle(int a, int b, int c)
        {
            int[] data =  { a, b, c};
            Array.Sort(data);
            if(Math.Pow(data[0], 2) + Math.Pow(data[1], 2) == Math.Pow(data[2], 2))
            {
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine();
            }
    
        }
        
        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            string[] input;
            int a = 0;
            int b = 0;
            int c = 0;
            for(int i = 0; i < n; i++)
            {
                input= Console.ReadLine().Split(' ');
                a = int.Parse(input[0]);
                b = int.Parse(input[1]);
                c = int.Parse(input[2]);
                Triangle(a, b, c);
            }
        }
    }
}"
C#,"using System;
namespace Prob0004
{
    class Program
    {
        static void Main(string[] args)
        {
            const int COLUMN = 2;
            const int ROW = 3;
            string line;
            while((line = Console.ReadLine()) != null)
            {
                
                
                string[] tokens = line.Split(' ');
                double[,] a = new double[COLUMN, ROW];
                for(int y = 0; y < COLUMN; y++)
                {
                    for (int x = 0; x < ROW; x++)
                    {
                        a[y, x] = double.Parse(tokens[y * ROW + x]);
                    }
                }
                
                double coef;
                for (int p = 0; p < ROW - 1; p++)
                {
                    
                    coef = a[p, p];
                    for (int x = p; x < ROW; x++)
                    { 
                        a[p, x] /= coef;
                    }
                    
                    for (int y = 0; y < COLUMN; y++)
                    {
                        if(p == y)
                        {
                            continue;
                        }
                        coef = a[y, p];
                        for (int x = p; x < ROW; x++)
                        {
                            a[y, x] -= a[p, x] * coef;
                        }
                    }
                }
                
                Console.Write(, a[0, ROW - 1].ToString());
                for (int y = 1; y < COLUMN; y++)
                {
                    Console.Write(, a[y, ROW - 1].ToString());
                }
                Console.WriteLine();
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace _0001
{
    public class Program
    {
        public static void Main(string[] args)
        {
            int[] hills = new int[10];
            for (int i = 0 ; i < 10 ; i++)
            {
                hills[i] = ReadInt();
            }
            hills = hills.OrderByDescending(x => x).ToArray();
            Console.WriteLine(hills[0]);
            Console.WriteLine(hills[1]);
            Console.WriteLine(hills[2]);
        }
        static string ReadSt() { return Console.ReadLine(); }
        static int ReadInt() { return int.Parse(Console.ReadLine()); }
        static long ReadLong() { return long.Parse(Console.ReadLine()); }
        static double ReadDouble() { return double.Parse(Console.ReadLine()); }
        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }
        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }
        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }
        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }
        static string WriteAr(int[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(double[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(long[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
    }
}"
C#,"using System;
using System.Collections;
using System.Collections.Generic;
public class Example3
{
	public static void Main ()
	{
		int count = int.Parse( Console.ReadLine ());
		List <string> triangleParameterList = new List<string> ();
		for (int i = 0; i < count; i++) {
			string tempStr = Console.ReadLine ();
			triangleParameterList.Add (tempStr);
		}
		foreach (var t in triangleParameterList) {
			string[] triangleParameterStr = t.Split (' ');
			int[] triangleParameter = new int[3];
			for (int j = 0; j < 3; j++){
				triangleParameter [j] = int.Parse( triangleParameterStr [j]);
			}
			if (isTriangle (triangleParameter)) {
				Console.WriteLine ();
			} else {
				Console.WriteLine ();
			}
		}
	}
	public static bool isTriangle(int[] triangleParameter){
		Array.Sort (triangleParameter);
		int result1 = triangleParameter[0]*triangleParameter[0] + triangleParameter[1]*triangleParameter[1];
		int result2 = triangleParameter [2] * triangleParameter [2];
		           
		if (result1 == result2) {
			return true;
		} else {
			return false;
		}
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace AthleteProgramming
{
    class Program
    {
        static void Main()
        {
            int n = int.Parse(Console.ReadLine());
            for(int i = 0; i < n; i++)
            {
                int[] array = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();
                Sort(ref array);
                CheckRightTriangle(array);
            }
        }
        static void CheckRightTriangle(int[] array)
        {
            if (array[0] * array[0] == array[1] * array[1] + array[2] * array[2])
            {
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine();
            }
        }
        static void Sort(ref int[] array)
        {
            for(int i = array.Length-1; i >= 0; i--)
            {
                for(int j = 0; j < i; j++)
                {
                    if (array[j] < array[j + 1])
                    {
                        Swap(ref array[j], ref array[j + 1]);
                    }
                }
            }
        }
        static void Swap(ref int a, ref int b)
        {
            int tmp = a;
            a = b;
            b = tmp;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace contest
{
    class Program
    {
        static int Main(string[] args)
        {
            int MAX = 200;
            char text_split = ' ';
            for (int i = 0; i < MAX; i++)
            {
                string read = Console.ReadLine();
                if (read == null) break;
                else
                {
                    string[] words = read.Split(text_split);
                    if( words[1] == null) break;
                    
                    int a_num = int.Parse(words[0]);
                    int b_num = int.Parse(words[1]);
                    
                    int ab = a_num + b_num;
                    int count = 1;
                    while (ab >= 10)
                    {
                        ab /= 10;
                        count++;
                    }
                    Console.WriteLine(, count);
                }
            }
            
            return 0;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace _0003
{
    class Program
    {
        static void Main(string[] args)
        {
            
            
            
            
            int n = int.Parse(Console.ReadLine());
            for (int i = 0; i < n; i++)          
            {
                int[] ary = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();
                Array.Sort(ary);                                                            
                if (Math.Pow(ary[0], 2) + Math.Pow(ary[1], 2) == Math.Pow(ary[2], 2))
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
    }
}"
C#,"using System;
namespace TestSpace
{
    class Test
    {
        static void Main(string[] args)
        {
            string[] arrRead;
            int i, j, k, l, N, z;
            N = int.Parse(Console.ReadLine());
            int[] intRead = new int[3];
            for (i = 0; i < N; i++)
            {
                arrRead = Console.ReadLine().Split(' ');
                for (j = 0; j < 3; j++)
                {
                    intRead[j] = int.Parse(arrRead[j]);
                }
                for (k = 0; k < 2; k++)
                {
                    for (l = 2; k < l; l--)
                    {
                        if (intRead[l] < intRead[l - 1])
                        {
                            z = intRead[l];
                            intRead[l] = intRead[l - 1];
                            intRead[l - 1] = z;
                        }                        
                    }
                }
                if (Math.Pow(intRead[0], 2) + Math.Pow(intRead[1], 2) == Math.Pow(intRead[2], 2))
                {
                    Console.WriteLine();
                }
                else 
                {
                    Console.WriteLine();
                }      
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace contest
{
    class Program
    {
        public class Q1
        {
            static public int func()
            {
                int MAX = 200;
                char text_split = ' ';
                for (int i = 0; i < MAX; i++)
                {
                    string read = Console.ReadLine();
                    if (read == null) break;
                    else
                    {
                        string[] words = read.Split(text_split);
                        if (words[1] == null) break;
                        int a_num = int.Parse(words[0]);
                        int b_num = int.Parse(words[1]);
                        
                        int ab = a_num + b_num;
                        int count = 1;
                        while (ab >= 10)
                        {
                            ab /= 10;
                            count++;
                        }
                        Console.WriteLine(, count);
                    }
                }
                return 0;
            }
        }
        public class Q2
        {
            /*
             * s it a Right Triangle?
                1 以上 1000 以下の３つの正の整数を入力し、それぞれの長さを３辺とする三角形が直角三角形である場合には
             * YES を、違う場合には NO と出力して終了するプログラムを作成して下さい。
             * 
             * input
             * 3
                4 3 5
                4 3 6
                8 8 8
             */
            static public int func()
            {
                string read = Console.ReadLine();
                int dataset_num = int.Parse(read);
                int[] num_array = new int[3];
                for (int i = 0; i < dataset_num; i++)
                {
                    
                    var input_line = Console.ReadLine();
                    
                    var line = input_line.Split();
                    int count = 0;
                    foreach (var num in line)
                    {
                        
                        num_array[count++] = int.Parse(num);
                    }
                    
                    
                    Array.Sort(num_array);
                    if (num_array[2] * num_array[2] == (num_array[0] * num_array[0] + num_array[1] * num_array[1]))
                    {
                        Console.WriteLine();
                    }
                    else
                    {
                        Console.WriteLine();
                    }
                }
                return 0;
            }
        }
        static int Main(string[] args)
        {
            Q2.func();
            Console.ReadKey();
            return 0;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace _0002
{
    public class Program
    {
        public static void Main(string[] args)
        {
            while (true)
            {
                string line = Console.ReadLine();
                if (line == null) break;
                int[] items = Array.ConvertAll(line.Split(' '), e => int.Parse(e));
                Console.WriteLine((items[0] + items[1]).ToString().Length);
            }       
        }
        static string ReadSt() { return Console.ReadLine(); }
        static int ReadInt() { return int.Parse(Console.ReadLine()); }
        static long ReadLong() { return long.Parse(Console.ReadLine()); }
        static double ReadDouble() { return double.Parse(Console.ReadLine()); }
        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }
        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }
        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }
        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }
        static string WriteAr(int[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(double[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(long[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace Digit_Number
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string s = Console.ReadLine();
                if (s == null)
                {
                    break;
                }
                string[] input = s.Split(' ');
                int num1 = int.Parse(input[0]);
                int num2 = int.Parse(input[1]);
                int temp = num1 + num2;
                if (temp >= 1000000)
                {
                    Console.WriteLine(7);
                }
                else if (temp >= 100000 && temp <= 999999)
                {
                    Console.WriteLine(6);
                }
                else if (temp >= 10000 && temp <= 99999)
                {
                    Console.WriteLine(5);
                }
                else if (temp >= 1000 && temp <= 9999)
                {
                    Console.WriteLine(4);
                }
                else if (temp >= 100 && temp <= 999)
                {
                    Console.WriteLine(3);
                }
                else if (temp >= 10 && temp <= 99)
                {
                    Console.WriteLine(2);
                }
                else
                {
                    Console.WriteLine(1);
                }
            }
        }
    }
}"
C#,"using System;
namespace _0004 {
	public static class Program {
		public static void Main() {
			string input;
			while (!string.IsNullOrEmpty(input = Console.ReadLine())) {
				var splitStr = input.Split(' ');
				var a = int.Parse(splitStr[0]);
				var b = int.Parse(splitStr[1]);
				var c = int.Parse(splitStr[2]);
				var d = int.Parse(splitStr[3]);
				var e = int.Parse(splitStr[4]);
				var f = int.Parse(splitStr[5]);
				if (a != 0 && d != 0) {
					var adLcm = LCM(a, d);
					var beDiff = b * (adLcm / a) - e * (adLcm / d);
					var cfDiff = c * (adLcm / a) - f * (adLcm / d);
					var y = ((double) cfDiff) / beDiff;
					var x = (c - (b * y)) / a;
					Console.WriteLine(, x, y);
				} else if (a == 0) {
					var y = ((double) c) / b;
					var x = (f - (e * y)) / d;
					Console.WriteLine(, x, y);
				} else {
					var y = ((double) f) / e;
					var x = (c - (b * y)) / a;
					Console.WriteLine(, x, y);
				}
			}
		}
		private static int LCM(int m, int n) {
			return m * n / GCD(m, n);
		}
		private static int GCD(int m, int n) {
			m = Math.Abs(m);
			n = Math.Abs(n);
			if (m < n) {
				return GCD(n, m);
			}
			return n == 0 ? m : GCD(n, m % n);
		}
	}
}"
C#,"using System;
class main
{
    static void Main(string[] args)
    {
            string s = Console.ReadLine();
            if (s != null)
            {
                int n = int.Parse(s);
                for (int i = 1; i <= n; ++i)
                {
                string s2 = Console.ReadLine();
                    if (s2 != null)
                    {
                        string[] t = s2.Split(' ');
                        int[] a = new int[3];
                        a[0] = int.Parse(t[0]);
                        a[1] = int.Parse(t[1]);
                        a[2] = int.Parse(t[2]);
                        Array.Sort(a);
                        if ((a[2] * a[2]) == (a[1] * a[1] + a[0] * a[0]))
                        {
                            Console.WriteLine();
                        }
                        else
                        {
                            Console.WriteLine();
                        }
                    }
                }
            }
        
    }
}"
C#,"using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
public class my
{
	
	private static StringBuilder sb = new StringBuilder();
	
	public static void Main()
	{
		string s;
		var list = new List<int>();
		
		while( null != ( s = Console.ReadLine() ) ){
			var n = int.Parse(s);
			
			if(list.Count < 3) {
				list.Add(n);
				list.Sort();
			} else {
				for(int i = 0; i < 3; i++) {
					if(n > list[i]) {
						list.RemoveAt(i);
						list.Add(n);
						list.Sort();
						break;
					}
				}
			}
		}
		Console.WriteLine(list[2]);
		Console.WriteLine(list[1]);
		Console.WriteLine(list[0]);
	}
	
	private static int CountChar(string s, char c)
	{
		return s.Length - s.Replace(c.ToString(), ).Length;
	}
	
	private static void Flush()
	{
		Console.Write(sb);
		sb.Length = 0;
	}
	
	private static void AppendLine(int v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(long v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(string[] v)
	{
		sb.AppendLine(string.Join(, v));
	}
	private static void Swap(ref string a, ref string b) 
	{
		string tmp = a;
		a = b;
		b = tmp;
	}
	
	private static void Swap(ref int a, ref int b) 
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	
	private static int[] GetIntArray()
	{
		return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);
	}
	
	private static void WriteArray(int[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static void WriteArray(long[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static int GetInt()
	{
		return int.Parse(Console.ReadLine());
	}
	
	private static long GetLong()
	{
		return long.Parse(Console.ReadLine());
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace _0003
{
    class Program
    {
        static void Main(string[] args)
        {
            int infomationLength = int.Parse(Console.ReadLine());
            List<string> answerList = new List<string>();
            for (int i = 0; i < infomationLength; ++i)
            {
                int[] sideList = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();
                Array.Sort(sideList);
                answerList.Add(IsRightAngle(sideList));
            }
            foreach(string i in answerList)
            {
                Console.WriteLine(i);
            }
        }
        static string IsRightAngle(int[] sideList)
        {
            if(Math.Pow(sideList[2],2) == (Math.Pow(sideList[0], 2) + Math.Pow(sideList[1], 2)))
            {
                return ;
            }
            else
            {
                return ;
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace _0003
{
    public class Program
    {
        public static void Main(string[] args)
        {
            int n = ReadInt();
            for (int i = 0 ; i < n ; i++)
            {
                int[] line = ReadIntAr();
                line = line.OrderBy(x => x).ToArray();
                Console.WriteLine(Math.Pow(line[0], 2) + Math.Pow(line[1], 2) == Math.Pow(line[2], 2) ?  : );
            }
        }
        static string ReadSt() { return Console.ReadLine(); }
        static int ReadInt() { return int.Parse(Console.ReadLine()); }
        static long ReadLong() { return long.Parse(Console.ReadLine()); }
        static double ReadDouble() { return double.Parse(Console.ReadLine()); }
        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }
        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }
        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }
        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }
        static string WriteAr(int[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(double[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(long[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
    }
}"
C#,"using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
public class Program
{
    public void Proc()
    {
        System.Text.StringBuilder ans = new System.Text.StringBuilder();
        int inputCount = int.Parse(Reader.ReadLine());
        for (int i = 0; i < inputCount; i++) {
            if(IsRightTriangle(Reader.ReadLine().Split(' ').Select(a=>int.Parse(a)).ToArray())) {
                ans.AppendLine();
            } else {
                ans.AppendLine();
            }
        }
        Console.Write(ans.ToString());
        
    }
    private bool IsRightTriangle(int[] len) {
        return IsRightTriangleSub(len[0], len[1], len[2]) || IsRightTriangleSub(len[0], len[2], len[1]) || IsRightTriangleSub(len[1], len[2], len[0]);
    }
    private bool IsRightTriangleSub(int num1, int num2, int num3) {
        if(num1*num1+num2*num2==num3*num3) {
            return true;
        }
        return false;
    }
    public class Reader
	{
		private static StringReader sr;
		public static bool IsDebug = false;
		public static string ReadLine()
		{
			if (IsDebug)
			{
				if (sr == null)
				{
					sr = new StringReader(InputText.Trim());
				}
				return sr.ReadLine();
			}
			else
			{
				return Console.ReadLine();
			}
		}
		private static string InputText = @""
3
4 3 5
4 3 6
8 8 8
"";
	}
	public static void Main(string[] args)
	{
#if DEBUG
		Reader.IsDebug = true;
#endif
		Program prg = new Program();
		prg.Proc();
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Vol0_3
{
    class Program
    {
        static void Main(string[] args)
        {
            
            int iInputNum = int.Parse(Console.ReadLine());
            
            for (int i = 0; i < iInputNum; i++)
            {
                List<double> iList = new List<double>();
                int iParam1 = 0;
                int iParam2 = 0;
                int iParam3 = 0;
                
                
                string[] str_List = Console.ReadLine().Split(' ');
                iParam1 = int.Parse(str_List[0]);
                iParam2 = int.Parse(str_List[1]);
                iParam3 = int.Parse(str_List[2]);
                
                iList.Add(System.Math.Pow(iParam1,2));
                iList.Add(System.Math.Pow(iParam2,2));
                iList.Add(System.Math.Pow(iParam3,2));
                iList.Sort();
                
                
                double dTmp = iList[0] + iList[1];
                if (dTmp == iList[2])
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
            Console.ReadLine();
        }
    }
}"
C#,"using System;
class main
{
    static void Main(string[] args)
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        for (int a = 1; a <= 9; ++a)
        {
            for (int b = 1; b <= 9; ++b)
            {
                Console.WriteLine(a +  + b +  + (a*b));
            }
        }
            
            /*int d = a[0] / a[1];
            int r = a[0] % a[1];
            decimal f = (decimal)a[0] / (decimal)a[1];
            Console.WriteLine(d +  + r +  + f);*/
            /*int i = 1;
            while (true)
            {
                string[] s = Console.ReadLine().Split(' ');
                a[0] = int.Parse(s[0]);
                a[1] = int.Parse(s[1]);
                if (a[0] == 0 && a[1] == 0)
                    break;
                Array.Sort(a);
                Console.WriteLine(a[0] +  + a[1]);
                i++;
            }*/
            /*if (y < x)
            {
                Console.WriteLine( +  + );
            }
            if (y > x)
            {
                Console.WriteLine( +  + );
            }
            if (y == x)
            {
                Console.WriteLine( +  + );
            }*/
            
            /*Console.WriteLine(a[0] +  + a[1] +  + a[2]);
            while(g <= 1000)
            {
                Console.WriteLine();
                ++g;
            }*/
            /*int i = 1;
            while (true)
            {
                string s = Console.ReadLine();
                if (s == )
                    break;
                Console.WriteLine(, i, s);
                i++;
            }*/
            /*for (int s = 0; s < j.Length; ++s)
            {
                Console.WriteLine( + (s+1) +  + j[s]);
            }
            Console.WriteLine(g);*/
            Console.ReadKey();
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Diagnostics;
namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> outList = new List<int>();
            string input;
            while ((input = Console.ReadLine()) != null)
            {
                string[] array = input.Split(' ');
                int sum = int.Parse(array[0]) + int.Parse(array[1]);
                outList.Add(GetDigit(sum));
            }
            foreach (int n in outList)
            {
                Console.WriteLine(n);
            }
            
        }
        static int GetDigit(int sum)
        {
            int count = 1;
            int i = 1;
            while (true)
            {
                i *= 10;
                if (sum - i < 0)
                {
                    break;
                }
                count++;
            }
            return count;
        }
    }
        
}"
C#,"using System;
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            string sCount =Console.ReadLine();
            int ncount = int.Parse(sCount);
            for (int i = 0; i < ncount; i++)
            {
                string input = Console.ReadLine();
                string[] data = input.Split();
                int data1 = int.Parse(data[0]);
                int data2 = int.Parse(data[1]);
                int data3 = int.Parse(data[2]);
                
                int ans = 0;
                if (data1 * data1 + data2 * data2 == data3 * data3)
                    ans++;
                if (data1 * data1 + data3 * data3 == data2 * data2)
                    ans++;
                if (data3 * data3 + data2 * data2 == data1 * data1)
                    ans++;
                if (ans == 0)
                    Console.WriteLine();
                else
                    Console.WriteLine();
            }
            Console.ReadLine();
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace P0003_Is_it_a_Right_Triangle
{
    class Program
    {
        static void Main(string[] args)
        {
            List<string> lines = new List<string>();
            int cntLine = int.Parse(Console.ReadLine());
            for(int i = 1; i <= cntLine; i++)
            {
                lines.Add(Console.ReadLine());
            }          
            foreach (string line in lines)
            {
                List<string> sidesStr = line.Split(' ').ToList<string>();
                List<int> sides = new List<int>();
                foreach (string sideStr in sidesStr)
                {
                    sides.Add(int.Parse(sideStr));
                }
                sides.Sort();
                if (Math.Pow(sides[2], 2) == Math.Pow(sides[0], 2) + Math.Pow(sides[1], 2))
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Pair = System.Collections.Generic.KeyValuePair<int, int>;
class Program
{
	public Program() { }
	static void Main(string[] args)
	{
		new Program().prog();
	}
	Scanner cin;
	const int MOD = 1000000007;
	const int INF = int.MaxValue;
	const double EPS = 1e-7;
	
	void prog()
	{
		cin = new Scanner();
		int[] hight = new int[10];
		for (int i = 0; i < 10; i++)
		{
			hight[i] = cin.nextInt();
		}
		Array.Sort(hight);
		Array.Reverse(hight);
		for (int i = 0; i < 3; i++)
		{
			Console.WriteLine(hight[i]);
		}
	}
}
class Scanner
{
	string[] s;
	int i;
	char[] cs = new char[] { ' ' };
	public Scanner()
	{
		s = new string[0];
		i = 0;
	}
	public string next()
	{
		if (i < s.Length) return s[i++];
		string st = Console.ReadLine();
		while (st == ) st = Console.ReadLine();
		s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);
		i = 0;
		return next();
	}
	public int nextInt()
	{
		return int.Parse(next());
	}
	public long nextLong()
	{
		return long.Parse(next());
	}
	public double nextDouble()
	{
		return double.Parse(next());
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Linq.Expressions;
namespace CS_Contest {
	using Li = List<int>;
	using LLi = List<List<int>>;
	using Ll = List<long>;
	internal class Program {
		private static void Main(string[] args) {
			var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };
			Console.SetOut(sw);
			new Calc().Solve();
			Console.Out.Flush();
		}
		public class Calc {
			public class Vector2<T1, T2> {
				public T1 Item1;
				public T2 Item2;
				public Vector2(T1 item1,T2 item2) {
					Item1 = item1;
					Item2 = item2;
				}
			}
			public void Solve() {
				var list = new List<int>();
				for (int i = 0; i < 10; i++) list.Add(int.Parse(Console.ReadLine()));
				foreach (var item in list.OrderByDescending(x=>x).Take(3)) {
					Console.WriteLine(item);
				}
				return;
			}
		}
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
}"
C#,"using System;
using System.Text;
using System.Collections.Generic;
namespace Solution
{
    class Solution
    {
        static void Main(string[] args)
        {
            List<int> mountains = new List<int>();
            for(int i = 0; i <= 9; i++)
            {
                int height = Int32.Parse(Console.ReadLine());
                for(int j = 0; j <= mountains.Count; j++)
                {
                    if (j == mountains.Count)
                    {
                        mountains.Add(height);
                        break;
                    }
                    if (height >= mountains[j])
                    {
                        mountains.Insert(j, height);
                        break;
                    }
                }
            }
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(mountains[0].ToString());
            sb.AppendLine(mountains[1].ToString());
            sb.Append(mountains[2].ToString());
            Console.WriteLine(sb.ToString());
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Contest
{
    class Program
    {
        static int Main(string[] args)
        {
            new Program().Process();
            return 0;
        }
        private CommonInput cin;
        private void Process()
        {
            this.cin = new CommonInput();
            int a, b, c, d, e, f;
            double x, y;
            string s;
            while (true)
            {
                s = cin.GetLine();
                if (s == null)
                    break;
                a = int.Parse(s);
                b = cin.GetInt();
                c = cin.GetInt();
                d = cin.GetInt();
                e = cin.GetInt();
                f = cin.GetInt();
                x = (double)(c * e - f * b) / (a * e - d * b);
                y = (double)(c * d - f * a) / (b * d - e * a);
                Console.WriteLine(, x, y);
            }
        }
    }
    public class CommonInput
    {
        public CommonInput()
        {
            this._s = new string[0];
            this._i = 0;
        }
        private string[] _s;
        private int _i;
        private char[] _sep = { ' ' };
        public string GetLine()
        {
            if (this._i < this._s.Length)
                return this._s[this._i++];
            string line;
            this._i = 0;
            do
            {
                line = Console.ReadLine();
            } while (line == );
            if (line == null)
                return null;
            this._s = line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);
            return this._s[this._i++];
        }
        public int GetInt()
        {
            return int.Parse(this.GetLine());
        }
        public long GetLong()
        {
            return long.Parse(this.GetLine());
        }
        public double GetDouble()
        {
            return double.Parse(this.GetLine());
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            Judge judge = new Judge();
            List<string> ans = new List<string>();
            int n = int.Parse(Console.ReadLine());
            for (int i = 0; i < n;  i++)
            {
                List<int> length = Console.ReadLine().Split(' ').Select(int.Parse).ToList();
                int max = length.Max();
                length.Remove(max);
                ans.Add(judge.Calc(max, length));
            }
            foreach (string item in ans)
            {
                Console.WriteLine(item);
            }
        }
    }
    class Judge
    {
        internal string Calc(int max, List<int> length)
        {
            string ans;
            double leftside = Math.Pow(max, 2);
            double rightside = Math.Pow(length[0], 2) + Math.Pow(length[1], 2);
            if (leftside == rightside)
            {
                ans = ;
            }
            else
            {
                ans = ;
            }
            return ans;
        }
        
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
class Program
{
    void Calc()
    {
        var sc = new Scanner();
        var a = sc.NextInt();
        for (int i = 0; i < a; i++)
        {
            int b = sc.NextInt();
            int c = sc.NextInt();
            int d = sc.NextInt();
            int[] kasatomo = new int[3];
            kasatomo[0] = b;
            kasatomo[1] = c;
            kasatomo[2] = d;
            Array.Sort(kasatomo);
            if (kasatomo[0] * kasatomo[0] + kasatomo[1] * kasatomo[1] == kasatomo[2] * kasatomo[2])
            {
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine();
            }
        }
        /*
        if (a > 0)
        {
            w = true;
            while (w == true)
            {
                int b = sc.NextInt();
                int c = sc.NextInt();
                int d = sc.NextInt();
                a = a--;
                if (b * b + c * c == d * d)
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
        else
        {
            w = false;
        }*/
    }
    static void Main()
    {
        new Program().Calc();
    }
    class Scanner
    {
        string[] s = new string[0];
        int i = 0;
        char[] cs = new char[] { ' ' };
        public string Next()
        {
            if (i < s.Length) return s[i++];
            s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);
            i = 0;
            return s[i++];
        }
        public int NextInt() { return int.Parse(Next()); }
        public long NextLong() { return long.Parse(Next()); }
        public double NextDouble() { return double.Parse(Next()); }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace ConsoleApplication2 {
    class Program {
        static void Main(string[] args) {
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
        }
    }
}"
C#,"using System;
namespace AIZUJudge {
    class EquisionSolver {
        static void Main(string[] args) {
            string line = ;
            while ((line = Console.ReadLine()) != null) {
                string[] set = line.Split(' ');
                int devides = 2;
                int lineLength = 3;
                Matrix eqMatrix = new Matrix(devides,lineLength-1);
                Matrix scalar = new Matrix(devides,1);
                for (int i = 0; i < devides; i++) {
                    for (int j = 0; j < lineLength-1; j++) {
                        eqMatrix.setElement(i, j, set[i*lineLength+j]);
                    }
                }
                scalar.setElement(0, 0,set[2]);
                scalar.setElement(1, 0, set[5]);
                double[] sol = eqMatrix.solveEq(scalar,2);
                Console.WriteLine(sol[0].ToString() +  + sol[1].ToString());
            }
       }
    }
    
    public class Matrix {
        double[,] element;
        public Matrix(int rowSize, int columnSize) {
            element = new double[rowSize, columnSize];
        }
        public void setElement(int row, int column, string value) {
            element[row, column] = double.Parse(value);
        }
        public double[] solveEq(Matrix scalar,int sol_Length) {
            double[] solution = new double[sol_Length];
            solution[0] = (element[1, 1] * scalar.element[0, 0] - element[0, 1] * scalar.element[1, 0]) / (element[0, 0] * element[1, 1] - element[0, 1] * element[1, 0]);
            solution[1] = (element[0, 0] * scalar.element[1, 0] - element[1, 0] * scalar.element[0, 0]) / (element[0, 0] * element[1, 1] - element[0, 1] * element[1, 0]);
            return solution;
        }
    }
}"
C#,"using System.Linq;
using System.Collections.Generic;
using System;
public class Hello{
    public static void Main(){
        
        
        var n = int.Parse(System.Console.ReadLine());
        
        
        
        
        for (var i = 0; i < n; i++) {
            var line = System.Console.ReadLine().Split(' ');
            var line2 = line.Select(elem => int.Parse(elem)).ToList();
            var a = line2[0];
            var b = line2[1];
            var c = line2[2];
            var a2 = Math.Pow(a,2) == Math.Pow(b,2) + Math.Pow(c,2);
            var b2 = Math.Pow(b,2) == Math.Pow(c,2) + Math.Pow(a,2);
            var c2 = Math.Pow(c,2) == Math.Pow(a,2) + Math.Pow(b,2);
            
            if (a2 || b2 || c2) {
                System.Console.WriteLine();
            }
            else {
                System.Console.WriteLine();
            }
        }
       
        
    }
}"
C#,"using System;
using System.Collections;
using System.Linq;
namespace Simultaneous_Equation
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayList[] result = new ArrayList[2];
            result[0] = new ArrayList();
            result[1] = new ArrayList();
            while (true)
            {
                var input = Console.ReadLine();
                if (string.IsNullOrEmpty(input)) break;
                var strcoe = input.Split(' ');
                if (strcoe.Length != 6) continue;
                double[] coe = new double[6];
                for(var i = 0; i < coe.Length; i++)
                {
                    coe[i] = double.Parse((strcoe[i]));
                }
                ArrayList[] matrix1 = new ArrayList[2];
                for(int i = 0; i < 2; i++)
                {
                    matrix1[i] = new ArrayList();
                    for (int j = 0; j < 2; j++)
                    {
                        matrix1[i].Add(coe[i * 3 + j]);
                    }
                }
                ArrayList[] matrix2 = new ArrayList[2];
                for (int i = 0; i < 2; i++)
                {
                    matrix2[i] = new ArrayList();
                    matrix2[i].Add(coe[i * 3 + 2]);
                }
                Matrix mt = new Matrix();
                ArrayList[] inv = mt.Inverse_2_2(matrix1);
                if(inv == null) { continue; }
                ArrayList[] xy = mt.Product(inv, matrix2);
                result[0].Add(xy[0][0]);
                result[1].Add(xy[1][0]);
            }
            for(int i = 0; i < result[0].Count; i++)
            {
                Console.WriteLine(, result[0][i], result[1][i]);
            }
        }
    }
    class Matrix
    {
        public ArrayList[] Inverse_2_2(ArrayList[] matrix)
        {
            ArrayList[] inv = new ArrayList[2];
            for (int i = 0; i < 2; i++)
            {
                inv[i] = new ArrayList();
                for (int j = 0; j < 2; j++)
                {
                    inv[i].Add(.0);
                }
            }
            
            var det = (double)matrix[0][0] * (double)matrix[1][1] - (double)matrix[0][1] * (double)matrix[1][0];
            if(det == 0) { return null; }
            inv[0][0] = (double)matrix[1][1] / (double)det;
            inv[1][1] = (double)matrix[0][0] / (double)det;
            inv[0][1] = (double)matrix[0][1] / (double)-det;
            inv[1][0] = (double)matrix[1][0] / (double)-det;
            return inv;
        }
        public ArrayList[] Product(ArrayList[] matrix1, ArrayList[] matrix2)
        {
            var row1 = matrix1.Count();
            var col1 = matrix1[0].Count;
            var col2 = matrix2[0].Count;
            ArrayList[] result = new ArrayList[2];
            for (int i = 0; i < row1; i++)
            {
                result[i] = new ArrayList();
                for (int j = 0; j < col2; j++)
                {
                    result[i].Add(.0);
                }
            }
            for(int i = 0; i < row1; i++)
            {
                for(int j = 0; j < col2; j++)
                {
                    double val = 0;
                    for(int k = 0; k < col1; k++) {
                        val += (double)matrix1[i][k] * (double)matrix2[k][j];
                    }
                    result[i][j] = val;
                }
            }
            
            return result;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
namespace ConsoleApp2
{
    class Program
    {
        static void Main(string[] args)
        {
            string A1 = Console.ReadLine();
            string A2 = Console.ReadLine();
            string A3 = Console.ReadLine();
            string A4 = Console.ReadLine();
            string A5 = Console.ReadLine();
            string A6 = Console.ReadLine();
            string A7 = Console.ReadLine();
            string A8 = Console.ReadLine();
            string A9 = Console.ReadLine();
            string A10 = Console.ReadLine();
            int a1 = int.Parse(A1);
            int a2 = int.Parse(A2);
            int a3 = int.Parse(A3);
            int a4 = int.Parse(A4);
            int a5 = int.Parse(A5);
            int a6 = int.Parse(A6);
            int a7 = int.Parse(A7);
            int a8 = int.Parse(A8);
            int a9 = int.Parse(A9);
            int a10 = int.Parse(A10);
            
            var A = new List<int>();
            A.Add(a1);
            A.Add(a2);
            A.Add(a3);
            A.Add(a4);
            A.Add(a5);
            A.Add(a6);
            A.Add(a7);
            A.Add(a8);
            A.Add(a9);
            A.Add(a10);
            A.Sort();
            Console.WriteLine(A[9]);
            Console.WriteLine(A[8]);
            Console.WriteLine(A[7]);
            Console.ReadKey();
        }
    }
}"
C#,"using System;
class p0003
{
    static void Main(string[] args)
    {
        string[] s;
        int[] a = new int[3];
        int n = int.Parse(Console.ReadLine());
        while (0 < n--)
        {
            s = Console.ReadLine().Split(' ');
            for (int i = 0; i < 3; ++i)
            {
                a[i] = int.Parse(s[i]);
                a[i] = a[i] * a[i];
            }
            Console.WriteLine(, ((a[0] == a[1] + a[2] || a[1] == a[0] + a[2] || a[2] == a[0] + a[1]) ?  : ));
        }
    }
    
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
class Program
{
    void Calc()
    {
        var sc = new Scanner();
        int[] asano = new int[10];
        for (int i = 0; i < 10; i++)
        {
            int a = sc.NextInt();
            asano[i] =  a;
        }
        Array.Sort(asano);
        Console.WriteLine(asano[9]);
        Console.WriteLine(asano[8]);
        Console.WriteLine(asano[7]);
    }
    static void Main()
    {
        new Program().Calc();
    }
    class Scanner
    {
        string[] s = new string[0];
        int i = 0;
        char[] cs = new char[] { ' ' };
        public string Next()
        {
            if (i < s.Length) return s[i++];
            s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);
            i = 0;
            return s[i++];
        }
        public int NextInt() { return int.Parse(Next()); }
        public long NextLong() { return long.Parse(Next()); }
        public double NextDouble() { return double.Parse(Next()); }
    }
}"
C#,"using System;
using System.Linq;
namespace V0002{
    public class Program{
        public static void Main(string[] args){
            var sr = new StreamReader();
            
            int[] input;
            while((input = sr.Next<int>(2))[0] != int.MinValue) Console.WriteLine(input.Sum().ToString().Length);
            
        }
    }
    public class StreamReader{
        private readonly char[] _c = {' '};
        private int _index = -1;
        private string[] _input = new string[0];
        public T Next<T>(){
            if(_index == _input.Length - 1){
                _index = -1;
                while(true){
                    string rl = Console.ReadLine();
                    if(rl == null){
                        if(typeof(T).IsClass) return default(T);
                        return (T) typeof(T).GetField().GetValue(null);
                    }
                    if(rl != ){
                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);
                        break;
                    }
                }
            }
            return (T) Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);
        }
        public T[] Next<T>(int x){
            var result = new T[x];
            for(var i = 0; i < x; ++i){
                result[i] = Next<T>();
            }
            return result;
        }
    }
}"
C#,"/*using System;
using System.Linq;
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string a;
                a = Console.ReadLine();
                if (a == null) break;
                string[] b = a.Split();
                int sum, cou = 0;
                sum = int.Parse(b[0]) + int.Parse(b[1]);
                for (; ; )
                {
                    if (sum >= 10)
                    {
                        sum = sum / 10;
                        cou++;
                    }
                    else
                    {
                        cou++;
                        break;
                    }
                }
                Console.WriteLine(cou);
            }
        }
    }
*/
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
class Program
{
    public const int INF = 1 << 25;
    static void Main()
    {
        string str;
        while (!string.IsNullOrEmpty(str = Console.ReadLine()))
        {
            string[] input = str.Split(' ');
            int a = int.Parse(input[0]);
            int b = int.Parse(input[1]);
            int c = a + b;
            int ans = 1;
            while (c / 10 != 0)
            {
                c /= 10;
                ans++;
            }
            Console.WriteLine(ans);
        }
    }
}"
C#,"using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
public class my
{
	
	private static StringBuilder sb = new StringBuilder();
	
	public static void Main()
	{
		var n = my.GetInt();
		
		for(int i = 0; i < n; i++) {
			var A = my.GetIntArray();
			
			Array.Sort(A);
			
			sb.AppendLine( (A[0]*A[0] + A[1]* A[1]== A[2]*A[2])?  : );
		}
		
		my.Flush();
	}
	
	private static int CountChar(string s, char c)
	{
		return s.Length - s.Replace(c.ToString(), ).Length;
	}
	
	private static void Flush()
	{
		Console.Write(sb);
		sb.Length = 0;
	}
	
	private static void AppendLine(int v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(long v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(string[] v)
	{
		sb.AppendLine(string.Join(, v));
	}
	private static void Swap(ref string a, ref string b) 
	{
		string tmp = a;
		a = b;
		b = tmp;
	}
	
	private static void Swap(ref int a, ref int b) 
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	
	private static int[] GetIntArray()
	{
		return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);
	}
	
	private static void WriteArray(int[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static void WriteArray(long[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static int GetInt()
	{
		return int.Parse(Console.ReadLine());
	}
	
	private static long GetLong()
	{
		return long.Parse(Console.ReadLine());
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
namespace JagArrayTest
{
    class Program
    {
        static void Main(string[] args)
        {
            var dataSetCount = Convert.ToInt32(Console.ReadLine());
            List<List<double>> dataSetList = new List<List<double>>();
            for(int count = 0; count< dataSetCount; count++)
            {
                var dataSet = Console.ReadLine().Split(' ').ToList().ConvertAll(double.Parse);
                dataSetList.Add(new List<double>() { dataSet[0], dataSet[1], dataSet[2] });
            }
            foreach(var elm in dataSetList)
            {
                if(isRightTriangle(elm))
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
        static bool isRightTriangle(List<double> lengthList)
        {
            var sortedList = lengthList.OrderByDescending(d => d).ToList();
            if(Math.Pow(sortedList[0], 2) == (Math.Pow(sortedList[1], 2) + (Math.Pow(sortedList[2], 2))))
            {
                return true;
            }
            return false;
        }
    }
}"
C#,"using System;
using System.Linq;
class Program
{
    public static void Main(string[] args)
    {
        int sum = 0;
        while(true)
        {
            string s = Console.ReadLine();
            if(s == null) break;
            string[] ss = s.Split();
            int a = int.Parse(ss[0]);
            int b = int.Parse(ss[1]);
            sum = a + b;
            
            if(sum / 1000000 >= 1)
            {
                Console.WriteLine(7);
            }else if(sum / 100000 >= 1)
            {
                Console.WriteLine(6);
            }else if(sum / 10000 >= 1)
            {
                Console.WriteLine(5);
            }else if(sum / 1000 >= 1)
            {
                Console.WriteLine(4);
            }else if(sum/ 100 >= 1)
            {
                Console.WriteLine(3);
            }else if(sum / 10 >= 1)
            {
                Console.WriteLine(2);
            }else
            {
                Console.WriteLine(1);
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            List<string> YesNo = new List<string>();
            int  count =Convert.ToInt32( Console.ReadLine());
            List<int> datList;
            string s=;
            for (int i = 0; i < count; i++)
            {
                s= Console.ReadLine();
                datList = new List<int>();
                datList.Add(Convert.ToInt32(s.Split(' ')[0]));
                datList.Add(Convert.ToInt32(s.Split(' ')[1]));
                datList.Add(Convert.ToInt32(s.Split(' ')[2]));
                datList.Sort();
                if (Math.Pow(datList[2], 2) == Math.Pow(datList[0], 2) + Math.Pow(datList[1], 2))
                { 
                    YesNo.Add(); 
                }
                else {
                    YesNo.Add(); 
                }
            }
            for (int i = 0; i < YesNo.Count; i++)
            {
                Console.WriteLine(YesNo[i]);
            }
            Console.ReadLine(); 
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace aoj
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string a = ;
                string b = ;
                string c = ;
                int d = 0;
                string k = Console.ReadLine();
                if (k == null) break;
                for (int i = 0; i <= k.Length - 1; i++)
                {
                    if (k.Substring(i, 1) == ) d += 1;
                }
                if (d >= 2)
                {
                    if (k == null) break;
                    for (int i = 0; i <= k.Length - 1; i++)
                    {
                        if (k.Substring(i, 1) == ) d += 1;
                        if (d == 2 && k.Substring(i, 1) != ) a = a + k.Substring(i, 1);
                        if (d == 3 && k.Substring(i, 1) != ) b = b + k.Substring(i, 1);
                        if (d == 4 && k.Substring(i, 1) != ) c = c + k.Substring(i, 1);
                    }
                    int x = int.Parse(a) * int.Parse(a);
                    int y = int.Parse(b) * int.Parse(b);
                    int z = int.Parse(c) * int.Parse(c);
                    if (x + y == z || y + z == x || x + z == y)
                    {
                        Console.WriteLine();
                    }
                    else
                    {
                        Console.WriteLine();
                    }
                }
            }
        }
    }
}"
C#,"using System;
 
class p0003{
     
    static void Main(string[] args){
        int n;
        
        string[] s;
        int[] a = new int[3];
        
        
            n = int.Parse(Console.ReadLine());
            while (0 < n--)
            {
                s = (Console.ReadLine()).Split(' ');
                for (int i = 0; i < 3; ++i)
                {
                    a[i] = int.Parse(s[i]);
                    a[i] = a[i] * a[i];
                }
                Console.WriteLine(, ((a[0] == a[1] + a[2] || a[1] == a[0] + a[2] || a[2] == a[0] + a[1]) ?  : ));
            }
        
    }
     
}"
C#,"using System.Collections;
using System;
using System.Collections.Generic;
public class Sample4{
	public static void Main(){
		string line;
		List <string> stringList = new List<string> ();
		do {
			line = Console.ReadLine ();
			if (line == null || !canDo(line)){
				break;
			}
			stringList.Add (line);
		} while (line != null);
		foreach (var s in stringList) {
			string[] tempStr = s.Split (' ');
			double x = getX (int.Parse (tempStr [0]),
				int.Parse (tempStr [1]),
				int.Parse (tempStr [2]),
				int.Parse (tempStr [3]),
				int.Parse (tempStr [4]),
				int.Parse (tempStr [5]));
			double y = getY (int.Parse(tempStr[0]),
				int.Parse(tempStr[1]),
				int.Parse(tempStr[2]),
				x);
			Console.WriteLine (,x,y);
		}
	}
	public static double getX(int a, int b, int c, int d, int e, int f){
        double value1 = c*e - b*f;
        double value2 = a*e - d*b;
        
		double x = value1/value2;
		return Math.Round(x, 3, MidpointRounding.AwayFromZero);;
	}
	public static double getY (int a, int b, int c, double x){
		double y = (c - a * x) / b;
		return Math.Round(y, 3, MidpointRounding.AwayFromZero);;
	}
	public static bool canDo (string line){
		string[] tempStr = line.Split (' ');
			foreach (var t in tempStr) {
			if (int.Parse (t) < -1000 || int.Parse (t) > 1000) {
					return false;
				}
			}
		return true;
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
class Program {
    static string ReadLine() { return Console.ReadLine(); }
    static int ReadInt() { return int.Parse(ReadLine()); }
    static int[] ReadInts() { return ReadLine().Split().Select(int.Parse).ToArray(); }
    static string[] ReadStrings() { return ReadLine().Split(); }
    static float Scala(float a, float b, float c, float d) {
        return a * d - b * c;
    }
    
    
    static void Calc(float a, float b, float c, float d, float e, float f) {
        var nume = Scala(a, b, d, e);
        var xd = Scala(c, b, f, e);
        var yd = Scala(a, c, d, f);
        var x = xd / nume;
        var y = yd / nume;
        Console.WriteLine(, x, y);
    }
    static void Main() {
        string s;
        while ((s = ReadLine()) != null) {
            var xs = s.Split().Select(int.Parse).ToArray();
            Calc(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5]);
        }
    }
}"
C#,"using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
 
class Program
{
    static void Main()
    {
        string input;
        while((input = Console.ReadLine()) != null)
        {
            double[] nums = input.Split(' ')
                                .Select(val => double.Parse(val))
                                .ToArray();
            double x = 0.0, y = 0.0;
            if(nums[0] != 0 && nums[4] != 0)
            {
                double a0 = nums[0];
                for(int i = 0; i < 3; i++)
                {
                    nums[i] /= a0;
                }
                double d1 = nums[3];
                for (int i = 3; i < 6; i++)
                {
                    nums[i] -= d1 * nums[i - 3];
                }
                double e2 = nums[4];
                for (int i = 4; i < 6; i++)
                {
                    nums[i] /= e2;
                }
                y = nums[5];
                x = nums[2] - nums[1] * y;
                
            }
            else if(nums[0] == 0 && nums[1] != 0)
            {
                y = nums[2] / nums[1];
                x = (nums[5] - nums[3] * y) / nums[4];
            }
            else if(nums[3] != 0 && nums[4] == 0)
            {
                x = nums[5] / nums[3];
                y = (nums[2] - nums[0] * x) / nums[1];
            }
            else Console.WriteLine();
            x = Math.Round(1000.0 * x, MidpointRounding.AwayFromZero) / 1000.0;
            y = Math.Round(1000.0 * y, MidpointRounding.AwayFromZero) / 1000.0;
            Console.WriteLine(, x, y);
        }
    }
}"
C#,"using System;
class Program{
    static void Main(){
        int how_many = int.Parse(Console.ReadLine());
        for(int i=0;i<how_many;i++){
            string str = Console.ReadLine();
            string[] stArray = str.Split(' ');
            int[] intArray = new int[3];
            int j, k;
            for(j=0;j<3;j++){
                intArray[j] = int.Parse(stArray[j]);
            }
            
            int tmp;
            for(j=0;j<3;j++){
                for(k=j+1;k<3;k++){
                    if(intArray[k] > intArray[j]){
                        tmp = intArray[k];
                        intArray[k] = intArray[j];
                        intArray[j] = tmp;
                    }
                }
                
            }
            if(intArray[0] * intArray[0]  == intArray[1] * intArray[1] + intArray[2] * intArray[2]){
                Console.WriteLine();
            }else{
                Console.WriteLine();
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace AthleteProgramming
{
    class Program
    {
        static void Main()
        {
            while (true)
            {
                string str = Console.ReadLine();
                if (str == null)
                {
                    break;
                }
                float[] array = str.Split(' ').Select(float.Parse).ToArray();
                float[] array2 = new float[6];
                for (int i = 0; i < 3; i++)
                {
                    array2[i] = array[i] * array[3];
                }
                for(int i = 3; i < 6; i++)
                {
                    array2[i] = array[i] * array[0];
                }
                float y = (array2[2] - array2[5]) / (array2[1] - array2[4]);
                float x = (array[2] - array[1] * y)/array[0];
                Console.WriteLine(,x.ToString(),y.ToString());
            }
        }
       
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace _0000
{
    public class Program
    {
        public static void Main(string[] args)
        {
            for (int i = 1 ; i < 10 ; i++)
            {
                for (int j = 1 ; j < 10 ; j++)
                {
                    Console.WriteLine(,i,j,i*j);
                }
            }
        }
        static string ReadSt() { return Console.ReadLine(); }
        static int ReadInt() { return int.Parse(Console.ReadLine()); }
        static long ReadLong() { return long.Parse(Console.ReadLine()); }
        static double ReadDouble() { return double.Parse(Console.ReadLine()); }
        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }
        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }
        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }
        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }
        static string WriteAr(int[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(double[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
        static string WriteAr(long[] array, string sep = ) { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Pair = System.Collections.Generic.KeyValuePair<int, int>;
class Program
{
	public Program() { }
	static void Main(string[] args)
	{
		new Program().prog();
	}
	
	const int MOD = 1000000007;
	const int INF = int.MaxValue;
	const double EPS = 1e-7;
	
	void prog()
	{
		
		for (int i = 0; i < 9; i++)
		{
			for (int j = 0; j < 9; j++)
			{
				Console.WriteLine(,i+1,j+1,(i+1)*(j+1));
			}
		}
	}
}
class Scanner
{
	string[] s;
	int i;
	char[] cs = new char[] { ' ' };
	public Scanner()
	{
		s = new string[0];
		i = 0;
	}
	public string next()
	{
		if (i < s.Length) return s[i++];
		string st = Console.ReadLine();
		while (st == ) st = Console.ReadLine();
		s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);
		i = 0;
		return next();
	}
	public int nextInt()
	{
		return int.Parse(next());
	}
	public long nextLong()
	{
		return long.Parse(next());
	}
	public double nextDouble()
	{
		return double.Parse(next());
	}
}"
C#,"using System;
class clas{
    public static void Main(){
        int[] mountain = new int[10];
        int a, b, c, d = 0, e = 0, f = 0;
        string x;
        for (int i = 0; i < 10; i++){
            x = Console.ReadLine();
            mountain[i] = int.Parse(x);
        }
        a = mountain[0];
        b = mountain[1];
        c = mountain[2];
        for(int n = 3; n < 10; n++){
            if (a <= b && a <= c && a <= mountain[n]){
                a = mountain[n];
                continue;
            }
            if (b <= a && b <= c && b <= mountain[n]){
                b = mountain[n];
                continue;
            }
            if (c <= b && c <= a && c <= mountain[n]){
                c = mountain[n];
                continue;
            }
        }
        if (a <= b && a <= c ){
            f = a;
            if (b <= c){
                e = b;
                d = c;
            }else{
                e = c;
                d = b;
            }
        }
        if (b <= a && b <= c ){
            f = b;
            if (a <= c)
            {
                e = a;
                d = c;
            }
            else
            {
                e = c;
                d = a;
            }
        }
        if (c <= b && c <= a ){
            f = c;
            if (b <= a)
            {
                e = b;
                d = a;
            }
            else
            {
                e = a;
                d = b;
            }
        }
        Console.WriteLine(d);
        Console.WriteLine(e);
        Console.WriteLine(f);
    }
}"
C#,"using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
public class Program
{
    public void Proc()
    {
        System.Text.StringBuilder ans = new System.Text.StringBuilder();
        while(true) {
            string inpt = Reader.ReadLine();
            if(inpt == null) {
                break;
            }
            ans.AppendLine(inpt.Split(' ').Select(a=>int.Parse(a)).Sum().ToString().Length.ToString());
        }
        Console.Write(ans.ToString());
        
    }
    public class Reader
	{
		private static StringReader sr;
		public static bool IsDebug = false;
		public static string ReadLine()
		{
			if (IsDebug)
			{
				if (sr == null)
				{
					sr = new StringReader(InputText.Trim());
				}
				return sr.ReadLine();
			}
			else
			{
				return Console.ReadLine();
			}
		}
		private static string InputText = @""
5 7
1 99
1000 999
"";
	}
	public static void Main(string[] args)
	{
#if DEBUG
		Reader.IsDebug = true;
#endif
		Program prg = new Program();
		prg.Proc();
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Diagnostics;
namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 0;
            int b = 0;
            int c = 0;
            for (int i = 0; i < 10; i++)
            {
                int h = int.Parse(Console.ReadLine());
                if (h > c)
                {
                    if (h > b)
                    {
                        if (h > a)
                        {
                            int tmp1 = a;
                            int tmp2 = b;
                            a = h;
                            b = tmp1;
                            c = tmp2;
                        }
                        else
                        {
                            int tmp = b;
                            b = h;
                            c = tmp;
                        }
                    }
                    else
                    {
                        c = h;
                    }
                }
            }
            Console.WriteLine(a);
            Console.WriteLine(b);
            Console.WriteLine(c);
        }
    }
        
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Contest
{
    class Program
    {
        static int Main(string[] args)
        {
            new Program().Process();
            return 0;
        }
        private CommonInput cin;
        private void Process()
        {
            this.cin = new CommonInput();
            List<int> h = new List<int>();
            for (int i = 0; i < 10; i++)
                h.Add(cin.GetInt());
            h = h.OrderByDescending(x => x).ToList();
            for (int i = 0; i < 3; i++)
                Console.WriteLine(h[i]);
        }
    }
    public class CommonInput
    {
        public CommonInput()
        {
            this._s = new string[0];
            this._i = 0;
        }
        private string[] _s;
        private int _i;
        private char[] _sep = { ' ' };
        public string GetLine()
        {
            if (this._i < this._s.Length)
                return this._s[this._i++];
            string line;
            this._i = 0;
            do
            {
                line = Console.ReadLine();
            } while (line == );
            this._s = line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);
            return this._s[this._i++];
        }
        public int GetInt()
        {
            return int.Parse(this.GetLine());
        }
        public long GetLong()
        {
            return long.Parse(this.GetLine());
        }
        public double GetDouble()
        {
            return double.Parse(this.GetLine());
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace aoj
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string a = ;
                string b = ;
                string c = ;
                int d = 0;
                string k = Console.ReadLine();
                if (k == null) break;
                for (int i = 0; i <= k.Length - 1; i++)
                {
                    if (k.Substring(i, 1) == ) d += 1;
                }
                if (d >= 2)
                {
                    if (k == null) break;
                    for (int i = 0; i <= k.Length - 1; i++)
                    {
                        if (k.Substring(i, 1) == ) d += 1;
                        if (d == 2 && k.Substring(i, 1) != ) a = a + k.Substring(i, 1);
                        if (d == 3 && k.Substring(i, 1) != ) b = b + k.Substring(i, 1);
                        if (d == 4 && k.Substring(i, 1) != ) c = c + k.Substring(i, 1);
                    }
                    int x = int.Parse(a) * int.Parse(a);
                    int y = int.Parse(b) * int.Parse(b);
                    int z = int.Parse(c) * int.Parse(c);
                    if (x + y == z || y + z == x || x + z == y)
                    {
                        Console.WriteLine();
                    }
                    else
                    {
                        Console.WriteLine();
                    }
                }
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Contest
{
    class Program
    {
        static int Main(string[] args)
        {
            new Program().Process();
            return 0;
        }
        private CommonInput cin;
        private void Process()
        {
            this.cin = new CommonInput();
            int N, count;
            List<int> l = new List<int>();
            N = cin.GetInt();
            count = 0;
            while (count < N)
            {
                l.Clear();
                for (int i = 0; i < 3; i++)
                    l.Add(cin.GetInt());
                l = l.OrderByDescending(x => x).ToList();
                Console.WriteLine(, l[0] * l[0] == l[1] * l[1] + l[2] * l[2] ?  : );
                count++;
            }
        }
    }
    public class CommonInput
    {
        public CommonInput()
        {
            this._s = new string[0];
            this._i = 0;
        }
        private string[] _s;
        private int _i;
        private char[] _sep = { ' ' };
        public string GetLine()
        {
            if (this._i < this._s.Length)
                return this._s[this._i++];
            string line;
            this._i = 0;
            do
            {
                line = Console.ReadLine();
            } while (line == );
            this._s = line.Split(this._sep, StringSplitOptions.RemoveEmptyEntries);
            return this._s[this._i++];
        }
        public int GetInt()
        {
            return int.Parse(this.GetLine());
        }
        public long GetLong()
        {
            return long.Parse(this.GetLine());
        }
        public double GetDouble()
        {
            return double.Parse(this.GetLine());
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
namespace Problem0003
{
    class Program
    {
        static void Main(string[] args)
        {
            var triples =
                GetInputLines()
                .Skip(1)
                .Select(line => line.Split().Select(word => int.Parse(word)).ToArray());
            foreach (int[] triple in triples)
            {
                if (IsRightTriangle(triple))
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
        }
        static IEnumerable<string> GetInputLines()
        {
            string line;
            while (!string.IsNullOrEmpty(line = System.Console.ReadLine()))
            {
                yield return line;
            }
        }
        static bool IsRightTriangle(int[] triple)
        {
            int[] sortedTriple = triple.OrderBy(n => n).ToArray();
            int a = sortedTriple[0], b = sortedTriple[1], c = sortedTriple[2];
            return a * a + b * b == c * c;
        }
    }
}"
C#,"using System;
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string a = Console.ReadLine();
                    if (a == null)
                        break;
                string[] aa = a.Split();
                int data1 = int.Parse(aa[0]);
                int data2 = int.Parse(aa[1]);
                int data0 = data1 + data2;
                int count = 1;
                while (true)
                {
                    data0 /= 10;
                    if (data0 != 0)
                        count++;
                    else
                        break;
                }
                Console.WriteLine(count);
            }
            Console.ReadLine();
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        }
    }
}"
C#,"using System;
class three
{
    static void Main()
    {
        string a = Console.ReadLine();
        int b = int.Parse(a);
        bool[] c = new bool[b];
        for (int i = 0; i < b; i++)
        {
            string d = Console.ReadLine();
            string[] e = d.Split(' ');
            int[] f = new int[3];
            for(int j = 0; j < 3; j++)
            {
                f[j]=int.Parse(e[j]);
            }
            if (f[0] > f[1])
            {
                int w = f[0];
                f[0] = f[1];
                f[1] = w;
            }
             if (f[1] > f[2])
            {
                int w = f[1];
                f[1] = f[2];
                f[2] = w;
            }
            if (f[0] > f[2])
            {
                int w = f[0];
                f[0] = f[2];
                f[2] = w;
            }
            if (f[0] > f[1])
            {
                int w = f[0];
                f[0] = f[1];
                f[1] = w;
            }
            if (f[1] > f[2])
            {
                int w = f[1];
                f[1] = f[2];
                f[2] = w;
            }
            if (f[0] * f[0] + f[1] * f[1] == f[2] * f[2])
            {
                c[i] = true;
            }
            
        }
        for (int k = 0; k < b; k++)
            {
                if (c[k])
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
class Procon {
    static void Main (string[] agrs) {
        for (int i = 1; i<= 9; i++) {
            for (int j = 1; j <= 9; j++) {
                Console.WriteLine(, i, j, i*j);
            }
        }
    }
    static string String () => Scanner.nextString ();
    static int Int () => int.Parse (Scanner.nextString ());
    static long Long () => long.Parse (Scanner.nextString ());
    static double Double () => double.Parse (Scanner.nextString ());
    static char[] Chars () => String ().ToCharArray ();
    static string[] Strings () => Console.ReadLine ().Split (' ');
    static int[] Ints () => Strings ().Select (v => int.Parse (v)).ToArray ();
    static long[] Longs () => Strings ().Select (v => long.Parse (v)).ToArray ();
    static double[] Doubles () => Strings ().Select (v => double.Parse (v)).ToArray ();
    const int M = 1000000007;
}
class PriorityQueue<T> where T : IComparable<T> {
    public T[] heap;
    public int size;
    public int sign;
    public PriorityQueue (int N, bool descend = false) {
        heap = new T[N];
        sign = 1;
        if (descend) sign = -1;
    }
    public int Compare (T x, T y) {
        return x.CompareTo (y) * sign;
    }
    public void Push (T x) {
        int i = size++;
        while (i > 0) {
            int p = (i - 1) / 2;
            if (Compare (x, heap[p]) >= 0) {
                break;
            }
            heap[i] = heap[p];
            i = p;
        }
        heap[i] = x;
    }
    public T Pop () {
        T ret = heap[0];
        T x = heap[--size];
        int i = 0;
        while (i * 2 + 1 < size) {
            int a = i * 2 + 1;
            int b = i * 2 + 2;
            if (b < size && Compare (heap[a], heap[b]) > 0) {
                a = b;
            }
            if (Compare (heap[a], x) >= 0) {
                break;
            }
            heap[i] = heap[a];
            i = a;
        }
        heap[i] = x;
        return ret;
    }
    public int Count () {
        return size;
    }
}
class Scanner {
    static string[] s = new string[0];
    static int i = 0;
    static int max_i = 0;
    static public string nextString () {
        if (i >= s.Length) {
            s = Console.ReadLine ().Split (' ');
            max_i = s.Length;
            i = 0;
            if (max_i == 0) {
                return ;
            }
            return s[i++];
        }
        return s[i++];
    }
}"
C#,"using System;
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string input = Console.ReadLine();
                if (input == null)
                    break;
                string[] split = input.Split();
                double a = double.Parse(split[0]);
                double b = double.Parse(split[1]);
                double c = double.Parse(split[2]);
                double d = double.Parse(split[3]);
                double e = double.Parse(split[4]);
                double f = double.Parse(split[5]);
                
                
                
                
                
                
                
                
                
                
                double y = (d * c - f * a) / (d * b - a * e);
                double x = (c - b * y) / a;
                string ans = x.ToString() +  + y.ToString();
                Console.WriteLine(ans);
            }
            Console.ReadLine();
        }
    }
}"
C#,"using System;
class yama
{
    static void Main()
    {
        int[]a = new int[10];
        int[] b = new int[3];
        for(int i = 0; i < 10; i++)
        {
            a[i] = int.Parse(Console.ReadLine());
            for(int j = 0; j < 3; j++)
            {
                if (b[j] <= a[i])
                {
                    if (j == 0)
                    {
                        b[j +2] = b[j + 1];
                        b[j + 1] = b[j];
                        b[j] = a[i];
                        goto stop;
                    }
                    if (j == 1)
                    {
                        b[j + 1] = b[j];
                        b[j] = a[i];
                        goto stop;
                    }
                    if (j == 2)
                    {
                        b[j] = a[i];
                        goto stop;
                    }
                    
                }
                
            }
            stop:;
        }
        for(int i = 0; i < 3; i++)
        {
            Console.WriteLine(b[i]);
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Study0001
{
    class Program
    {
        static void Main(string[] args)
        {
            int inputNum = int.Parse(Console.ReadLine());
            var inputs = new List<string>();
            for (int i = 0; i < inputNum; i++)
            {
                inputs.Add(Console.ReadLine());
            }
            foreach (var input in inputs)
            {
                var parts = input.Split(' ');
                int a = int.Parse(parts[0]);
                int b = int.Parse(parts[1]);
                int c = int.Parse(parts[2]);
                bool ischeck = false;
                if (a >= b && a >= c)
                {
                    ischeck = a * a == b * b + c * c;
                }
                else if (b >= c && b >= a)
                {
                    ischeck = b * b == a * a + c * c;
                }
                else if (c >= a && c >= b)
                {
                    ischeck = c * c == a * a + b * b;
                }
                if (ischeck)
                {
                    Console.WriteLine();
                }
                else
                {
                    Console.WriteLine();
                }
            }
            
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace contest
{
    class Program
    {
        static int Main(string[] args)
        {
                string read = Console.ReadLine();
                int dataset_num = int.Parse(read);
                int[] num_array = new int[3];
                for (int i = 0; i < dataset_num; i++)
                {
                    
                    var input_line = Console.ReadLine();
                    
                    var line = input_line.Split();
                    int count = 0;
                    foreach (var num in line)
                    {
                        
                        num_array[count++] = int.Parse(num);
                    }
                    
                    
                    Array.Sort(num_array);
                    if (num_array[2] * num_array[2] == (num_array[0] * num_array[0] + num_array[1] * num_array[1]))
                    {
                        Console.WriteLine();
                    }
                    else
                    {
                        Console.WriteLine();
                    }
                }
                return 0;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace a
{
    class Program
    {
        static void Main()
        {
            string line;
            while ((line = Console.ReadLine()) != null)
            {
                var ab = line.Split().Select(int.Parse).ToArray();
                int a = ab[0];
                int b = ab[1];
                if ((a + b) / 1000000 >= 1)
                    Console.WriteLine();
                else if ((a + b) / 100000 >= 1)
                    Console.WriteLine();
                else if ((a + b) / 10000 >= 1)
                    Console.WriteLine();
                else if ((a + b) / 1000 >= 1)
                    Console.WriteLine();
                else if ((a + b) / 100 >= 1)
                    Console.WriteLine();
                else if ((a + b) / 10 >= 1)
                    Console.WriteLine();
                else if ((a + b) / 1 >= 1)
                    Console.WriteLine();
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Text;
namespace contest
{
    class Program
    {       
        static int Main(string[] args)
        {
                string read = Console.ReadLine();
                int dataset_num = int.Parse(read);
                for (int i = 0; i < dataset_num; i++)
                {
                    
                    var line = Console.ReadLine().Split();
                    
                    var num_array =  Array.ConvertAll(line, len => int.Parse(len));
                    
                    Array.Sort(num_array);
                    if (num_array[2] * num_array[2] == (num_array[0] * num_array[0] + num_array[1] * num_array[1]))
                    {
                        Console.WriteLine();
                    }
                    else
                    {
                        Console.WriteLine();
                    }
                }
                return 0;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Pair = System.Collections.Generic.KeyValuePair<int, int>;
class Program
{
	public Program() { }
	static void Main(string[] args)
	{
		new Program().prog();
	}
	
	const int MOD = 1000000007;
	const int INF = int.MaxValue;
	const double EPS = 1e-7;
	
	void prog()
	{
		
		string str;
		while (!string.IsNullOrEmpty(str = Console.ReadLine()))
		{
			string[] s = str.Split(' ');
			Console.WriteLine((int.Parse(s[0])+int.Parse(s[1])).ToString().Length);
		}
	}
}
class Scanner
{
	string[] s;
	int i;
	char[] cs = new char[] { ' ' };
	public Scanner()
	{
		s = new string[0];
		i = 0;
	}
	public string next()
	{
		if (i < s.Length) return s[i++];
		string st = Console.ReadLine();
		while (st == ) st = Console.ReadLine();
		s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);
		i = 0;
		return next();
	}
	public int nextInt()
	{
		return int.Parse(next());
	}
	public long nextLong()
	{
		return long.Parse(next());
	}
	public double nextDouble()
	{
		return double.Parse(next());
	}
}"
C#,"using System;
 
public class p0003{
     
    public static void Main(string[] args){
        int n;
        string str;
        string[] s;
        int[] a = new int[3];
        while ((str = Console.ReadLine()) != null)
        {
            n = int.Parse(str);
            while (0 < n--)
            {
                s = (Console.ReadLine()).Split(' ');
                for (int i = 0; i < 3; ++i)
                {
                    a[i] = int.Parse(s[i]);
                    a[i] = a[i] * a[i];
                }
                Console.WriteLine(, ((a[0] == a[1] + a[2] || a[1] == a[0] + a[2] || a[2] == a[0] + a[1]) ?  : ));
            }
        }
    }
     
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Diagnostics;
namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
            int n = int.Parse(Console.ReadLine());
            List<string> list = new List<string>();
            for (int i = 0; i < n; i++)
            {
                string[] s = Console.ReadLine().Split(' ');
                List<int> triangle = new List<int>();
                foreach (string st in s)
                {
                    triangle.Add(int.Parse(st));
                }
                triangle.Sort();
                list.Add(JudgeTriangle(triangle));
            }
            foreach (string s in list)
            {
                Console.WriteLine(s);
            }
        }
        static string JudgeTriangle(List<int> l)
        {
            if (l[2] * l[2] == l[1] * l[1] + l[0] * l[0])
            {
                return ;
            }
            else
            {
                return ;
            }
        }
    }
        
}"
C#,"using System;
using System.Collections.Generic;
class UNKO
{
    
    static void Main()
    {
        string str;
        List<double> Answers = new List<double>();
        int count = 0;
        while ((str = Console.ReadLine()) != null)
        {
            string[] strarray = str.Split(' ');
            double[] abcdef = new double[6];
            for (int i=0;i<6;i++)
            {
                abcdef[i] = double.Parse(strarray[i]);
            }
           
                    double x = ((abcdef[4] * abcdef[2]) - (abcdef[1] * abcdef[5])) / ((abcdef[4] * abcdef[0]) - (abcdef[1] * abcdef[3]));
                    double y = ((abcdef[3] * abcdef[2]) - (abcdef[0] * abcdef[5])) / ((abcdef[1] * abcdef[3]) - (abcdef[0] * abcdef[4]));
     
            Answers.Add(x);
            Answers.Add(y);
            count++;   
        }
        for (int i=0; i< count;i++)
        {
            Console.WriteLine(, (Answers[2 * i]).ToString(), (Answers[1 + (2 * i)]).ToString());
        }
    }
}"
Rust,"fn main(){
  let n: u32 = read();
  for _ in 0 .. n {
    let mut v: Vec<Vec<usize>> = Vec::new();
    
    v.push(vec![0; 10]);
    
    for _ in 0 .. 10 {
      v.push(read_vec());
    }
    for i in 0 .. 1024 {
      let mut cv = v.clone();
      for j in 0 .. 10 {
        if i & (1 << j) > 0 {
          cv[0][j] = 1;
        } else {
          cv[0][j] = 0;
        }
      }
      match pass(&mut cv) {
        Some(ans) => {print_vec(&ans); break;},
        None => {},
      }
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn print_vec(v: &Vec<Vec<usize>>) -> (){
  let l = v[0].len();
  for x in v {
    for i in 0 .. l {
      if i == l - 1 {
        println!(, x[i]);
      } else {
        print!(, x[i]);
      }
    }
  }
}
fn pass(v: &mut Vec<Vec<usize>>) -> Option<Vec<Vec<usize>>> {
  let mut ans: Vec<Vec<usize>> = vec![vec![0; 10]; 10];
  let dv: Vec<(isize, isize)> = vec![(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)];
  
  for i in 1 .. 11 {
    for j in 0 .. 10 {
      if v[i-1][j] == 1 {
        ans[i-1][j] = 1;
        for &(di, dj) in &dv {
          let ni = i as isize + di;
          let nj = j as isize + dj;
          if ni >= 0 && ni <= 10 && nj >= 0 && nj <= 9 {
            v[ni as usize][nj as usize] = 1 - v[ni as usize][nj as usize];
          }
        }
      }
    }
  }
  
  if v[10] == vec![0; 10] {
    Some(ans)
  } else {
    None
  }
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::f32::MAX;
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::Display;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    loop {
        let_mut_all!(n: i32);
        if n == -1 {return}
        if n == 0 {
            println!();
            continue
        }
        let mut digits: Vec<i32> = Vec::new();
        while n != 0 {
            digits.push(n % 4);
            n /= 4;
        }
        println!(, digits.iter().map(|x| x.to_string()).rev().collect::<Vec<_>>().connect());
    }
}"
Rust,"use std::cmp;
use std::collections::VecDeque;
fn main(){
  loop {
    let n: usize = read();
    if n == 0 { break; }
    let mut wll: Vec<Vec<usize>> = Vec::new();
    wll.push(read_vec());
    wll.push(read_vec());
    
    let mut jmp: Vec<Vec<usize>> = vec![vec![10000;n];2];
    jmp[0][0] = 0;
    jmp[1][0] = 0;
    let mut que: VecDeque<(usize, usize)> = VecDeque::new();
    que.push_back((0, 0));
    que.push_back((1, 0));
    loop {
      match que.pop_front() {
        Some((p, i)) => {
          if i < n - 1 && wll[p][i] == 1 && wll[p][i+1] == 1 {
            if jmp[p][i] < jmp[p][i+1] {
              jmp[p][i+1] = jmp[p][i];
              que.push_back((p, i+1));
            }
          } else if wll[p][i] == 2 {
            if jmp[p][i] < jmp[p][i-1] {
              jmp[p][i-1] = jmp[p][i];
              que.push_back((p, i-1));
            }
          } else {
            if jmp[p][i] + 1 < jmp[1-p][i] {
              jmp[1-p][i] = jmp[p][i] + 1;
              que.push_back((1-p, i));
            }
            if i+1 < n && jmp[p][i] + 1 < jmp[1-p][i+1] {
              jmp[1-p][i+1] = jmp[p][i] + 1;
              que.push_back((1-p, i+1));
            }
            if i+2 < n && jmp[p][i] + 1 < jmp[1-p][i+2] {
              jmp[1-p][i+2] = jmp[p][i] + 1;
              que.push_back((1-p, i+2));
            }
          }
        },
        None => {
          if wll[0][n-1] == 2 && wll[1][n-1] == 2 ||
             wll[0][n-1] == 2 && jmp[1][n-1] == 10000 ||
             jmp[0][n-1] == 10000 && wll[1][n-1] == 2 ||
             jmp[0][n-1] == 10000 && jmp[1][n-1] == 10000 {
               println!();
             } else {
               println!(, cmp::min(jmp[0][n-1], jmp[1][n-1]));
             }
          break;
        },
      }
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"#![allow(unused_imports, unused_variables, dead_code, non_snake_case, unused_macros)]
use std::io::{stdin, Read, StdinLock};
use std::str::FromStr;
use std::fmt::*;
use std::str::*;
use std::cmp::*;
use std::collections::*;
fn getline() -> String{
    let mut res = String::new();
    std::io::stdin().read_line(&mut res).ok();
    res
}
macro_rules! readl {
    ($t: ty) => {
        {
            let s = getline();
            s.trim().parse::<$t>().unwrap()
        }
    };
    ($( $t: ty),+ ) => {
        {
            let s = getline();
            let mut iter = s.trim().split(' ');
            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) 
        }
    };
}
macro_rules! readlvec {
    ($t: ty) => {
        {
            let s = getline();
            let iter = s.trim().split(' ');
            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()
        }
    }
}
macro_rules! mvec {
    ($v: expr, $s: expr) => {
        vec![$v; $s]
    };
    ($v: expr, $s: expr, $($t: expr),*) => {
        vec![mvec!($v, $($t),*); $s]
    };
}
macro_rules! debug {
    ($x: expr) => {
        println!(, stringify!($x), $x)
    }
}
fn printiter<'a, T>(v: &'a T)
where
    &'a T: std::iter::IntoIterator, 
    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {
    for (i,e) in v.into_iter().enumerate() {
        if i != 0 {
            print!();
        }
        print!(, e);
    }
    println!();
}
struct ContestPrinter {
    s: String,
}
impl ContestPrinter {
    fn new() -> ContestPrinter {
        ContestPrinter {
        s: String::new(),
        }
    }
    fn print<T>(&mut self, x: T)
        where T: std::fmt::Display {
        self.s.push_str(format!(, x).as_str());
    }
    fn println<T>(&mut self, x: T)
        where T: std::fmt::Display {
        self.s.push_str(format!(, x).as_str());
    }
}
impl std::ops::Drop for ContestPrinter {
    fn drop(&mut self) {
        print!(, self.s);
    }
}
fn is_max_i64(num: i64) -> bool { if num == i64::max_value() { true } else { false } }
fn is_prime(n: i64) -> bool {
    let mut i = 2;
    loop {
        if (n % i) == 0 {return false; }
        i += 1;
        if (i*i) > n { break; }
    }
    return true;
}
fn prime_list(n: usize) -> Vec<usize> {
    let mut ret: Vec<usize> = Vec::new();
    let num = n - 1;
    let mut table: Vec<bool> = vec![false; num];
    for i in 0..num {
        if !table[i] {
            let next = i + 2;
            ret.push(next);
            let mut j = i + next;
            while j < num {
                table[j] = true;
                j += next;
            }
        }
    }
    ret
} 
fn prime_factorization(n: usize) -> Vec<(usize, usize)> {
    let mut ret: Vec<(usize, usize)> = Vec::new();
    let pl = prime_list((n as f64).sqrt() as usize + 1);
    let mut num = n;
    for p in pl { 
        let mut cnt = 0;
        while (num % p) == 0 {
            num /= p;
            cnt += 1;
        }
        if cnt > 0 { ret.push((p, cnt)); }
    }
    if ret.is_empty() { vec![(n, 1); 1] }
    else { ret }
} 
fn main() {
    let cin = stdin();
    let cin = cin.lock();
    let mut sc = Scanner::new(cin);
    
    let size = 999999;
    let ps = prime_list(size);
    let mut num: Vec<usize> = vec![0; size+1];
    let mut idx: usize = 0;
    
    for i in 2..size+1 {
        num[i] = num[i-1];
        if idx >= ps.len() { continue; }
        if ps[idx] == i {
            num[i] += 1;
            idx += 1;
        }
    }
    let mut input: Option<usize> = sc.read1();
    while let Some(n) = input {
        println!(, num[n]);
        input = sc.read1();
    }
}
struct Scanner<'a> {
    cin: StdinLock<'a>,
}
 
impl<'a> Scanner<'a> {
    fn new(cin: StdinLock<'a>) -> Scanner<'a> {
        Scanner { cin: cin }
    }
 
    fn read1<T: FromStr>(&mut self) -> Option<T> {
        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)
            .skip_while(|c| c.is_whitespace())
            .take_while(|c| !c.is_whitespace())
            .collect::<String>();
        token.parse::<T>().ok()
    }
 
    fn read<T: FromStr>(&mut self) -> T {
        self.read1().unwrap()
    }
}"
Rust,"use std::collections::VecDeque;
fn main(){
  loop {
    let nm: Vec<usize> = read_vec();
    let n = nm[0];
    let m = nm[1];
    if n == 0 && m == 0 { break; }
    let mut mp: Vec<Vec<char>> = vec![vec!['.'; n+2]; m+2];
    let mut dv: Vec<Vec<usize>> = vec![vec![10000; n+2]; m+2];
    
    let mut si: usize = 0;
    let mut sj: usize = 0;
    
    for i in 1 .. m+1 {
      let ts: String = read();
      let tl: Vec<char> = ts.chars().collect();
      for j in 1 .. n+1 {
        mp[i][j] = tl[j-1];
        if mp[i][j] == '&' { si = i; sj = j; }
      }
    }
    
    dv[si][sj] = 0;
    
    let mut que: VecDeque<(usize, usize)> = VecDeque::new();
    que.push_back((si, sj));
    
    let d: Vec<(isize, isize)> = vec![(1,0),(-1, 0), (0, 1), (0, -1)];
    
    loop {
      match que.pop_front() {
        None => { break; },
        Some((i, j)) => {
          for &(di, dj) in &d {
            let ti = (i as isize) + di;
            let tj = (j as isize) + dj;
            if ti < 0 || tj < 0 || ti > (m as isize)+1 || tj > (n as isize)+1 { continue; }
            let ni: usize = ti as usize;
            let nj: usize = tj as usize;
            let tc: usize =  dv[i][j] + if mp[i][j] != '#' && mp[ni][nj] == '#' {1} else {0};
            if tc < dv[ni][nj] {
              dv[ni][nj] = tc;
              que.push_back((ni, nj));
            }
          }
        },
      }
    }
    println!(, dv[0][0]);
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"fn main() {
        let n = readln();
        let mut c:f64= 100000.0;
        for _i in 0..n {
            c=c+c*0.05;
            if c%1000.0!=0.0{
                c=(((c/1000.0) as i32) as f64)*1000.0+1000.0;
            }
        }
        println!(,c);
}
     
    
    #[allow(unused_imports)]
    use std::cmp::{max, min};
    #[allow(unused_imports)]
    use std::collections::{HashMap, HashSet, VecDeque};
     
    pub trait FromLn {
        fn fromln(s: &str) -> Self;
    }
    pub fn readln<T: FromLn>() -> T {
        let mut buf = String::new();
        let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
        T::fromln(buf.trim())
    }
    pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
        let mut vs = vec![];
        for _ in 0..n {
            vs.push(readln());
        }
        vs
    }
    macro_rules! fromln_primitives {
        ($($t:ty),*) => { $(
            impl FromLn for $t {
                fn fromln(s: &str) -> $t {
                    s.parse().unwrap()
                }
            }
        )* }
    }
    fromln_primitives!(
        String,
        bool,
        f32,
        f64,
        isize,
        i8,
        i16,
        i32,
        i64,
        usize,
        u8,
        u16,
        u32,
        u64
    );
    impl<T> FromLn for Vec<T>
    where
        T: FromLn,
    {
        fn fromln(s: &str) -> Vec<T> {
            s.split_whitespace().map(T::fromln).collect()
        }
    }
    impl FromLn for Vec<char> {
        fn fromln(s: &str) -> Vec<char> {
            s.chars().collect()
        }
    }
    macro_rules! fromln_tuple {
        ($($t:ident),*) => {
            impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
                fn fromln(s: &str) -> ($($t),*) {
                    let mut it = s.split_whitespace();
                    let t = ($($t::fromln(it.next().unwrap())),*);
                    assert_eq!(it.next(), None);
                    t
                }
            }
        }
    }
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"use std::cmp;
fn main(){
  loop {
    let nm: Vec<usize> = read_vec();
    let n = nm[0];
    let m = nm[1] as u32;
    if n == 0 && m == 0 { break; }
    
    let mut d: Vec<u32> = vec![0];
  
    for _ in 0 .. n {
      d.push(read());
    }
    let mut d2: Vec<u32> = Vec::new();
    
    for i in 0 .. n+1 {
      for j in 0 .. n+1 {
        let t = d[i] + d[j];
        if t <= m {
          d2.push(t);
        }
      }
    }
    d2.sort();
    let mut ans: u32 = 0;
    
    for i in 0 .. d2.len() {
      let t = bsearch(&d2, m-d2[i]);
      ans = cmp::max(ans, t + d2[i]);
    }
    
    println!(, ans);
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn bsearch(v: &Vec<u32>, x: u32) -> u32 {
  let mut l: usize = 0;
  let mut r: usize = v.len();
  
  loop {
    if l + 1 == r { break; }
    let m = (l + r) / 2;
    if v[m] <= x {
      l = m;
    } else {
      r = m;
    }
  }
  v[l]
}"
Rust,"extern crate core;
use std::fmt;
use std::i32::{MAX};
use std::cmp::{Ordering, min, max };
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::{Display, Formatter, Error};
use std::collections::hash_map::Values;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_lines{
    ($count: expr; $delimiter: expr; $ty: ty) => {{
        let line_count = $count;
        let mut vec: Vec<Vec<$ty>> = Vec::with_capacity(line_count);
        for _ in 0 .. line_count {
            vec.push(read_line!($delimiter; $ty));
        }
        vec
    }};
    ($count: expr; $ty: ty) => {{
        let line_count = $count;
        let mut vec: Vec<$ty> = Vec::with_capacity(line_count);
        for _ in 0 .. line_count {
            vec.push(read_value!());
        }
        vec
    }}
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn find_first_true<F>(mut from: usize, mut until: usize, predicate: F) -> usize where F: Fn(usize) -> bool {
    while from < until {
        let mid = (from + until) / 2;
        if predicate(mid){
            until = mid;
        }
        else {
            from = mid + 1;
        }
    }
    until
}
trait SortedVec<Value> {
    fn lower_bound(&self, value: Value) -> usize;
    fn upper_bound(&self, value: Value) -> usize;
}
impl <T> SortedVec<T> for Vec<T> where T: Ord {
    fn lower_bound(&self, value: T) -> usize {
        let mut left = 0;
        let mut right = self.len();
        while left < right {
            let mid = (left + right) / 2;
            if self[mid] < value {
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        right
    }
    fn upper_bound(&self, value: T) -> usize {
        let mut left = 0;
        let mut right = self.len();
        while left < right {
            let mid = (left + right) / 2;
            if self[mid] <= value {
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        right
    }
}
fn main(){
    loop {
        let_all!(m: usize, n: usize); if n == 0 {break}
        let books = read_lines!(n; usize);
        let mut width_sum = Vec::with_capacity(n + 1); width_sum.push(0usize);
        for b in books { width_sum.push(b) }
        for i in 1 .. width_sum.len() { width_sum[i] += width_sum[i - 1]; }
        let width_sum = width_sum;
        println!(, find_first_true(1, 1500000, |w| -> bool {
            let mut current = 0;
            for c in 0 .. m {
                current = width_sum.upper_bound(width_sum[current] + w) - 1;
            }
            return current == n;
        }))
    }
}"
Rust,"use std::io::{stdin, BufRead, BufReader};
fn gcd(x: i64,y:i64)-> i64{
    if y==0{
       return x;
    }
    return gcd(y,x%y);
}
fn lcm(x: i64,y:i64) ->i64{
    if x==0 || y==0{
        return 0;
    }
    return x*y/gcd(x,y);
}
fn main(){
    let input = BufReader::new(stdin());
    for line in input.lines(){
        
        let v: Vec<i64> = line.unwrap().split_whitespace().filter_map(|x| x.parse::<i64>().ok()).collect();
        println!(,gcd(v[0],v[1]),lcm(v[0],v[1]));
            
    }
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::fmt::{Display, Error, Formatter};
use std::collections::{VecDeque, BinaryHeap, BTreeMap};
use std::f32::MAX;
use std::ops::{Add, Sub};
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn clockwise_first(origin: Point, points: &Vec<Point>) -> Option<usize> {
    if !points.is_empty() {
        let mut suspect = 0;
        for i in 1 .. points.len() {
            if (points[suspect] - origin).cross(&(points[i] - origin)) > 0_f64 {
                suspect = i;
            }
        }
        Some(suspect)
    }else {
        None
    }
}
fn clockwise_last(origin: Point, points: &Vec<Point>) -> Option<usize> {
    if !points.is_empty() {
        let mut suspect = 0;
        for i in 1 .. points.len() {
            if (points[suspect] - origin).cross(&(points[i] - origin)) < 0_f64  {
                suspect = i;
            }
        }
        Some(suspect)
    }else {
        None
    }
}
fn min_f64(a: f64, b: f64) -> f64 {
    match a.partial_cmp(&b) {
        Some(Ordering::Greater) => b,
        Some(_) => a,
        None => {unimplemented!()}
    }
}
fn min_distance_on_edge(start: Point, goal: Point, edge: Edge) -> f64 {
    let line = Line::by_two_points(&edge.from, &edge.to);
    let symmetry_goal = line.line_symmetry_point(&goal);
    let default = min_f64(start.distance(&edge.from) + goal.distance(&edge.from), start.distance(&edge.to) + goal.distance(&edge.to));
    if let Some(cp) = Line::by_two_points(&start, &symmetry_goal).cross_point(&line) {
        if (edge.from - start).cross(&(cp - start)) <= 0_f64 && (edge.to - start).cross(&(cp - start)) >= 0_f64 {
            min_f64(default, start.distance(&cp) + goal.distance(&cp))
        }else {
            default
        }
    }else {
        default
    }
}
fn main() {
    let_all!(from_x: f64, from_y: f64);
    let_all!(to_x: f64, to_y: f64);
    let start = Point{x: from_x, y: from_y};
    let goal = Point{x: to_x, y: to_y};
    let_all!(n: usize);
    let mut points = Vec::with_capacity(n);
    for _ in 0 .. n {
        let_all!(x: f64, y: f64);
        points.push(Point{x: x, y: y});
    }
    let mut suspect = std::f64::MAX;
    match (clockwise_first(start, &points), clockwise_last(goal, &points)) {
        (Some(to), Some(from)) if (points[to] - start).cross(&(goal - start)) < 0_f64 => {
            let mut temp = start.distance(&points[to]) + goal.distance(&points[from]);
            for i in 0 .. (to + n - from) % n {
                temp += (points[(i + from) % n] - points[(i + from + 1) % n]).norm();
            }
            if suspect > temp {
                suspect = temp;
            }
        }
        (Some(from), Some(to)) if from != to => {
            let mut temp = 0_f64;
            for i in 0 .. (to + n - from) % n {
                temp = min_distance_on_edge(start, goal, Edge{from: points[(i + from) % n], to: points[(i + from + 1) % n]});
                if temp < suspect {
                    suspect = temp;
                }
            }
        }
        (Some(from), Some(to)) => {
            let temp = start.distance(&points[from]) + goal.distance(&points[to]);
            if suspect > temp {
                suspect = temp;
            }
        }
        _ => {}
    }
    match (clockwise_last(start, &points), clockwise_first(goal, &points)) {
        (Some(from), Some(to)) if (points[from] - start).cross(&(goal - start)) > 0_f64 => {
            let mut temp = start.distance(&points[from]) + goal.distance(&points[to]);
            for i in 0 .. (to + n - from) % n {
                temp += (points[(i + from) % n] - points[(i + from + 1) % n]).norm();
            }
            if suspect > temp {
                suspect = temp;
            }
        }
        (Some(to), Some(from)) if from != to => {
            let mut temp = 0_f64;
            for i in 0 .. (to + n - from) % n {
                temp = min_distance_on_edge(start, goal, Edge{from: points[(i + from) % n], to: points[(i + from + 1) % n]});
                if temp < suspect {
                    suspect = temp;
                }
            }
        }
        (Some(to), Some(from)) => {
            let temp = start.distance(&points[from]) + goal.distance(&points[to]);
            if suspect > temp {
                suspect = temp;
            }
        }
        _ => {}
    }
    println!(, 10, suspect);
}
#[derive(Copy, Clone)]
struct Edge{
    from: Point, to: Point
}
#[derive(Copy, Clone)]
struct Point {
    x: f64, y: f64,
}
impl Point {
    fn cross(&self, other: &Self) -> f64 {
        self.x * other.y - self.y * other.x
    }
    fn dot(&self, other: &Self) -> f64 {
        self.x * other.x + self.y * other.x
    }
    fn norm(&self) -> f64 {
        (self.x * self.x + self.y * self.y).sqrt()
    }
    fn sin(&self, other: &Self) -> f64 {
        self.cross(other) / self.norm() / other.norm()
    }
    fn cos(&self, other: &Self) -> f64 {
        self.dot(other) / self.norm() / other.norm()
    }
    fn angle(&self, other: &Self) -> Angle {
        let ab = self.norm() * other.norm();
        Angle{sin: self.cross(other) / ab, cos: self.dot(other) / ab}
    }
    fn distance(&self, other: &Self) -> f64 {
        let diff = *self - *other;
        (diff.x * diff.x + diff.y * diff.y).sqrt()
    }
}
struct Angle {
    sin: f64, cos: f64
}
impl Add for Angle {
    type Output = Self;
    fn add(self, rhs: Self) -> Self::Output {
        Angle{sin: self.sin * rhs.cos + self.cos * rhs.sin, cos: self.cos * rhs.cos - self.sin * rhs.sin}
    }
}
impl Sub for Angle {
    type Output = Self;
    fn sub(self, rhs: Self) -> Self::Output {
        Angle{sin: self.sin * rhs.cos - self.cos * rhs.sin, cos: self.cos * rhs.cos + self.sin * rhs.sin}
    }
}
impl Add for Point {
    type Output = Point;
    fn add(self, rhs: Self) -> Self::Output {
        Point{x: self.x + rhs.x, y: self.y + rhs.y}
    }
}
impl Sub for Point {
    type Output = Point;
    fn sub(self, rhs: Self) -> Self::Output {
        Point{x: self.x - rhs.x, y: self.y - rhs.y}
    }
}
impl Display for Point {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        write!(f, , self.x, self.y)
    }
}
pub struct Line {
    a: f64, b: f64, c: f64,
}
impl Line {
    fn by_two_points(a: &Point, b: &Point) -> Line {
        Line{a: a.x - b.x, b: b.y - a.y, c: a.y * b.x - a.x * b.y}
    }
    fn by_point_and_angle(point: &Point, angle: &Angle) -> Line {
        Line{a: angle.cos, b: -angle.sin, c: angle.sin * point.x - angle.cos * point.y}
    }
    fn is_parallel(&self, other: &Self) -> bool {
        self.a * other.b == self.b * other.a
    }
    fn cross_point(&self, other: &Self) -> Option<Point> {
        if self.is_parallel(other) {
            None
        }else {
            let d = self.b * other.a - self.a * other.b;
            Some(Point{x: (self.a * other.c - self.c * other.a) / d, y: (self.c * other.b - self.b * other.c) / d})
        }
    }
    fn angle(&self) -> Angle {
        Angle{sin: -self.b, cos: self.a}
    }
    fn line_symmetry_point(&self, point: &Point) -> Point {
        let line = Line::by_point_and_angle(point, &(self.angle() + Angle{sin: 1_f64, cos: 0_f64}));
        let cp = line.cross_point(self).unwrap();
        cp - *point + cp
    }
}
impl Display for Line {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        write!(f, , self.a, self.b, self.c)
    }
}"
Rust,"use std::cmp;
fn main(){
  let n: usize = read();
  let mut a: Vec<Vec<i32>> = vec![vec![0;n+1];n];
  for i in 0 .. n {
    let t: Vec<i32> = read_vec();
    for j in 0 .. n {
      a[i][j+1] = a[i][j] + t[j];
    }
  }
  let mut mxv: i32 = std::i32::MIN;
  
  for i in 0 .. n {
    for j in i+1 .. n+1 {
      let mut ac: i32 = a[0][j] - a[0][i];
      mxv = cmp::max(mxv, ac);
      
      for k in 1 .. n {
        let s: i32 = a[k][j] - a[k][i];
        ac = cmp::max(ac+s, s);
        mxv = cmp::max(mxv, ac);
      }
    }
  }
  
  println!(, mxv);
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"#![allow(non_snake_case)]                                                   
use std::cmp::Ordering;   
use std::io::{stdin, BufRead, BufReader};
use std::f64;
fn main(){
    let input = BufReader::new(stdin());
    let mut V:Vec<i32> = Vec::new();
    for line in input.lines() {
        let values: Vec<i32> = line.unwrap()
            .split_whitespace()
            .filter_map(|x| x.parse::<i32>().ok())
            .collect();
        if values[0]==0{
            if let Some(top)=V.pop(){
                println!(,top);
            }
        }
        else{
            V.push(values[0]);
        }
    }
    
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::fmt::{Display, Error, Formatter};
use std::collections::{VecDeque, BinaryHeap, BTreeMap};
use std::f32::MAX;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    let_all!(a: usize, b: usize, c: usize);
    if (a == 1 && b == 1) || c == 1 {
        println!();
    }else {
        println!();
    }
}"
Rust,"fn main(){
  loop {
    let nm: Vec<usize> = read_vec();
    let n = nm[0];
    let m = nm[1];
    if n == 0 && m == 0 { break; }
    let mut st: Vec<char> = vec!['#';n];
    
    for _ in 0 .. m {
      let a: String = read();
      
      if a == .to_string() { countrya(n, &mut st); }
      else if a == .to_string() { countryb(n, &mut st); }
      else if a == .to_string() { countryc(n, &mut st); }
      else { countryd(n, &mut st); }
    }
      
    println! (, st.iter().collect::<String>());
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn countrya(n: usize, st: &mut Vec<char>){
  for i in 0 .. n {
    if st[i] == '#' {
      st[i] = 'A';
      break;
    }
  }
}
fn countryb(n: usize, st: &mut Vec<char>){
  if n == 1 { st[0] = 'B'; }
  else {
    let mut f: bool = true;
  
    for i in (0 .. n).rev() {
      if i == n - 1 {
        if st[i] == '#' && st[i-1] != 'A' {st[i] = 'B'; f = false; break;}
      }
      else if i == 0 {
        if st[i] == '#' && st[i+1] != 'A' {st[i] = 'B'; f = false; break;}
      }
      else {
        if st[i] == '#' && st[i+1] != 'A' && st[i-1] != 'A' {st[i] = 'B'; f = false; break;}
      }
    }
    if f {
      for i in 0 .. n {
        if st[i] == '#' {
          st[i] = 'B';
          break;
        }
      }
    }
  }
}
fn countryc(n: usize, st: &mut Vec<char>){
  if n == 1 { st[0] = 'C'; }
  else {
    let mut f: bool = true;
    
    for i in 0 .. n {
      if st[i] != '#' {
        if i < n - 1 && st[i+1] == '#' {st[i+1] = 'C'; f = false; break;}
        if i > 0 && st[i-1] == '#' {st[i-1] = 'C'; f = false; break;}
      }
    }
    if f {
      st[n/2] = 'C';
    }
  }
}
fn countryd(n: usize, st: &mut Vec<char>){
  let mut d: Vec<usize> = vec![1000;n];
  for i in 0 .. n {
    if st[i] != '#' {
      d[i] = 0;
      let mut j: usize = 1;
      while i >= j && st[i-j] == '#' && d[i-j] > j {
        d[i-j] = j;
        j += 1;
      }
      j = 1;
      while i+j < n && st[i+j] == '#' {
        d[i+j] = j;
        j += 1;
      }
    }
  }
  
  let mut md: usize = 0;
  let mut mi: usize = 0;
  for i in 0 .. n {
    if d[i] > md {
      md = d[i];
      mi = i;
    }
  }
  st[mi] = 'D';
}"
Rust,"fn main(){
  let mut sieve: Vec<bool> = vec![true; 999984];
  sieve[0] = false;
  sieve[1] = false;
  for i in 2 .. 1000 {
    if sieve[i] {
      let mut j = i * i;
      while j < 999984 {
        sieve[j] = false;
        j += i;
      }
    }
  }
  let mut pn: Vec<usize> = vec![0; 999984];
  
  for i in 1 .. 999984 {
    if sieve[i] {
      pn[i] = pn[i-1] + 1;
    } else {
      pn[i] = pn[i-1];
    }
  }
  
  loop {
    let n: usize = read();
    
    if n == 0 { break; }
    let mut ans: usize = 0;
    
    for _ in 0 .. n {
      let pm: Vec<usize> = read_vec();
      let p = pm[0];
      let m = pm[1];
      let rmn: usize = if p < m + 1 { 0 } else { p - m - 1 };
      let rmx: usize = if p + m > 999983 { 999983 } else { p + m };
      ans += pn[rmx] - pn[rmn];
    }
    ans -= n;
    
    println!(, ans);
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"use std::collections::VecDeque;
use std::collections::HashSet;
fn main(){
  let n: usize = read();
  for _ in 0 .. n {
    let pv: Vec<usize> = read_vec();
    let mut que: VecDeque<(usize, Vec<usize>)> = VecDeque::new();
    let mut hs: HashSet<Vec<usize>> = HashSet::new();
    que.push_back((0, pv.clone()));
    hs.insert(pv.clone());
    loop {
      match que.pop_front() {
        Some((c, v)) => {
          if is_complete(&v) {
            println!(, c);
            break;
          }
          
          let nvf = rotf(&v);
          if !hs.contains(&nvf) {
            que.push_back((c+1, nvf.clone()));
            hs.insert(nvf.clone());
          }
          let nvr = rotr(&v);
          if !hs.contains(&nvr) {
            que.push_back((c+1, nvr.clone()));
            hs.insert(nvr.clone());
          }
          let nvl = rotl(&v);
          if !hs.contains(&nvl) {
            que.push_back((c+1, nvl.clone()));
            hs.insert(nvl.clone());
          }
          let nvb = rotb(&v);
          if !hs.contains(&nvb) {
            que.push_back((c+1, nvb.clone()));
            hs.insert(nvb.clone());
          }
        },
        None => {},
      }
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn rotf(v: &Vec<usize>) -> Vec<usize> {
  let mut nv: Vec<usize> = v.iter().map(|x| x.clone()).collect();
  nv[6] = v[21]; nv[21] = v[6];
  nv[7] = v[22]; nv[22] = v[7];
  nv[8] = v[23]; nv[23] = v[8];
  
  nv[9] = v[11]; nv[11] = v[9];
  
  nv[17] = v[12]; nv[12] = v[17];
  
  nv
}
fn rotr(v: &Vec<usize>) -> Vec<usize> {
  let mut nv: Vec<usize> = v.iter().map(|x| x.clone()).collect();
  nv[2] = v[21]; nv[21] = v[2];
  nv[5] = v[24]; nv[24] = v[5];
  nv[8] = v[27]; nv[27] = v[8];
  
  nv[12] = v[14]; nv[14] = v[12];
  
  nv[11] = v[18]; nv[18] = v[11];
  
  nv
}
fn rotl(v: &Vec<usize>) -> Vec<usize> {
  let mut nv: Vec<usize> = v.iter().map(|x| x.clone()).collect();
  nv[0] = v[23]; nv[23] = v[0];
  nv[3] = v[26]; nv[26] = v[3];
  nv[6] = v[29]; nv[29] = v[6];
  
  nv[15] = v[17]; nv[17] = v[15];
  
  nv[9] = v[20]; nv[20] = v[9];
  
  nv
}
fn rotb(v: &Vec<usize>) -> Vec<usize> {
  let mut nv: Vec<usize> = v.iter().map(|x| x.clone()).collect();
  nv[0] = v[27]; nv[27] = v[0];
  nv[1] = v[28]; nv[28] = v[1];
  nv[2] = v[29]; nv[29] = v[2];
  
  nv[18] = v[20]; nv[20] = v[18];
  
  nv[14] = v[15]; nv[15] = v[14];
  
  nv
}
fn is_complete(v: &Vec<usize>) -> bool {
   v[4] == v[0] &&
   v[4] == v[1] &&
   v[4] == v[2] &&
   v[4] == v[3] &&
   v[4] == v[5] &&
   v[4] == v[6] &&
   v[4] == v[7] &&
   v[4] == v[8] &&
   v[10] == v[9] &&
   v[10] == v[11] &&
   v[13] == v[12] &&
   v[13] == v[14] &&
   v[16] == v[15] &&
   v[16] == v[17] &&
   v[19] == v[18] &&
   v[19] == v[20] &&
   v[25] == v[21] &&
   v[25] == v[22] &&
   v[25] == v[23] &&
   v[25] == v[24] &&
   v[25] == v[26] &&
   v[25] == v[27] &&
   v[25] == v[28] &&
   v[25] == v[29]
}"
Rust,"use std::cmp;
fn main(){
  let n: usize = read();
  let m: usize = read();
  let mut dm: Vec<Vec<u32>> = vec![vec![std::u32::MAX / 4;n];n];
  
  for _ in 0 .. m {
    let abcd: Vec<u32> = read_vec();
    let a = (abcd[0] - 1) as usize;
    let b = (abcd[1] - 1) as usize;
    let c = abcd[2];
    let d = abcd[3];
    dm[a][b] = c;
    dm[b][a] = d;
  }
  let sgvp: Vec<u32> = read_vec();
  let s = (sgvp[0] - 1) as usize;
  let g = (sgvp[1] - 1) as usize;
  let v = sgvp[2];
  let p = sgvp[3];
  
  for k in 0 .. n {
    for i in 0 .. n {
      for j in 0 .. n {
        dm[i][j] = cmp::min(dm[i][j], dm[i][k] + dm[k][j]);
      }
    }
  }
  let ans: u32 = v - p - dm[s][g] - dm[g][s];
  
  println!(, ans);
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().split(',').map(|e| e.parse().unwrap()).collect()
}"
Rust,"/**
 *  _           _                 __                            _   _ _   _                                 _                    _                  _
 * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |
 * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___
 * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|
 * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\
 * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/
 *                                                  | |                                                                           | |   | |
 *                                                  |_|                                                                           |_|   |_|
 *
 * https:
 */
#[allow(unused_imports)]
use std::cmp::{max, min, Ordering};
#[allow(unused_imports)]
use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
#[allow(unused_imports)]
use std::iter::FromIterator;
#[allow(unused_imports)]
use std::io::{stdin, stdout, BufWriter, Write};
mod util {
    use std::io::{stdin, stdout, BufWriter, StdoutLock};
    use std::str::FromStr;
    use std::fmt::Debug;
    #[allow(dead_code)]
    pub fn line() -> String {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.trim().to_string()
    }
    #[allow(dead_code)]
    pub fn chars() -> Vec<char> {
        line().chars().collect()
    }
    #[allow(dead_code)]
    pub fn gets<T: FromStr>() -> Vec<T>
    where
        <T as FromStr>::Err: Debug,
    {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.split_whitespace()
            .map(|t| t.parse().unwrap())
            .collect()
    }
    #[allow(dead_code)]
    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {
        let out = stdout();
        let writer = BufWriter::new(out.lock());
        f(writer)
    }
}
#[allow(unused_macros)]
macro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }
#[allow(unused_macros)]
macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) ,  ) ,* ) , $ ( $ a ) ,* ) ; } }
#[allow(dead_code)]
fn main() {
    loop {
        let (h, w) = get!(usize, usize);
        if h == 0 && w == 0 {
            break;
        }
        let n = get!(usize);
        let yx = get!(usize, usize; n);
        let mut map = vec![vec![false; w]; h];
        for (y, x) in yx {
            map[y - 1][x - 1] = true;
        }
        let mut dp = vec![vec![0; w]; h];
        dp[0][0] = 1;
        for i in 0..h {
            for j in 0..w {
                if map[i][j] {
                    continue;
                }
                if i > 0 {
                    dp[i][j] += dp[i - 1][j];
                }
                if j > 0 {
                    dp[i][j] += dp[i][j - 1];
                }
            }
        }
        println!(, dp[h - 1][w - 1]);
    }
}"
Rust,"#![allow(unused_mut, non_snake_case,unused_imports)]
use std::iter;
use std::cmp::{max, min, Ordering};
use std::mem::{swap};
use std::collections::{HashMap,BTreeMap,HashSet,BTreeSet,BinaryHeap,VecDeque};
use std::iter::FromIterator;
macro_rules! input {(source = $s:expr, $($r:tt)*) => {let mut iter = $s.split_whitespace();let mut next = || { iter.next().unwrap() };input_inner!{next, $($r)*}};($($r:tt)*) => {let stdin = std::io::stdin();let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));let mut next = move || -> String{bytes.by_ref().map(|r|r.unwrap() as char).skip_while(|c|c.is_whitespace()).take_while(|c|!c.is_whitespace()).collect()};input_inner!{next, $($r)*}};}
macro_rules! input_inner {($next:expr) => {};($next:expr, ) => {};($next:expr, $var:ident : $t:tt $($r:tt)*) => {let $var = read_value!($next, $t);input_inner!{$next $($r)*}};}
macro_rules! read_value {($next:expr, ( $($t:tt),* )) => {( $(read_value!($next, $t)),* )};($next:expr, [ $t:tt ; $len:expr ]) => {(0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()};($next:expr, chars) => {read_value!($next, String).chars().collect::<Vec<char>>()};($next:expr, usize1) => {read_value!($next, usize) - 1};($next:expr, $t:ty) => {$next().parse::<$t>().expect()};}
/*
 <url:http:
 問題文============================================================
 =================================================================
 解説=============================================================
 ================================================================
 */
fn main(){
    input!(N:usize,C:usize,p:[usize;C]);
    let sum = p.into_iter().sum::<usize>();
    let mut ans = 0;
    ans += sum/(N+1);
    if sum%(N+1) != 0{
        ans+=1;
    }
    println!(,ans);
}"
Rust,"use std::str::FromStr;
use std::io::{ self, stdin };
use std::io::BufRead;
fn main() {
    let N: u32 = input();
    for _ in 0..N {
        let mut val_vec: Vec<u32> = input_vec();
        val_vec.sort();
        let mut val_iter = val_vec.into_iter();
        let v1 = val_iter.next().unwrap().pow(2);
        let v2 = val_iter.next().unwrap().pow(2);
        let v3 = val_iter.next().unwrap().pow(2);
        if v1 + v2 == v3 {
            println!();
        } else {
            println!();
        }
    }
}
pub fn input<T>() -> T
where T:FromStr
{
    let mut buf = String::new();
    stdin().read_line(&mut buf).expect();
    let parse_result = buf.trim().parse::<T>();
    if let Ok(v) = parse_result {
        v
    } else {
        panic!();
    }
}
pub fn input_vec<T>() -> Vec<T>
where T: FromStr
{
    let mut buf = String::new();
    stdin().read_line(&mut buf).expect();
    let split_vec: Vec<_> = buf.trim().split().collect();
    split_vec.iter()
        .map(|&v|{
            let parse_result = v.parse::<T>();
            if let Ok(v) = parse_result { v }
            else {panic!();}
        })
        .collect::<Vec<T>>()
}"
Rust,"/*
お財布メタボ診断
４月に消費税が８％になってから、お財布が硬貨でパンパンになっていませんか。同じ金額を持ち歩くなら硬貨の枚数を少なくしたいですよね。硬貨の合計が１０００円以上なら、硬貨をお札に両替して、お財布のメタボ状態を解消できます。
お財布の中の硬貨の枚数が種類ごとに与えられたとき、硬貨をお札に両替できるかどうかを判定するプログラムを作成してください。
*/
macro_rules! input_vec {
    () => {
        input!()
            .split_whitespace()
            .map(|x| x.parse().unwrap())
            .collect()
    };
    ($delimiter:expr) => {
        input!()
            .split($delimiter)
            .map(|x| x.parse().unwrap())
            .collect()
    };
}
macro_rules! input {
    () => {{
        let mut return_ = String::new();
        std::io::stdin().read_line(&mut return_).ok();
        return_.pop();
        return_
    }};
}
fn main() {
    let v: Vec<i32> = input_vec!();
    println!(
        ,
        if v[0] + v[1] * 5 + v[2] * 10 + v[3] * 50 + v[4] * 100 + v[5] * 500 >= 1000 {
            1
        } else {
            0
        }
    );
}"
Rust,"fn main(){
    let _: usize = read();
    let mut v: Vec<u32> = read_vec();
    let q: i32 = read();
    let mut sv: Vec<u32> = v.clone();
    sv.sort();
    let mut dc: usize = v.iter().zip(sv.iter()).filter(|&(&x, &y)| x != y).count();
    let mut ix: i32 = 0;
    loop {
        if dc == 0 { break }
        ix += 1;
        if ix > q { ix = -1; break }
        let xy: Vec<usize> = read_vec();
        let x = xy[0] - 1;
        let y = xy[1] - 1;
        if v[x] != sv[x] && v[x] == sv[y] { dc -= 1 }
        if v[x] == sv[x] && v[x] != sv[y] { dc += 1 }
        if v[y] != sv[y] && v[y] == sv[x] { dc -= 1 }
        if v[y] == sv[y] && v[y] != sv[x] { dc += 1 }
        v.swap(x, y);
    }
    println!(, ix);
}
#[allow(dead_code)]
fn read<T>() -> T
where T: std::str::FromStr,
      T::Err: std::fmt::Debug
{
    let mut buf = String::new();
    std::io::stdin().read_line(&mut buf).expect();
    buf.trim().parse().unwrap()
}
#[allow(dead_code)]
fn read_vec<T>() -> Vec<T>
where T: std::str::FromStr,
      T::Err: std::fmt::Debug
{
    let mut buf = String::new();
    std::io::stdin().read_line(&mut buf).expect();
    buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"extern crate core;
use std::str::FromStr;
struct Iostream {
    line: Vec<String>,
    position: usize
}
type Parse<T: FromStr> = Result<T, T::Err>;
impl Iostream {
    fn new() -> Iostream{
        Iostream {line:vec![], position: 0}
    }
    fn read_word(&mut self) -> &String {
        if self.position == self.line.len() {
            let mut line= String::new();
            std::io::stdin().read_line(&mut line).ok();
            self.line = line.split_whitespace().map(|x|x.to_string()).collect();
            self.position = 0
        }
        let result = &self.line[self.position];
        self.position += 1;
        result
    }
    fn read<T: FromStr>(&mut self) -> Parse<T> {
        self.read_word().parse()
    }
    fn get<T: FromStr>(&mut self) -> T {self.read().ok().unwrap()}
}
struct Sweets {
    id: i32,
    protein: i32,
    fat: i32,
    carbon: i32,
}
impl Sweets {
    fn calorie(&self) -> i32 {
        self.protein * 4 + self.carbon * 4 + self.fat * 9
    }
}
fn tabulate<T, F>(count: usize, elements: &mut F) -> Vec<T> where F: FnMut(usize) -> T {
    let mut result:Vec<T> = Vec::with_capacity(count);
    for i in 0 .. count {
        result.push(elements(i))
    }
    result
}
fn fill<T, F>(count: usize, generator: F) -> Vec<T> where F: Fn() -> T {
    let mut result: Vec<T> = Vec::with_capacity(count);
    for i in 0 .. count {
        result.push(generator())
    }
    result
}
fn main() {
    let mut stdin = Iostream::new();
    let input = &mut stdin;
    loop {
        let n: usize = input.get();
        if n == 0 {
            break
        }
        let sweets = tabulate(n, &mut |_idx| {
            let s: i32 = input.get();
            let p: i32 = input.get();
            let q: i32 = input.get();
            let r: i32 = input.get();
            Sweets { id: s, protein: p, fat: q, carbon: r }
        });
        let protein :i32 = input.get();
        let fat:i32 = input.get();
        let carbon:i32 = input.get();
        let calorie:i32 = input.get();
        let filtered: Vec<_> = sweets.iter().filter(|&x| x.calorie() <= calorie && x.protein <= protein && x.fat <= fat && x.carbon <= carbon).collect();
        if filtered.len() == 0 {
            println!();
        } else {
            for s in filtered {
                println!(, s.id)
            }
        }
    }
}"
Rust,"#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_macros)]
#![allow(unused_imports)]
use std::str::FromStr;
use std::io::*;
use std::collections::*;
use std::cmp::*;
struct Scanner<I: Iterator<Item = char>> {
    iter: std::iter::Peekable<I>,
}
macro_rules! exit {
    () => {{
        exit!(0)
    }};
    ($code:expr) => {{
        if cfg!(local) {
            writeln!(std::io::stderr(), )
                .expect();
        }
        std::process::exit($code);
    }}
}
impl<I: Iterator<Item = char>> Scanner<I> {
    pub fn new(iter: I) -> Scanner<I> {
        Scanner {
            iter: iter.peekable(),
        }
    }
    pub fn safe_get_token(&mut self) -> Option<String> {
        let token = self.iter
            .by_ref()
            .skip_while(|c| c.is_whitespace())
            .take_while(|c| !c.is_whitespace())
            .collect::<String>();
        if token.is_empty() {
            None
        } else {
            Some(token)
        }
    }
    pub fn token(&mut self) -> String {
        self.safe_get_token().unwrap_or_else(|| exit!())
    }
    pub fn get<T: FromStr>(&mut self) -> T {
        self.token().parse::<T>().unwrap_or_else(|_| exit!())
    }
    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {
        (0..len).map(|_| self.get()).collect()
    }
    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {
        (0..row).map(|_| self.vec(col)).collect()
    }
    pub fn char(&mut self) -> char {
        self.iter.next().unwrap_or_else(|| exit!())
    }
    pub fn chars(&mut self) -> Vec<char> {
        self.get::<String>().chars().collect()
    }
    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {
        (0..row).map(|_| self.chars()).collect()
    }
    pub fn line(&mut self) -> String {
        if self.peek().is_some() {
            self.iter
                .by_ref()
                .take_while(|&c| !(c == '\\n' || c == '\\r'))
                .collect::<String>()
        } else {
            exit!();
        }
    }
    pub fn peek(&mut self) -> Option<&char> {
        self.iter.peek()
    }
}
const INF: i64 = 1 << 60;
fn main() {
    let cin = stdin();
    let cin = cin.lock();
    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));
    loop {
        let n: usize = sc.get();
        if n == 0 {
            break;
        }
        let a: Vec<i64> = sc.vec(n);
        let mut ans = -INF;
        let mut sum = 0;
        for i in 0..n {
            sum = max(a[i], sum + a[i]);
            ans = max(ans, sum);
        }
        println!(, ans);
    }
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::f32::MAX;
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::Display;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    let name = vec!['A', 'B', 'C', 'D', 'E'];
    loop {
        let_all!(s1: i32, s2: i32);
        if s1 == 0 && s2 == 0 {return}
        let mut current = 0;
        let mut current_max = s1 + s2;
        for i in 1 .. 5 {
            let_all!(s1: i32, s2: i32);
            if current_max < s1 + s2 {
                current = i;
                current_max = s1 + s2;
            }
        }
        println!(, name[current], current_max);
    }
}"
Rust,"use std::collections::*;
#[allow(dead_code)]
fn read_line(n: usize) -> String {
    let mut ss = String::new();
    for _i in 0..n {
        let mut s = String::new();
        std::io::stdin().read_line(&mut s).unwrap();
        ss.push_str(&s);
    }
    ss
}
macro_rules! parse {
    ($s:expr => $($r:tt)*) => {
        let s = $s;
        let mut iter = s.split_whitespace();
        input_inner!{iter, $($r)*}
    };
    ($($r:tt)*) => {
        use std::io::Read;
        let mut s = String::new();
        std::io::stdin().read_to_string(&mut s).unwrap();
        parse!{s => $($r)*}
    };
}
macro_rules! input_inner {
    ($iter:expr) => {};
    ($iter:expr, ) => {};
    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {
        let $var = read_value!($iter, $t);
        input_inner!{$iter $($r)*}
    };
    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {
        let mut $var = read_value!($iter, $t);
        input_inner!{$iter $($r)*}
    };
}
macro_rules! read_value {
    ($iter:expr, ( $($t:tt),* )) => {
        ( $(read_value!($iter, $t)),* )
    };
    ($iter:expr, [ $t:tt ; $len:expr ]) => {
        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()
    };
    ($iter:expr, chars) => {
        read_value!($iter, String).chars().collect::<Vec<char>>()
    };
    ($iter:expr, usize1) => {
        read_value!($iter, usize) - 1
    };
    ($iter:expr, $t:ty) => {
        $iter.next().unwrap().parse::<$t>().expect()
    };
}
fn calc(n: i32, cur: i32, s: i32, sum: i32, used: &mut BTreeSet<i32>, useds: &mut BTreeSet<BTreeSet<i32>>) {
    if s < sum {
        return;
    }
    if n == cur {
        if s == sum {
            useds.insert(used.clone());
        }
        return;
    }
    for i in cur..10 {
        if used.get(&i).is_some() {
            continue;
        }
        let mut new_used = used.clone();
        new_used.insert(i);
        calc(n, cur + 1, s, sum + i, &mut new_used, useds);
    }
}
fn sub() -> bool {
    parse!{
        read_line(1) =>
        n: i32,
        s: i32,
    }
    if n == 0 && s == 0 {
        return false;
    }
    let mut used = BTreeSet::new();
    let mut useds = BTreeSet::new();
    calc(n, 0, s, 0, &mut used, &mut useds);
    println!(, useds.len());
    return true;
}
fn main()
{
    while sub() {
    }
}"
Rust,"fn main(){
    let mut hs: Vec<i32> = vec![];
    for _i in 0..10{
        let n=readln();
        hs.push(n);
    }
    hs.sort();
    for i in (7..10).rev(){
        println!(,hs[i]);
    }
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"use std::collections::BinaryHeap;
use std::collections::VecDeque;
fn main(){
  let mut seat: Vec<usize> = vec![0; 18];
  for i in 0 .. 17 {
    seat[i] = 17 - i;
  }
  let mut tm: usize = 0;
  let mut que: VecDeque<usize> = VecDeque::new();
  
  let mut bh: BinaryHeap<(i32, usize, usize)> = BinaryHeap::new();
  
  seat[0] = 0;
  seat[1] = 0;
  let et: i32 = -1 * ((tm + meal_time(0)) as i32);
  bh.push((et, 0, 0));
  let mut rslt: Vec<usize> = vec![0;100];
  let mut ext: bool = false;
  
  loop {
    tm += 1;
    loop {
      match bh.peek() {
        Some(&(tpt, ti, tsn)) => {
          let tt: usize = (-1 * tpt) as usize;
  
          if tt == tm {
            for i in tsn .. tsn + num_member(ti) {
              seat[i] = 1;
            }
            for i in (0..17).rev() {
              if seat[i] != 0 {
                seat[i] = seat[i+1] + 1;
              }
            }
            bh.pop();
          } else { break; }
        },
        None => { break; }
      }
    }
    
    if tm % 5 == 0  && tm < 500{
      que.push_back(tm / 5);
    }
    loop {
      match que.front() {
        Some(&ti) => {
          let tn = num_member(ti);
          match find_seat(&seat, tn) {
            Some(tsi) => {
              for i in tsi .. tsi + tn {
                seat[i] = 0;
              }
              que.pop_front();
              rslt[ti] = tm - 5 * ti;
              let pt: i32 = -1 * ((tm + meal_time(ti)) as i32);
              bh.push((pt, ti, tsi));
              
              if ti == 99 { ext = true; }
            },
            None => { break; }
          }
        },
        None => { break; }
      }
    }
    if ext { break; }
  }
  loop {
    let mut buf = String::new();
    
    if let Ok(c) = std::io::stdin().read_line(&mut buf) {
      if c == 0 { break; }
    }
    let n: usize = buf.trim().parse().unwrap();
    println!(, rslt[n]);
  }
}
fn num_member(i: usize) -> usize {
  if i % 5 == 1 { 5 } else { 2 }
}
fn meal_time(i: usize) -> usize {
  17 * (i % 2) + 3 * (i % 3) + 19
}
fn find_seat(st: &Vec<usize>, t: usize) -> Option<usize> {
  for i in 0 .. 17 {
    if st[i] >= t {
      return Some(i)
    }
  }
  None
}"
Rust,"use std::io::{stdin, Read, StdinLock};
use std::str::FromStr;
use std::cmp;
struct Scanner<'a> {
    cin : StdinLock<'a>,
}
impl<'a> Scanner<'a> {
    fn new(cin : StdinLock<'a>) -> Scanner<'a> {
        Scanner { cin: cin }
    }
    fn read1<T: FromStr>(&mut self) -> Option<T> {
        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)
            .skip_while(|c| c.is_whitespace())
            .take_while(|c| !c.is_whitespace())
            .collect::<String>();
        token.parse::<T>().ok()
    }
    fn read<T: FromStr>(&mut self) -> T {
        self.read1().unwrap()
    }
}
#[derive(Clone)]
struct Query {
    a: usize,
    b: usize,
    c: usize,
    res: bool
}
fn main(){
	let cin = stdin();
	let cin = cin.lock();
	let mut sc = Scanner::new(cin);
        loop {
            let (a, b, c): (usize, usize, usize) = (sc.read(), sc.read(), sc.read());
            if a == 0 { break; }
            let mut tab: Vec<Option<bool>> = vec![None; a+b+c];
            let mut query: Vec<Query> = Vec::new();
            let n : usize = sc.read();
            for _ in 0..n {
                query.push(Query{a: sc.read::<usize>()-1, b: sc.read::<usize>()-1, c: sc.read::<usize>()-1, res: if sc.read::<usize>() == 1 { true } else { false }});
            }
            for j in 0..n {
                if query[j].res {
                    tab[query[j].a] = Some(true);
                    tab[query[j].b] = Some(true);
                    tab[query[j].c] = Some(true);
                } else {
                    if let Some(aa) = tab[query[j].a] {
                        if let Some(bb) = tab[query[j].b] {
                            if aa && bb {
                                tab[query[j].c] = Some(false);
                            }
                        }
                        if let Some(cc) = tab[query[j].c] {
                            if aa && cc {
                                tab[query[j].b] = Some(false);
                            }
                        }
                    }
                    if let Some(bb) = tab[query[j].b] {
                        if let Some(cc) = tab[query[j].c] {
                            if bb && cc {
                                tab[query[j].a] = Some(false);
                            }
                        }
                    }
                }
            }
            for j in 0..n {
                if query[j].res {
                    tab[query[j].a] = Some(true);
                    tab[query[j].b] = Some(true);
                    tab[query[j].c] = Some(true);
                } else {
                    if let Some(aa) = tab[query[j].a] {
                        if let Some(bb) = tab[query[j].b] {
                            if aa && bb {
                                tab[query[j].c] = Some(false);
                            }
                        }
                        if let Some(cc) = tab[query[j].c] {
                            if aa && cc {
                                tab[query[j].b] = Some(false);
                            }
                        }
                    }
                    if let Some(bb) = tab[query[j].b] {
                        if let Some(cc) = tab[query[j].c] {
                            if bb && cc {
                                tab[query[j].a] = Some(false);
                            }
                        }
                    }
                }
            }
            for i in &tab {
                println!(, if let Some(sta) = *i {
                    if sta { 1 }
                    else { 0 }
                } else { 2 } 
                );
            }
        }
}"
Rust,"use std::collections::BinaryHeap;
fn main(){
  let nrl: Vec<usize> = read_vec();
  let n = nrl[0];
  let r = nrl[1];
  let l = nrl[2];
  let mut ptm: usize = 0;
  let mut pid: usize = 1;
  let mut cpt: Vec<isize> = vec![0;n+1];
  let mut ttm: Vec<usize> = vec![0;n+1];
  let mut hp: BinaryHeap<(isize, isize)> = BinaryHeap::new();
  for i in 1 .. n+1 {
    hp.push((0, -1 * (i as isize)));
  }
  for _ in 0 .. r {
    let dtx: Vec<isize> = read_vec();
    let d = dtx[0] as usize;
    let t = dtx[1] as usize;
    let x = dtx[2];
    ttm[pid] += t - ptm;
    cpt[d] += x;
    hp.push((cpt[d], -1 * (d as isize)));
    let mut mp = *hp.peek().unwrap();
    loop {
      if cpt[(mp.1 * -1) as usize] == mp.0 { break; }
      hp.pop();
      mp = *hp.peek().unwrap();
    }
    
    ptm = t;
    pid = (mp.1 * -1) as usize;
  }
  ttm[pid] += l - ptm;
  let mut mid: usize = 1;
  let mut mt: usize = ttm[1];
  for i in 2 .. n+1 {
    if mt < ttm[i] {
      mt = ttm[i];
      mid = i;
    }
  }
  println!(, mid);
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"fn main(){
  let n: usize = read();
  let inf: usize = 100000;
  let mut rv: Vec<Vec<usize>> = vec![vec![inf;n];n];
  
  for _ in 0 .. n {
    let rkt: Vec<usize> = read_vec();
    let r = rkt[0] - 1;
    for t in rkt.iter().skip(2) {
      rv[r][t-1] = 1;
    }
  }
  for k in 0 .. n {
    for i in 0 .. n {
      for j in 0 .. n {
        if rv[i][j] > rv[i][k] + rv[k][j] {
          rv[i][j] = rv[i][k] + rv[k][j];
        }
      }
    }
  }
  let p: usize = read();
  for _ in 0 .. p {
    let sdv: Vec<usize> = read_vec();
    let s = sdv[0] - 1;
    let d = sdv[1] - 1;
    let v = sdv[2];
    if v > rv[s][d] {
      println!(, rv[s][d] + 1);
    } else {
      println!();
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"extern crate core;
use std::fmt;
use std::i32::{MAX};
use std::cmp::{Ordering, min, max };
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::{Display, Formatter, Error};
use std::str::Chars;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_lines{
    ($count: expr; $delimiter: expr; $ty: ty) => {{
        let line_count = $count;
        let mut vec: Vec<Vec<$ty>> = Vec::with_capacity(line_count);
        for _ in 0 .. line_count {
            vec.push(read_line!($delimiter; $ty));
        }
        vec
    }};
    ($count: expr; $ty: ty) => {{
        let line_count = $count;
        let mut vec: Vec<$ty> = Vec::with_capacity(line_count);
        for _ in 0 .. line_count {
            vec.push(read_value!());
        }
        vec
    }}
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    const max_card:usize = 300000;
    let_all!(n: usize, q: usize);
    let mut max_cards = vec![0; max_card + 1];
    for c in read_line!(' '; usize) {
        max_cards[c] = c;
    }
    for i in 1 .. max_cards.len() {
        max_cards[i] = max(max_cards[i], max_cards[i - 1]);
    }
    let max_cards = max_cards;
    for _ in 0 .. q {
        let_all!(m: usize);
        let mut max_rest = max_cards.last().unwrap() % m;
        let mut i = m - 1;
        while i < max_cards.len() {
            max_rest = max(max_rest, max_cards[i] % m);
            i += m;
        }
        print!(, max_rest);
    }
}"
Rust,"macro_rules! input {
    (source = $s:expr, $($r:tt)*) => {
        let mut iter = $s.split_whitespace();
        input_inner!{iter, $($r)*}
    };
    ($($r:tt)*) => {
        #[allow(unused_mut)]
        let mut s = {
            use std::io::Read;
            let mut s = String::new();
            std::io::stdin().read_to_string(&mut s).unwrap();
            s
        };
        let mut iter = s.split_whitespace();
        input_inner!{iter, $($r)*}
    };
}
macro_rules! input_inner {
    ($iter:expr) => {};
    ($iter:expr, ) => {};
    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {
        let $var = read_value!($iter, $t);
        input_inner!{$iter $($r)*}
    };
}
macro_rules! read_value {
    ($iter:expr, ( $($t:tt),* )) => {
        ( $(read_value!($iter, $t)),* )
    };
    ($iter:expr, [ $t:tt ; $len:expr ]) => {
        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()
    };
    ($iter:expr, chars) => {
        read_value!($iter, String).chars().collect::<Vec<char>>()
    };
    ($iter:expr, usize1) => {
        read_value!($iter, usize) - 1
    };
    ($iter:expr, $t:ty) => {
        $iter.next().unwrap().parse::<$t>().expect()
    };
}
#[allow(dead_code)]
type Pi = (i32, i32);
fn pri<T: std::fmt::Display>(x: T) {println!(, x);}
fn main() {
    input!{
        v: [u32; 10],
    }
    let mut v = v;
    v.sort();
    pri(v[9]); pri(v[8]); pri(v[7]);
}"
Rust,"fn main(){
  let inf: usize = 200000000;
  
  loop {
    let nk: Vec<usize> = read_vec();
    let n = nk[0];
    let k = nk[1];
    if n == 0 && k == 0 { break; }
    let mut ntu = false;
    let mut dist: Vec<Vec<usize>> = vec![vec![inf; n]; n];
    
    for i in 0 .. n {
      dist[i][i] = 0;
    }
    
    for _ in 0 .. k {
      let q: Vec<usize> = read_vec();
      if q[0] == 0 {
        let a = q[1] - 1;
        let b = q[2] - 1;
        if ntu {
          wf(&mut dist, n);
          ntu = false;
        }
        
        if dist[a][b] == inf {
          println!();
        } else {
          println!(, dist[a][b]);
        }
      } else {
        let c = q[1] - 1;
        let d = q[2] - 1;
        let e = q[3];
        if dist[c][d] > e {
          dist[c][d] = e;
          dist[d][c] = e;
          ntu = true;
        }
      }
    }
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn wf(d: &mut Vec<Vec<usize>>, n: usize) {
  for k in 0 .. n {
    for i in 0 .. n {
      for j in 0 .. n {
        let t = d[i][k] + d[k][j];
        if t < d[i][j] {
          d[i][j] = t;
        }
      }
    }
  }
}"
Rust,"use std::io;
use std::str::FromStr;
use std::collections::HashMap;
fn read() -> i32 {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    let x: i32 = s.trim().parse().unwrap();
    x
}
fn read_char() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    let x: String = s.trim().parse().unwrap();
    x
}
 fn main(){
    loop{
        let mut rules : HashMap<String,String> = HashMap::new();
    
        let n = read();
        if n == 0{
            break;
        }
        for i in 0..n{
            let mut buf = String::new();
            io::stdin().read_line(&mut buf).unwrap();
            let mut it = buf.split_whitespace().map(|n| String::from_str(n).unwrap());
            let a = it.next().unwrap();
            let b = it.next().unwrap();
            rules.insert(a,b);
        }
        let m = read();
        for i in 0..m{
            let mut a = read_char();
            match rules.get(&a){
                Some(e) =>{
                    print!(,e);
                },
                None => print!(,&a),
            }
        }
        println!();
    }
 }
 "
Rust,"use std::io::BufRead;
pub struct StdinReader<R: BufRead> {
    pub reader: R,
    pub buf: String,
}
impl<R: BufRead> StdinReader<R> {
    pub fn new(reader: R) -> Self {
        Self {
            reader,
            buf: String::new(),
        }
    }
}
macro_rules! get {
    ($r:expr, $t:ty) => {
        {
            let mut line = &mut $r.buf;
            line.clear();
            $r.reader.read_line(&mut line).unwrap();
            line.trim().parse::<$t>().unwrap()
        }
    };
    ($r:expr, $($t:ty),*) => {
        {
            let mut line = &mut $r.buf;
            line.clear();
            $r.reader.read_line(&mut line).unwrap();
            let mut iter = line.split_whitespace();
            (
                $(iter.next().unwrap().parse::<$t>().unwrap(),)*
            )
        }
    };
    ($r:expr, $t:ty; $n:expr) => {
        (0..$n).map(|_|
            get!($r, $t)
        ).collect::<Vec<_>>()
    };
    ($r:expr, $($t:ty),*; $n:expr) => {
        (0..$n).map(|_|
            get!($r, $($t),*)
        ).collect::<Vec<_>>()
    };
    ($r:expr, $t:ty ;;) => {
        {
            let mut line = &mut $r.buf;
            line.clear();
            $r.reader.read_line(&mut line).unwrap();
            line.split_whitespace()
                .map(|t| t.parse::<$t>().unwrap())
                .collect::<Vec<_>>()
        }
    };
    ($r:expr, $t:ty ;; $n:expr) => {
        (0..$n).map(|_| get!($r, $t ;;)).collect::<Vec<_>>()
    };
}
fn main() {
    let stdin = std::io::stdin();
    let mut r = StdinReader::new(stdin.lock());
    let mut hs: Vec<u32> = vec![];
    for _i in 0..10 {
        let a = get!(r, u32);
        hs.push(a);
    }
    hs.sort_by(|a, b| b.cmp(a));
    for i in 0..3 {
        println!(, hs[i]);
    }
}"
Rust,"use std::cmp::Ordering;
use std::io::{stdin, BufRead, BufReader};
struct Vector {
    x: f32,
    y: f32,
}
fn main() {
    let input = BufReader::new(stdin());
    for line in input.lines() {
        let values: Vec<f32> = line.unwrap()
            .split_whitespace()
            .filter_map(|x| x.parse::<f32>().ok())
            .collect();
        let (tri_vectors, target) = get_vectors(values);
        if is_inside(tri_vectors, target) {
            println!();
        } else {
            println!();
        }
    }
}
fn is_inside(tri_vectors: Vec<Vector>, target: Vector) -> bool {
    let idx_pair = [(1, 0), (2, 1), (0, 2)];
    let mut cross_product = vec![];
    for pair in &idx_pair {
        let v1 = sub_vector(&tri_vectors[pair.0], &tri_vectors[pair.1]);
        let v2 = sub_vector(&target, &tri_vectors[pair.0]);
        let c = v1.x * v2.y - v1.y * v2.x;
        cross_product.push(c);
    }
    let plus: Vec<&f32> = cross_product.iter().filter(|x| x > &&0.0).collect();
    let minus: Vec<&f32> = cross_product.iter().filter(|x| x < &&0.0).collect();
    return plus.len() == 3 || minus.len() == 3;
}
fn sub_vector(v1: &Vector, v2: &Vector) -> Vector {
    return Vector {
        x: v1.x - v2.x,
        y: v1.y - v2.y,
    };
}
fn get_vectors(points: Vec<f32>) -> (Vec<Vector>, Vector) {
    let mut vectors = Vec::with_capacity(3);
    let mut i = 0;
    while i < points.len() - 2 {
        vectors.push(Vector {
            x: points[i],
            y: points[i + 1],
        });
        i += 2;
    }
    vectors.sort_by(|a, b| match a.x.partial_cmp(&b.x).unwrap() {
        Ordering::Equal => a.y.partial_cmp(&b.y).unwrap(),
        other => other,
    });
    return (
        vectors,
        Vector {
            x: points[i],
            y: points[i + 1],
        },
    );
}"
Rust,"use std::io::{stdin, BufRead, BufReader};
fn main() {
    let mut w: u32 = 0;
    for i in 0..2 {
        let mut buf = String::new();
        stdin().read_line(&mut buf).unwrap();
        match i {
            0 => w = buf.trim().parse().unwrap(),
            _ => break,
        }
    }
    let reader = BufReader::new(stdin());
    let mut hlines = vec![];
    for line in reader.lines() {
        let l: Vec<u32> = line.unwrap()
            .trim()
            .split(',')
            .filter_map(|x| x.parse::<u32>().ok())
            .collect();
        hlines.push((l[0], l[1]));
    }
    let mut answer = Vec::with_capacity((w + 1) as usize);
    for i in 1..w + 2 {
        answer.push(i);
    }
    for i in 1..w + 1 {
        let mut current = i;
        for hline in &hlines {
            if hline.0 == current {
                current = hline.1;
            } else if hline.1 == current {
                current = hline.0;
            }
        }
        answer[(current - 1) as usize] = i;
    }
    for i in 0..w {
        println!(, answer[i as usize]);
    }
}"
Rust,"/**
 *  _           _                 __                            _   _ _   _                                 _                    _                  _
 * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |
 * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___
 * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|
 * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\
 * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/
 *                                                  | |                                                                           | |   | |
 *                                                  |_|                                                                           |_|   |_|
 *
 * https:
 */
#[allow(unused_imports)]
use std::cmp::{max, min, Ordering};
#[allow(unused_imports)]
use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
#[allow(unused_imports)]
use std::iter::FromIterator;
#[allow(unused_imports)]
use std::io::{stdin, stdout, BufWriter, Write};
mod util {
    use std::io::{stdin, stdout, BufWriter, StdoutLock};
    use std::str::FromStr;
    use std::fmt::Debug;
    #[allow(dead_code)]
    pub fn line() -> String {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.trim().to_string()
    }
    #[allow(dead_code)]
    pub fn chars() -> Vec<char> {
        line().chars().collect()
    }
    #[allow(dead_code)]
    pub fn gets<T: FromStr>() -> Vec<T>
    where
        <T as FromStr>::Err: Debug,
    {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.split_whitespace()
            .map(|t| t.parse().unwrap())
            .collect()
    }
    #[allow(dead_code)]
    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {
        let out = stdout();
        let writer = BufWriter::new(out.lock());
        f(writer)
    }
}
#[allow(unused_macros)]
macro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }
#[allow(unused_macros)]
macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) ,  ) ,* ) , $ ( $ a ) ,* ) ; } }
#[allow(dead_code)]
fn main() {
    let n = get!(usize);
    let m = get!(usize);
    let ab = get!(usize, usize; m);
    let mut g = vec![Vec::new(); n];
    let mut e_rev = vec![HashSet::new(); n];
    for (a, b) in ab {
        e_rev[b - 1].insert(a - 1);
        g[a - 1].push(b - 1);
    }
    let mut stack: Vec<usize> = (0..n).filter(|&i| e_rev[i].is_empty()).collect();
    let mut exists = stack.len() > 1;
    let mut ans = Vec::new();
    while let Some(i) = stack.pop() {
        exists |= stack.len() > 0;
        ans.push(i);
        for &to in &g[i] {
            e_rev[to].remove(&i);
            if e_rev[to].is_empty() {
                stack.push(to);
            }
        }
    }
    util::with_bufwriter(|mut out| {
        for a in ans {
            writeln!(out, , a + 1).unwrap();
        }
        if exists {
            writeln!(out, ).unwrap();
        } else {
            writeln!(out, ).unwrap();
        }
    });
}"
Rust,"#![allow(unused_imports)]
#![allow(unused_macros)]
use std::cmp::{ min, max };
macro_rules! ewriteln {
    ($($args:expr),*) => { let _ = writeln!(&mut std::io::stderr(), $($args),*); };
}
macro_rules! trace {
    ($x:expr) => { ewriteln!(, stringify!($x), $x) };
    ($($xs:expr),*) => { trace!(($($xs),*)) }
}
macro_rules! put {
    ($x:expr) => { println!(, $x) };
    ($x:expr, $($xs:expr),*) => { print!(, $x); put!($($xs),*) }
}
#[derive(Debug, Clone, Copy)]
struct Point(f64, f64);
#[allow(dead_code)]
impl Point {
    fn norm(self) -> f64 {
        (self * self).sqrt()
    }
    fn det(self, other: Point) -> f64 {
        self.0 * other.1 - self.1 * other.0
    }
    fn arg(self) -> f64 {
        let x = self.0 / self.norm();
        (if x < -1.0 { -1.0 } else if x > 1.0 { 1.0 } else { x } as f64).acos()
    }
}
use std::cmp::{PartialEq, Eq};
impl PartialEq for Point {
    fn eq(&self, other: &Point) -> bool {
        let eps = 0.0001;
        (self.0 - other.0).abs() < eps && (self.1 - other.1).abs() < eps
    }
    fn ne(&self, other: &Point) -> bool {
        !(self == other)
    }
}
impl Eq for Point { }
use std::ops::{Add, Sub, Neg, Mul, Div};
impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -> Point {
        Point(self.0 + other.0, self.1 + other.1)
    }
}
impl Neg for Point {
    type Output = Point;
    fn neg(self) -> Point {
        Point(-self.0, -self.1)
    }
}
impl Sub for Point {
    type Output = Point;
    fn sub(self, other: Point) -> Point {
        self + (-other)
    }
}
impl Mul<Point> for f64 {
    type Output = Point;
    fn mul(self, other: Point) -> Point {
        Point(self * other.0, self * other.1)
    }
}
impl Mul<f64> for Point {
    type Output = Point;
    fn mul(self, other: f64) -> Point {
        Point(other * self.0, other * self.1)
    }
}
impl Mul<Point> for Point {
    type Output = f64;
    fn mul(self, other: Point) -> f64 {
        self.0 * other.0 + self.1 * other.1
    }
}
impl Div<f64> for Point {
    type Output = Point;
    fn div(self, other: f64) -> Point {
        Point(self.0 / other, self.1 / other)
    }
}
#[derive(Debug, Clone, Copy)]
struct Line(Point, Point);
#[allow(dead_code)]
impl Line {
    fn len(self) -> f64 {
        (self.0 - self.1).norm()
    }
    fn rev(self) -> Line {
        Line(self.1, self.0)
    }
}
#[derive(Debug, Clone, Copy)]
struct Circle(Point, f64);
#[derive(Debug)]
enum CircleRelation {
    EQUAL,
    SUB, SUP,  
    INTERSECTION(usize)  
}
fn circle_relation(a: Circle, b: Circle) -> CircleRelation {
    use CircleRelation::*;
    let d = (a.0 - b.0).norm();
    let eps = 1e-9;
    if d < eps && (a.1 - b.1).abs() < eps {
        EQUAL
    } else if d + a.1 < b.1 {
        SUB
    } else if a.1 > d + b.1 {
        SUP
    } else if d < a.1 + b.1 {
        INTERSECTION(2)
    } else if d <= a.1 + b.1 + eps {
        INTERSECTION(1)
    } else {
        INTERSECTION(0)
    }
}
fn main() {
    use CircleRelation::*;
    let mut sc = Scanner::new();
    let q: usize = sc.cin();
    for _ in 0..q {
        let x1: f64 = sc.cin();
        let y1: f64 = sc.cin();
        let r1: f64 = sc.cin();
        let x2: f64 = sc.cin();
        let y2: f64 = sc.cin();
        let r2: f64 = sc.cin();
        let a = Circle(Point(x1, y1), r1);
        let b = Circle(Point(x2, y2), r2);
        match circle_relation(a, b) {
            SUB => {
                put!(-2);
            },
            SUP => {
                put!(2);
            },
            INTERSECTION(0) => {
                put!(0);
            },
            _ => {
                put!(1);
            }
        }
    }
}
use std::io::{self, Write};
use std::str::FromStr;
use std::collections::VecDeque;
struct Scanner { stdin: io::Stdin, buffer: VecDeque<String>, }
impl Scanner {
    fn new() -> Scanner { Scanner { stdin: io::stdin(), buffer: VecDeque::new() } }
    fn cin<T: FromStr>(&mut self) -> T {
        while self.buffer.len() == 0 {
            let mut line = String::new();
            let _ = self.stdin.read_line(&mut line);
            for w in line.split_whitespace() {
                self.buffer.push_back(String::from(w));
            }
        }
        self.buffer.pop_front().unwrap().parse::<T>().ok().unwrap()
    }
}"
Rust,"use std::fmt::Debug;
use std::str::FromStr;
use std::collections::*;
fn read_line<T>() -> Vec<T>
where T: FromStr, <T as FromStr>::Err : Debug{
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim().split_whitespace().map(|c| T::from_str(c).unwrap()).collect()
}
fn sub() -> bool
{
    let ms = read_line();
    let m = ms[0];
    if m == 0 {
        return false;
    }
    let mut m_xys = Vec::with_capacity(m);
    let mut base_x = 0;
    let mut base_y = 0;
    for i in 0..m {
        let mut line: Vec<i64> = read_line();
        if i == 0 {
            base_x = line[0];
            base_y = line[1];
        }
        else {
            line[0] -= base_x;
            line[1] -= base_y;
            m_xys.push(line);
        }
    }
    let ns = read_line();
    let n = ns[0];
    let mut n_xys = HashSet::with_capacity(n);
    for _i in 0..n {
        let ns: Vec<i64> = read_line();
        n_xys.insert(ns);
    }
    if m == 1 {
        
        assert!(m_xys.is_empty());
        for n_xy in &n_xys {
            println!(, n_xy[0] - base_x, n_xy[1] - base_y);
            return true;
        }
    }
    let mut matchs = Vec::new();
    for n_xy in &n_xys {
        if !m_xys.iter().all(|m_xy| {
            matchs.clear();
            matchs.push(n_xy[0] + m_xy[0]);
            matchs.push(n_xy[1] + m_xy[1]);
            n_xys.contains(&matchs)
        }) {
            continue;
        }
        println!(, n_xy[0] - base_x, n_xy[1] - base_y);
    }
    return true;
}
fn main()
{
    loop {
        if !sub() {
            return;
        }
    }
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::fmt::{Display, Error, Formatter};
use std::collections::{VecDeque, BinaryHeap, BTreeMap};
use std::f32::MAX;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    loop {
        let_all!(n: usize);
        if n == 0 {
            return
        }
        let heights = read_line!(' '; i32);
        for i in 0 .. n + 1 {
            let mut vec = Vec::with_capacity(n);
            for j in 0 .. n + 1 {
                if i != j {
                    vec.push(heights[j]);
                }
            }
            let mut res = true;
            for j in 1 .. n - 1 {
                if vec[j] - vec[j - 1] != vec[j + 1] - vec[j] {
                    res = false;
                }
            }
            if res {
                println!(, heights[i]);
                break
            }
        }
    }
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::f32::MAX;
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::{Display, Formatter, Error};
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    let_all!(n: usize);
    let mut count = vec![0; 200100];
    for _ in 0..n {
        let_all!(a: usize, b: usize);
        count[a + b] += 1;
    }
    for i in 0 .. count.len() {
        if count[i] >= 2 {
            count[i + 1] += count[i] / 2;
            count[i] %= 2;
        }
        if count[i] > 0 {
            println!(, i);
        }
    }
}"
Rust,"/*input
12
100
200
300
0
*/
fn read_line() -> String {
    let mut return_ = format!();
    std::io::stdin().read_line(&mut return_).ok();
    return_.pop();
    return_
}
fn sieve_of_eratosthenes(n: usize) -> Vec<bool> {
    let mut vec: Vec<bool> = vec![true; n];
    vec[0] = false;
    vec[1] = false;
    let mut j: usize;
    for i in 2..n {
        if vec[i] {
            j = i * i;
            while j < n {
                vec[j] = false;
                j = j + i;
            }
        }
    }
    vec
    /*let mut vec2: Vec<usize> = vec![];
    for i in 0..vec.len() {
        if vec[i] {
            vec2.push(i);
        }
    }
    vec2*/
}
fn main() {
    let soe = sieve_of_eratosthenes(10001);
    let mut input: i32;
    let mut index: i32;
    let mut prime: [i32; 2];
    let mut prime_fill_1: bool;
    loop {
        input = read_line().parse().unwrap();
        
        if input == 0 {
            break;
        }
        index = input;
        prime = [0; 2];
        prime_fill_1 = true;
        loop {
            if soe[index as usize] {
                if prime_fill_1 {
                    prime[1] = prime[0];
                    prime[0] = index;
                    prime_fill_1 = false;
                } else {
                    prime[1] = prime[0];
                    prime[0] = index;
                    prime_fill_1 = true;
                }
            }
            
            if (prime[1] - prime[0]).abs() == 2 {
                println!(, prime[0], prime[1]);
                break;
            }
            index = index - 1;
        }
    }
}"
Rust,"use std::cmp;
fn main(){
  loop {
    let nk: Vec<usize> = read_vec();
    let n = nk[0];
    let k = nk[1];
    if n == 0 && k == 0 { break; }
    let mut cv: Vec<bool> = vec![false; n+1];
    for _ in 0 .. k {
      let c: usize = read();
      cv[c] = true;
    }
    let mut mxl: usize = 1;
    let mut av: Vec<usize> = vec![0; n+1];
    
    if cv[0] {
      for i in 1 .. n+1 {
        if cv[i] {
          if cv[i-1] {
            av[i] = av[i-1] + 1;
          } else {
            av[i] = 1;
          }
        }
      }
      
      let mut mv: Vec<usize> = vec![0; n+1];
      mv[n] = av[n];
      
      for i in (1 .. n).rev() {
        if av[i] > 0 {
          if av[i+1] > 0 {
            mv[i] = mv[i+1];
          } else {
            mv[i] = av[i];
          }
        }
      }
      for i in 1 .. n+1 {
        if !cv[i] {
          let s = 1 +
                  if i > 1 { mv[i-1] } else { 0 } +
                  if i < n { mv[i+1] } else { 0 };
          mxl = cmp::max(mxl, s);
        }
      }
    } else {
      for i in 1 .. n+1 {
        if cv[i] {
          if cv[i-1] {
            av[i] = av[i-1] + 1;
            mxl = cmp::max(mxl, av[i]);
          } else {
            av[i] = 1;
          }
        }
      }
    }
    
    println!(, mxl);
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"use std::io::{stdin, BufRead, BufReader};
fn main(){
  let input = BufReader::new(stdin());
  for input in input.lines(){
    let n: u32 = input.unwrap().trim().parse::<u32>().unwrap();
    let mut res=0;
    for i in 0..10{
        for j in 0..10{
            for k in 0..10{
                for l in 0..10{
                    if (i+j+k+l)==n{
                        res=res+1;
                    }
                }
            }
        }
    }
    println!(,res);
  }
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::f32::MAX;
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::Display;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    loop {
        let_all!(n: usize, m: usize);
        if n == 0 && m == 0 {return}
        let mut picture: Vec<Vec<i32>> = Vec::with_capacity(n);
        for _ in 0 .. n {
            picture.push(read_line!(' '; i32));
        }
        let mut piece: Vec<Vec<i32>> = Vec::with_capacity(m);
        for _ in 0 .. m {
            piece.push(read_line!(' '; i32));
        }
        let picture = Picture{state: picture, height: n, width: n};
        let mut piece = Piece::read(&piece);
        let mut left_top = Point{x: n, y: n};
        'out: for _ in 0 .. 4 {
            piece = piece.rotate_right();
            for y in 0 .. n - m + 1 {
                for x in 0 .. n - m + 1 {
                    if let Some(p) = piece.is_match_at(&picture, Point{x: x, y: y}) {
                        if left_top.y > p.y || (left_top.y == p.y && left_top.x > p.x) {
                            left_top = p;
                        }
                        continue 'out;
                    }
                }
            }
        }
        if left_top.y == n {
            println!();
        }else {
            println!(, left_top.x + 1, left_top.y + 1);
        }
    }
}
#[derive(Copy, Clone)]
struct Point {
    x: usize, y: usize
}
struct Piece {
    peaces: Vec<(Point, i32)>,
    height: usize, width: usize,
}
struct Picture {
    state: Vec<Vec<i32>>,
    height: usize, width: usize,
}
impl Piece {
    fn read(piece: &Vec<Vec<i32>>) -> Piece {
        
        
        let mut vec = Vec::new();
        for y in 0 .. piece.len() {
            for x in 0 .. piece[y].len() {
                if piece[y][x] != -1 {
                    vec.push((Point{x: x, y: y}, piece[y][x]));
                }
            }
        }
        Piece{peaces: vec, height: piece.len(), width: piece[0].len()}
    }
    fn is_match_at(&self, picture: &Picture, left_top: Point) -> Option<Point> {
        let left = left_top.x;
        let top = left_top.y;
        for &(p, n) in &self.peaces {
            if p.x + left >= picture.width || p.y + top >= picture.height || picture.state[p.y + top][p.x + left] != n{
                return None
            }
        }
        let (ret, _) = self.peaces[0];
        Some(Point{x: ret.x + left, y: ret.y + top})
    }
    fn rotate_right(&self) -> Piece {
        let mut vec = vec![vec![-1; self.height]; self.width];
        for &(p, n) in &self.peaces {
            vec[p.x][self.height - p.y - 1] = n;
        }
        Piece::read(&vec)
    }
}"
Rust,"fn main(){
  loop {
    let nm: Vec<usize> = read_vec();
    let n = nm[0];
    let m = nm[1];
    if n == 0 && m == 0 { break; }
  
    let mut wv: Vec<Vec<isize>> = Vec::new();
  
    for _ in 0 .. n {
      wv.push(read_vec());
    }
  
    let mut pv: Vec<Vec<Vec<isize>>> = vec![vec![vec![0;m];m];4];
  
    for i in 0 .. m {
      let t: Vec<isize> = read_vec();
      for j in 0 .. m {
        pv[0][i][j] = t[j];
      }
    }
  
    for k in 1 .. 4 {
      for i in 0 .. m {
        for j in 0 .. m {
          pv[k][j][m-i-1] = pv[k-1][i][j];
        }
      }
    }
    let mut ofs: Vec<usize> = vec![0;4];
    for k in 0 .. 4 {
      for i in (0 .. m).rev() {
        if pv[k][0][i] >= 0 { ofs[k] = i; }
      }
    }
    let mut ans: (usize, usize) = (n, n);
    for y in 0 .. n - m + 1 {
      for x in 0 .. n - m + 1 {
        for r in 0 .. 4 {
          if equal(&wv, &pv, r, y, x) && ans > (y, x + ofs[r]) {
            ans = (y, x + ofs[r]);
          }
        }
      }
    }
    if ans == (n, n) {
      println!();
    } else {
      println!(, ans.1 + 1, ans.0 + 1);
    }
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn equal(w: &Vec<Vec<isize>>, p: &Vec<Vec<Vec<isize>>>, r: usize, y: usize, x: usize) -> bool {
  let m = p[0][0].len();
  let mut ret = true;
  for i in 0 .. m {
    for j in 0 .. m {
      if p[r][i][j] >= 0 && w[y+i][x+j] != p[r][i][j] { ret = false; }
    }
  }
  ret
}"
Rust,"/*
All the players, welcome to PC Koshien. The main election of PC Koshien will be held at Aizu University, and one team will be assigned to one desk in the hall. As PC Koshien has one team and two people, it requires a team number Ã— 2 chairs. In the university, there are other opportunities to set up desks and chairs at various event venues, but the number of desks and chairs needed also varies. So, given the number of desks to prepare for an event and the number of chairs needed per desk, create a program to calculate the total number of chairs needed.
*/
macro_rules! input_vec {
    () => {
        input!()
            .split_whitespace()
            .map(|x| x.parse().unwrap())
            .collect()
    };
    ($delimiter:expr) => {
        input!()
            .split($delimiter)
            .map(|x| x.parse().unwrap())
            .collect()
    };
}
macro_rules! input {
    () => {{
        let mut return_ = String::new();
        std::io::stdin().read_line(&mut return_).ok();
        return_.pop();
        return_
    }};
}
fn main() {
    let v: Vec<i32> = input_vec!();
    println!(, v[0] * v[1]);
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::fmt::{Display, Error, Formatter};
use std::collections::{VecDeque, BinaryHeap, BTreeMap};
use std::f32::MAX;
use std::ops::{Add, Sub};
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn main() {
    loop {
        let_all!(n: usize);
        if n == 0 {
            return
        }
        let_all!(y: f64);
        let mut max_rate = 0_f64;
        let mut max_bank = 0;
        for _ in 0..n {
            let_all!(b: usize, r: f64, t: usize);
            let rate = match t {
                1 => {
                    (1_f64 + y * r / 100_f64).log10()
                }
                2 => {
                    (1_f64 + r / 100_f64).log10() * y
                }
                _ => unreachable!()
            };
            if max_rate < rate {
                max_bank = b;
                max_rate = rate;
            }
        }
        println!(, max_bank);
    }
}"
Rust,"use std::collections::VecDeque;
use std::collections::HashSet;
fn main(){
  loop {
    let wh: Vec<usize> = read_vec();
    let w = wh[0];
    let h = wh[1];
    
    if w == 0 && h == 0 { break; }
    
    let txy: Vec<usize> = read_vec();
    let tx = txy[0] - 1;
    let ty = txy[1] - 1;
    let kxy: Vec<usize> = read_vec();
    let kx = kxy[0] - 1;
    let ky = kxy[1] - 1;
    let mut d : Vec<Vec<usize>> = Vec::new();
    
    for _ in 0 .. h {
      d.push(read_vec());
    }
    
    let mut que: VecDeque<((usize, usize), (usize, usize), usize)> = VecDeque::new();
    let mut set: HashSet<(usize, usize, usize, usize)> = HashSet::new();
    que.push_back(((tx, ty), (kx, ky), 0));
    set.insert((tx, ty, kx, ky));
    loop {
      match que.pop_front() {
        Some(((x1, y1), (x2, y2), wk)) => {
          if wk >= 100 { continue; }
          
          if x1 == x2 && y1 == y2 {
            println!(, wk);
            break;
          }
          
          let nx1 = if x1 < w - 1 && d[y1][x1+1] == 0 { x1 + 1 } else { x1 };
          let nx2 = if x2 > 0 && d[y2][x2-1] == 0 { x2 - 1 } else { x2 };
          if !set.contains(&(nx1, y1, nx2, y2)) {
            que.push_back(((nx1, y1), (nx2, y2), wk + 1));
            set.insert((nx1, y1, nx2, y2));
          }
          
          let nx1 = if x1 > 0 && d[y1][x1-1] == 0 { x1 - 1 } else { x1 };
          let nx2 = if x2 < w - 1 && d[y2][x2+1] == 0 { x2 + 1 } else { x2 };
          if !set.contains(&(nx1, y1, nx2, y2)) {
            que.push_back(((nx1, y1), (nx2, y2), wk + 1));
            set.insert((nx1, y1, nx2, y2));
          }
          
          let ny1 = if y1 < h - 1 && d[y1+1][x1] == 0 { y1 + 1 } else { y1 };
          let ny2 = if y2 > 0 && d[y2-1][x2] == 0 { y2 - 1 } else { y2 };
          if !set.contains(&(x1, ny1, x2, ny2)) {
            que.push_back(((x1, ny1), (x2, ny2), wk + 1));
            set.insert((x1, ny1, x2, ny2));
          }
          
          let ny1 = if y1 > 0 && d[y1-1][x1] == 0 { y1 - 1 } else { y1 };
          let ny2 = if y2 < h - 1 && d[y2+1][x2] == 0 { y2 + 1 } else { y2 };
          if !set.contains(&(x1, ny1, x2, ny2)) {
            que.push_back(((x1, ny1), (x2, ny2), wk + 1));
            set.insert((x1, ny1, x2, ny2));
          }
        },
        None => {
          println!();
          break;
        },
      }
    }
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::fmt::{Display, Error, Formatter, Binary};
use std::f32::MAX;
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet};
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
struct Real {
    vec: [bool;32]
}
impl Real {
    fn new(expression: &String) -> Real {
        let expression: Vec<_> = expression.chars().map(|c| {c.to_digit(16).unwrap() as i32 }).collect();
        let mut vec = [false; 32];
        for i in 0 .. 8 {
            for j in 0 .. 4 {
                vec[i * 4 + j] = (expression[i] & (1 << (3 - j as i32))) != 0;
            }
        }
        Real{vec: vec}
    }
    fn to_real_expression(&self) -> String {
        let mut vec = Vec::new();
        let mut value = 0;
        for i in 25 .. 32 {
            value *= 2;
            if self.vec[i] {
                value += 1;
            }
        }
        value *= 78125;
        let mut has_digit = false;
        for _ in 0 .. 7 {
            if has_digit || value % 10 != 0 {
                vec.push((value % 10).to_string());
                has_digit = true;
            }
            value /= 10;
        }
        if !has_digit {vec.push(.to_string())};
        vec.push(.to_string());
        value = 0;
        for i in 1 .. 25 {
            value *= 2;
            if self.vec[i] {
                value += 1;
            }
        }
        while value >= 10 {
            vec.push((value % 10).to_string());
            value /= 10;
        }
        vec.push(value.to_string());
        if self.vec[0] {
            vec.push(.to_string());
        }
        vec.reverse();
        vec.concat()
    }
}
fn main() {
    let_all!(q: usize);
    for _ in 0 .. q {
        let string = read_line!().trim().to_string();
        println!(, Real::new(&string).to_real_expression());
    }
}"
Rust,"fn main() {
    loop {
        let (n, k) = read_tuple();
        if n == 0 && k == 0 {
            break;
        }
        let data = (0..n).map(|_| read::<i64>()).collect::<Vec<i64>>();
        let acc_sum = accumulate_each(data.iter(), add_i64, 0);
        let mut ans = 0;
        for i in 0..(n - k + 1) {
            let local_sum = acc_sum[i + k] - acc_sum[i];
            if ans < local_sum {
                ans = local_sum;
            }
        }
        println!(, ans);
    }
}
fn add_i64(a: i64, b:i64) -> i64 {
    a + b
}
fn accumulate_each<T: std::clone::Clone>(iterable: std::slice::Iter<T>, func: fn(T, T) -> T, init: T) -> Vec<T> {
    let mut res = Vec::new();
    let mut acc = init.clone();
    res.push(acc.clone());
    for element in iterable {
        acc = func(acc, element.clone());
        res.push(acc.clone());
    }
    res
}
fn read_tuple<T: std::str::FromStr + Copy>() -> (T, T) {
    let temp = read_vec();
    (temp[0], temp[1])
}
fn read_vec<T: std::str::FromStr>() -> Vec<T> {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    s.trim().split_whitespace()
        .map(|e| e.parse().ok().unwrap()).collect()
}
fn read<T: std::str::FromStr>() -> T {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    s.trim().parse().ok().unwrap()
}"
Rust,"#![allow(unused_mut, non_snake_case,unused_imports)]
use std::iter;
use std::cmp::{max, min, Ordering};
use std::mem::{swap};
use std::collections::{HashMap,BTreeMap,HashSet,BTreeSet,BinaryHeap,VecDeque};
use std::iter::FromIterator;
macro_rules! input {(source = $s:expr, $($r:tt)*) => {let mut iter = $s.split_whitespace();let mut next = || { iter.next().unwrap() };input_inner!{next, $($r)*}};($($r:tt)*) => {let stdin = std::io::stdin();let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));let mut next = move || -> String{bytes.by_ref().map(|r|r.unwrap() as char).skip_while(|c|c.is_whitespace()).take_while(|c|!c.is_whitespace()).collect()};input_inner!{next, $($r)*}};}
macro_rules! input_inner {($next:expr) => {};($next:expr, ) => {};($next:expr, $var:ident : $t:tt $($r:tt)*) => {let $var = read_value!($next, $t);input_inner!{$next $($r)*}};}
macro_rules! read_value {($next:expr, ( $($t:tt),* )) => {( $(read_value!($next, $t)),* )};($next:expr, [ $t:tt ; $len:expr ]) => {(0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()};($next:expr, chars) => {read_value!($next, String).chars().collect::<Vec<char>>()};($next:expr, usize1) => {read_value!($next, usize) - 1};($next:expr, $t:ty) => {$next().parse::<$t>().expect()};}
/*
 <url:>
 問題文============================================================
 =================================================================
 解説=============================================================
 ================================================================
 */
use std::str::FromStr;
fn main() {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).ok();
    let mut v: Vec<String> = s.trim().
        split_whitespace().map(|c| c.parse().ok().unwrap()).collect();
    v.sort_by_key(|s| s.len());
    let mut mp: HashMap<String, usize> = HashMap::new();
    let mut ans1= String::new();
    let mut m = 0;
    for x in v.iter() {
        let key = x.clone();
        let count = mp.entry(key).or_insert(0);
        *count += 1;
        if m < *count{
            m = *count;
            ans1 = x.clone();
        }
    }
    let ans2 = v.last().unwrap();
    println!(,ans1,ans2);
}"
Rust,"use std::io::*;
use std::str::FromStr;
fn read<T: FromStr>() -> T {
    let stdin = stdin();
    let stdin = stdin.lock();
    let token: String = stdin
        .bytes()
        .map(|c| c.expect() as char)
        .skip_while(|c| c.is_whitespace())
        .take_while(|c| !c.is_whitespace())
        .collect();
    token.parse().ok().expect()
}
fn main() {
    loop {
        let n: usize = read();
        let k: usize = read();
        if n == 0 && k == 0 {
            break;
        }
        let a: Vec<i64> = (0..n).map(|_| read()).collect();
        let mut s: Vec<i64> = vec![0; n + 1];
        
        for i in 0..n {
            s[i + 1] = s[i] + a[i];
        }
        
        let mut max = std::i64::MIN;
        for i in 0..n + 1 - k {
            max = std::cmp::max(s[i + k] - s[i], max);
        }
        println!(, max);
    }
}"
Rust,"fn main(){
  let nmq: Vec<usize> = read_vec();
  let n = nmq[0];
  let m = nmq[1];
  let q = nmq[2];
  let av: Vec<usize> = read_vec();
  let qv: Vec<usize> = read_vec();
  let mut ll: Vec<usize> = vec![0;n];
  let mut rl: Vec<usize> = vec![0;n];
  rl[0] = n - 1;
  ll[n-1] = 0;
  for i in 1 .. n {
    rl[i] = i - 1;
  }
  for i in 0 .. n-1 {
    ll[i] = i + 1;
  }
  let mut cbt = 0;
  
  for i in 0 .. m {
    cbt = pass(&mut ll, &mut rl, av[i], cbt);
  }
  for i in 0 .. q {
    println!(, if ll[qv[i]] == 200000 { 0 } else { 1 });
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn pass(ll: &mut Vec<usize>, rl: &mut Vec<usize>, a: usize, bt: usize) -> usize {
  let mut t = bt;
  
  if a % 2 == 0 {
    for _ in 0 .. a {
      t = ll[t];
    }
  } else {
    for _ in 0 .. a {
      t = rl[t];
    }
  }
  
  let tl = ll[t];
  let tr = rl[t];
  rl[tl] = tr;
  ll[tr] = tl;
  rl[t] = 200000;
  ll[t] = 200000;
  tl
}"
Rust,"#[doc = ]
#[allow(unused_imports)]
use std::cmp::{max, min, Ordering};
#[allow(unused_imports)]
use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
#[allow(unused_imports)]
use std::io::{stdin, stdout, BufWriter, Write};
#[allow(unused_imports)]
use std::iter::FromIterator;
mod util {
    use std::fmt::Debug;
    use std::io::{stdin, stdout, BufWriter, StdoutLock};
    use std::str::FromStr;
    #[allow(dead_code)]
    pub fn line() -> String {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.trim().to_string()
    }
    #[allow(dead_code)]
    pub fn chars() -> Vec<char> {
        line().chars().collect()
    }
    #[allow(dead_code)]
    pub fn gets<T: FromStr>() -> Vec<T>
    where
        <T as FromStr>::Err: Debug,
    {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.split_whitespace()
            .map(|t| t.parse().unwrap())
            .collect()
    }
    #[allow(dead_code)]
    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {
        let out = stdout();
        let writer = BufWriter::new(out.lock());
        f(writer)
    }
}
#[allow(unused_macros)]
macro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }
#[allow(unused_macros)]
macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) ,  ) ,* ) , $ ( $ a ) ,* ) ; } }
const BIG_STACK_SIZE: bool = true;
#[allow(dead_code)]
fn main() {
    use std::thread;
    if BIG_STACK_SIZE {
        thread::Builder::new()
            .stack_size(32 * 1024 * 1024)
            .name(.into())
            .spawn(solve)
            .unwrap()
            .join()
            .unwrap();
    } else {
        solve();
    }
}
#[doc = ]
pub trait BinarySearch<T> {
    fn lower_bound(&self, &T) -> usize;
    fn upper_bound(&self, &T) -> usize;
}
impl<T: Ord> BinarySearch<T> for [T] {
    fn lower_bound(&self, x: &T) -> usize {
        let mut low = 0;
        let mut high = self.len();
        while low != high {
            let mid = (low + high) / 2;
            match self[mid].cmp(x) {
                Ordering::Less => {
                    low = mid + 1;
                }
                Ordering::Equal | Ordering::Greater => {
                    high = mid;
                }
            }
        }
        low
    }
    fn upper_bound(&self, x: &T) -> usize {
        let mut low = 0;
        let mut high = self.len();
        while low != high {
            let mid = (low + high) / 2;
            match self[mid].cmp(x) {
                Ordering::Less | Ordering::Equal => {
                    low = mid + 1;
                }
                Ordering::Greater => {
                    high = mid;
                }
            }
        }
        low
    }
}
fn f(xs: &[u64]) -> Vec<u64> {
    let mut res = xs.to_vec();
    res.push(0);
    for &x in xs {
        for &y in xs {
            res.push(x + y);
        }
    }
    res.sort();
    res.dedup();
    res
}
fn solve() {
    loop {
        let (n, m) = get!(usize, u64);
        if n == 0 && m == 0 {
            return;
        }
        let xs = get!(u64; n);
        let v = f(&xs);
        let mut ans = 0;
        for &x in &v {
            if x <= m {
                let i = v.upper_bound(&(m - x));
                ans = max(ans, x + v[i - 1]);
            }
        }
        println!(, ans);
    }
}"
Rust,"use std::io::{stdin, BufRead, BufReader};
fn main(){
    let input = BufReader::new(stdin());
    for line in input.lines(){
        
        let v: Vec<f32> = line.unwrap().split_whitespace().filter_map(|x| x.parse::<f32>().ok()).collect();
        
        println!(, (v[2]*v[4]-v[1]*v[5])/(v[0]*v[4]-v[1]*v[3]),(v[2]*v[3]-v[0]*v[5])/(v[1]*v[3]-v[0]*v[4]));
    }
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"use std::io::Read;
use std::io::Write;
struct Dice {
    val: [usize; 6],
}
impl Dice {
    fn new() -> Self {
        let mut dice = Dice {
            val: [0; 6],
        };
        for i in 0..6 {
            dice.val[i] = i + 1;
        }
        dice
    }
    fn top(&self) -> usize {
        self.val[0]
    }
    fn rotate_by(&mut self, a: &[usize]) {
        let val = &mut self.val;
        let x = val[a[0]];
        let mut p = a[0];
        for &a in &a[1..] {
            val[p] = val[a];
            p = a;
        }
        val[p] = x;
    }
    fn north(&mut self) {
        let a = [0, 1, 5, 4];
        self.rotate_by(&a);
    }
    fn east(&mut self) {
        let a = [0, 3, 5, 2];
        self.rotate_by(&a);
    }
    fn west(&mut self) {
        let a = [0, 2, 5, 3];
        self.rotate_by(&a);
    }
    fn south(&mut self) {
        let a = [0, 4, 5, 1];
        self.rotate_by(&a);
    }
    fn right(&mut self) {
        let a = [1, 2, 4, 3];
        self.rotate_by(&a);
    }
    fn left(&mut self) {
        let a = [1, 3, 4, 2];
        self.rotate_by(&a);
    }
}
fn run() {
    let out = std::io::stdout();
    let mut out = std::io::BufWriter::new(out.lock());
    let mut s = String::new();
    std::io::stdin().read_to_string(&mut s).unwrap();
    let mut it = s.trim().split_whitespace();
    loop {
        let n: usize = it.next().unwrap().parse().unwrap();
        if n == 0 {
            break;
        }
        let dice = &mut Dice::new();
        let mut ans = 1;
        for _ in 0..n {
            let s = it.next().unwrap();
            match s {
                 => dice.north(),
                 => dice.east(),
                 => dice.south(),
                 => dice.west(),
                 => dice.right(),
                 => dice.left(),
                _ => unreachable!(),
            };
            ans += dice.top();
        }
        writeln!(out, , ans).ok();
    }
}
fn main() {
    run();
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::f32::MAX;
use std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};
use std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};
use std::fmt::Display;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
fn show2<T: Display>(vec: &Vec<Vec<T>>) {
    if vec.is_empty() {
        println!();
    }else {
        for l in vec {
            show(l);
        }
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! read_value{
    () => {
        read_line!().trim().parse().ok().unwrap()
    }
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
macro_rules! let_mut_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn count_step(a: i32, b: i32) -> i32 {
    if b == 0 {
        0
    }else if a >= b {
        1 + count_step(b, a % b)
    }else {
        count_step(b, a)
    }
}
fn gcd(a: i32, b: i32) -> i32 {
    if b == 0 {
        a
    }else {
        gcd(b, a % b)
    }
}
fn main() {
    loop {
        let_all!(a: i32, b: i32);
        if a == 0 && b == 0 {
            return
        }
        println!(, gcd(a, b), count_step(a, b));
    }
}"
Rust,"fn main(){
  let n: usize = read();
  let mut sdv: Vec<Vec<i32>> = Vec::new();
  for _ in 0 .. n {
    sdv.push(read_vec());
  }
  let mut dp: Vec<Vec<(f64, i32, usize)>> = vec![vec![(1000000000.0, 0, 0);n]; (1 << n)];
  
  for i in 0 .. n {
    dp[1 << i][i] = (0f64, sdv[i][2], 16usize);
  }
  
  for s in 1 .. (1 << n) {
    for i in 0 .. n {
      if s & (1 << i) > 0 {
        for j in 0 .. n {
          if s & (1 << j) == 0 {
            let &(ot, _, _) = &dp[s|(1 << j)][j];
            let &(ct, cc, _) = &dp[s][i];
            let nt = time((sdv[i][1] - sdv[j][1]).abs(), cc) + ct; 
            if ot > nt {
              dp[s|(1 << j)][j] = (nt, cc + sdv[j][2], i);
            }
          }
        }
      }
    }
  }
  
  let mut ti: usize = 16;
  let mut tt: f64 = 1000000000.0;
  let mut ts: usize = (1 << n) - 1;
  
  for i in 0 .. n {
    let &(t, _, _) = &dp[ts][i];
    if tt > t {ti = i; tt = t}
  }
  let mut ans: Vec<i32> = Vec::new();
  ans.push(sdv[ti][0]);
  
  loop {
    let &(_, _, i) = &dp[ts][ti];
    if i == 16 { break; }
    ts = ts & !(1 << ti);
    ti = i;
    ans.push(sdv[ti][0]);
  }
  for i in 0 .. n {
    if i == n-1 {
      println!(, ans[n-1-i]);
    } else {
      print!(, ans[n-1-i]);
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn time(l: i32, c: i32) -> f64 {
  (l as f64) * (70.0 + (c as f64) * 20.0) / 2000.0
}"
Rust,"/*input
134
4330
34808
98792
0
*/
fn read_line() -> String {
    let mut return_ = format!();
    std::io::stdin().read_line(&mut return_).ok();
    return_
}
fn main() {
    let mut prime_list: [bool; 1000001] = [true; 1000001];
    let mut multiple;
    prime_list[0] = false;
    for i in 2..1000001 {
        if prime_list[i] {
            multiple = i.pow(2);
            while multiple < 1000001 {
                prime_list[multiple as usize] = false;
                multiple = multiple + i;
            }
        }
    }
    /*
    Let A be an array of Boolean values, indexed by integers 2 to n, initially all set to true.
    for i = 2, 3, 4, ..., not exceeding âˆšn:
      if A[i] is true:
        for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n:
          A[j] := false.
    */
    let mut input: u32;
    let mut total: u32;
    loop {
        input = read_line().trim().parse().expect();
        if input == 0 {
            break;
        }
        /*
        for i in range(num
        if num % 2 != 0:
            print(num, 'not even'); break
        if i in primes and (num - i) in primes:
            print(i, '+', num - i)
        */
        total = 0;
        
        for i in 2..((input / 2) + 1) {
            if prime_list[i as usize] && prime_list[(input - i) as usize] {
                total = total + 1;
            }
        }
        println!(, total);
    }
}"
Rust,"#![allow(non_snake_case)]                                                   
use std::cmp::Ordering;   
use std::io::{stdin, BufRead, BufReader};
use std::f64;
fn main(){
    let input = BufReader::new(stdin());
    let mut V:Vec<i32> = Vec::new();
    for line in input.lines() {
        let values: Vec<i32> = line.unwrap()
            .split_whitespace()
            .filter_map(|x| x.parse::<i32>().ok())
            .collect();
        let mut d=values[0];
        let mut res=0;
        
        while d<600{
            res=res+(values[0]*(d*d));
            d=d+values[0];
        }
        println!(,res);
    }
    
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"fn main(){
  loop {
    let xy: Vec<usize> = read_vec();
    let x = xy[0];
    let y = xy[1];
    if x == 0 && y == 0 { break; }
    let mut fv: Vec<Vec<usize>> = Vec::new();
    for _ in 0 .. y {
      fv.push(read_vec());
    }
    
    let mut dp: Vec<Vec<usize>> = vec![vec![0;x];y];
    for i in 0 .. x {
      if fv[0][i] != 1 { dp[0][i] = 1; }
    }
    for i in 1 .. y {
      for j in 0 .. x {
        if fv[i][j] == 0 {
          if j > 0 && fv[i-1][j-1] == 0 {
            dp[i][j] += dp[i-1][j-1];
          }
          if fv[i-1][j] == 0 {
            dp[i][j] += dp[i-1][j];
          }
          if j + 1 < x && fv[i-1][j+1] == 0 {
            dp[i][j] += dp[i-1][j+1];
          }
          if i > 1 && fv[i-2][j] == 2 {
            dp[i][j] += dp[i-2][j];
          }
        } else if fv[i][j] == 2 {
          if fv[i-1][j] == 0 {
            dp[i][j] += dp[i-1][j];
          }
          if i > 1 && fv[i-2][j] == 2 {
            dp[i][j] += dp[i-2][j];
          }
        }
      }
    }
    
    let mut ans: usize = 0;
    for i in 0 .. x {
      ans += dp[y-1][i];
    }
    if y > 1 {
      for i in 0 .. x {
        if fv[y-2][i] == 2 {
          ans += dp[y-2][i];
        }
      }
    }
    println!(, ans);
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"use std::cmp::min;
use std::io;
use std::io::prelude::*;
use std::iter::repeat;
fn main() {
    let mut stdin = io::stdin();
    let mut buf = String::new();
    stdin.read_to_string(&mut buf);
    let mut iter = buf.split_whitespace();
    loop {
        let a: usize = iter.next().unwrap().parse().unwrap();
        let b: usize = iter.next().unwrap().parse().unwrap();
        if (a, b) == (0, 0) {
            break;
        }
        let n: usize = iter.next().unwrap().parse().unwrap();
        let c: Vec<(usize, usize)> = (0..n)
            .map(|_| {
                (
                    iter.next().unwrap().parse().unwrap(),
                    iter.next().unwrap().parse().unwrap(),
                )
            })
            .collect();
        let mut path: Vec<Vec<u64>> = repeat(repeat(0).take(b + 1).collect())
            .take(a + 1)
            .collect();
        path[1][1] = 1;
        for d in 3..(a + b + 1) {
            for x in 1..min(d, a + 1) {
                let y = d - x;
                if y > b || c.contains(&(x, y)) {
                    continue;
                }
                path[x][y] = path[x-1][y] + path[x][y-1];
            }
        }
        println!(, path[a][b]);
    }
}"
Rust,"extern crate core;
use std::fmt;
use std::cmp::{Ordering, min, max};
use std::fmt::{Display, Error, Formatter};
use std::collections::{VecDeque, BinaryHeap, BTreeMap};
use std::f32::MAX;
fn show<T: Display>(vec: &Vec<T>) {
    if vec.is_empty() {
        println!();
    }else {
        print!(, vec[0]);
        for i in 1 .. vec.len() {
            print!(, vec[i]);
        }
        println!();
    }
}
macro_rules! read_line{
    () => {{
        let mut line = String::new();
        std::io::stdin().read_line(&mut line).ok();
        line
    }};
    (delimiter: ' ') => {
        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (delimiter: $p:expr) => {
        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()
    };
    (' ') => {
        read_line!(delimiter: ' ')
    };
    ($delimiter:expr) => {
        read_line!(delimiter: $delimiter)
    };
    (' '; $ty:ty) => {
        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
    ($delimiter:expr; $ty:ty) => {
        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()
    };
}
macro_rules! let_all {
    ($($n:ident:$t:ty),*) => {
        let line = read_line!(delimiter: ' ');
        let mut iter = line.iter();
        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*
    };
}
fn step(mut num: usize) -> usize {
    let mut digits = Vec::with_capacity(4);
    while num != 0 {
        digits.push(num % 10);
        num /= 10;
    }
    for _ in digits.len() .. 4 {
        digits.push(0);
    }
    digits.sort();
    let mut l = 0;
    let mut s = 0;
    for i in 0 .. 4 {
        l = l * 10 + digits[3 - i];
        s = s * 10 + digits[i];
    }
    l - s
}
fn solve(num: usize, memo: &mut Vec<i32>) -> i32 {
    match memo[num] {
        -1 => {
            let res = solve(step(num), memo) + 1;
            memo[num] = res;
            res
        }
        cache => cache
    }
}
fn main() {
    let mut memo = vec![-1; 10000];
    memo[6174] = 0;
    loop {
        let_all!(n: usize);
        if n == 0 {
            return
        }
        if step(n) == 0 {
            println!();
        }else {
            println!(, solve(n, &mut memo));
        }
    }
}"
Rust,"use std::collections::BTreeSet;
use std::fmt::Debug;
use std::str::FromStr;
fn read_line<T>() -> Vec<T>
where
    T: FromStr,
    <T as FromStr>::Err: Debug,
{
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim()
        .split_whitespace()
        .map(|c| T::from_str(c).unwrap())
        .collect()
}
fn sub() -> bool {
    let datas: Vec<usize> = read_line();
    let n = datas[0];
    if n == 0 {
        return false;
    }
    let mut cards0 = BTreeSet::new();
    for _i in 0..n {
        let datas: Vec<u32> = read_line();
        cards0.insert(datas[0]);
    }
    let mut cards1 = BTreeSet::new();
    for i in 1..2 * n + 1 {
        let i_u32 = i as u32;
        if !cards0.contains(&i_u32) {
            cards1.insert(i_u32);
        }
    }
    let mut cardss = vec![&mut cards0, &mut cards1];
    let mut ba = 0u32;
    'fin: loop {
        for cards in &mut cardss {
            ba = {
                let val = cards.iter().find(|&card| card > &ba);
                if val == None {
                    ba = 0u32;
                    continue;
                }
                *val.unwrap()
            };
            cards.remove(&ba);
            if cards.is_empty() {
                break 'fin;
            }
        }
    }
    println!(, cardss[1].len());
    println!(, cardss[0].len());
    return true;
}
fn main() {
    loop {
        if !sub() {
            break;
        }
    }
}"
Rust,"/**
*  _           _                 __                            _   _ _   _                                 _                    _                  _
* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |
* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___
* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|
* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\
* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/
*                                                  | |                                                                           | |   | |
*                                                  |_|                                                                           |_|   |_|
*
* https:
*/
#[allow(unused_imports)]
use std::cmp::{max, min, Ordering};
#[allow(unused_imports)]
use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
#[allow(unused_imports)]
use std::iter::FromIterator;
#[allow(unused_imports)]
use std::io::{stdin, stdout, BufWriter, Read, Write};
mod util {
    use std::io::{stdin, stdout, BufWriter, StdoutLock};
    use std::str::FromStr;
    use std::fmt::Debug;
    #[allow(dead_code)]
    pub fn line() -> String {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.trim().to_string()
    }
    #[allow(dead_code)]
    pub fn chars() -> Vec<char> {
        line().chars().collect()
    }
    #[allow(dead_code)]
    pub fn gets<T: FromStr>() -> Vec<T>
    where
        <T as FromStr>::Err: Debug,
    {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.split_whitespace()
            .map(|t| t.parse().unwrap())
            .collect()
    }
    #[allow(dead_code)]
    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {
        let out = stdout();
        let writer = BufWriter::new(out.lock());
        f(writer)
    }
}
#[allow(unused_macros)]
macro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }
#[allow(unused_macros)]
macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) ,  ) ,* ) , $ ( $ a ) ,* ) ; } }
const BIG_STACK_SIZE: bool = true;
#[allow(dead_code)]
fn main() {
    use std::thread;
    if BIG_STACK_SIZE {
        thread::Builder::new()
            .stack_size(32 * 1024 * 1024)
            .name(.into())
            .spawn(solve)
            .unwrap()
            .join()
            .unwrap();
    } else {
        solve();
    }
}
#[derive(Eq, PartialEq, Clone, Debug)]
pub struct Rev<T>(pub T);
impl<T: PartialOrd> PartialOrd for Rev<T> {
    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {
        other.0.partial_cmp(&self.0)
    }
}
impl<T: Ord> Ord for Rev<T> {
    fn cmp(&self, other: &Rev<T>) -> Ordering {
        other.0.cmp(&self.0)
    }
}
#[allow(dead_code)]
pub const INF: u64 = 1 << 60;
fn solve() {
    let mut buf = String::new();
    stdin().read_to_string(&mut buf).unwrap();
    let mut iter = buf.split_whitespace();
    loop {
        let n: usize = iter.next().unwrap().parse().unwrap();
        let k: usize = iter.next().unwrap().parse().unwrap();
        if n == 0 && k == 0 {
            break;
        }
        let mut g = vec![HashMap::new(); n];
        for _ in 0..k {
            let t: usize = iter.next().unwrap().parse().unwrap();
            if t == 0 {
                let a: usize = iter.next().unwrap().parse().unwrap();
                let b: usize = iter.next().unwrap().parse().unwrap();
                let mut ds = vec![INF; n];
                let mut heap = BinaryHeap::new();
                heap.push(Rev((0, a - 1)));
                while let Some(Rev((c, i))) = heap.pop() {
                    if ds[i] > c {
                        ds[i] = c;
                        if i == b - 1 {
                            break;
                        }
                        for (&t, &d) in g[i].iter() {
                            if ds[t] > c + d {
                                heap.push(Rev((c + d, t)));
                            }
                        }
                    }
                }
                if ds[b - 1] == INF {
                    println!();
                } else {
                    println!(, ds[b - 1]);
                }
            } else {
                let a: usize = iter.next().unwrap().parse().unwrap();
                let b: usize = iter.next().unwrap().parse().unwrap();
                let c: u64 = iter.next().unwrap().parse().unwrap();
                {
                    let x = g[a - 1].entry(b - 1).or_insert(c);
                    *x = min(*x, c);
                }
                {
                    let y = g[b - 1].entry(a - 1).or_insert(c);
                    *y = min(*y, c);
                }
            }
        }
    }
}"
Rust,"use std::io;
fn main(){
    loop{
        let mut buf = String::new();
        let _ = io::stdin().read_line(&mut buf);
        if buf ==  { break; }
        let v: Vec<_> = buf.split_whitespace().collect();
        let a: i32 = v[0].parse().unwrap();
        let b: i32 = v[1].parse().unwrap();
        println!(, (a + b).to_string().len());
    
    }
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"#![allow(non_snake_case)]
#![allow(dead_code)]
fn read_line() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim().to_string()
}
fn read_vec<T: std::str::FromStr>() -> Vec<T> {
    read_line()
        .split_whitespace()
        .map(|e| e.parse().ok().unwrap())
        .collect()
}
fn read_tuple<T: std::str::FromStr + Copy>() -> (T, T, T) {
    let v: Vec<T> = read_vec();
    (v[0], v[1], v[2])
}
fn floyd_warshall(d: &mut Vec<Vec<usize>>) {
    let v = d.len();
    for k in 0..v {
        for i in 0..v {
            for j in 0..v {
                d[i][j] = std::cmp::min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}
fn main() {
    loop {
        let n: usize = read_line().parse().unwrap();
        if n == 0 {
            break;
        }
        let mut info = Vec::new();
        let mut v = 1;
        for i in 0..n {
            let (a, b, c) = read_tuple::<usize>();
            v = std::cmp::max(v, std::cmp::max(a+1, b+1));
            info.push((a, b, c));
        }
        let mut d = vec![vec![usize::max_value() / 3; v]; v];
        for i in 0..v {
            d[i][i] = 0;
        }
        for &(a, b, c) in &info {
            d[a][b] = c;
            d[b][a] = c;
        }
        floyd_warshall(&mut d);
        let total: Vec<usize> = d.iter().map(|dist| dist.iter().sum()).collect();
        let min_dist = *total.iter().min().unwrap();
        println!(, total.iter().position(|&t| t == min_dist).unwrap(), min_dist);
    }
}"
Rust,"fn main(){
  let mut pv: Vec<bool> = vec![true;1000001];
  pv[0] = false;
  pv[1] = false;
  let mut i: usize = 2;
  
  while i * i <= 1000000 {
    if pv[i] {
      let mut j: usize = i * i;
      while j <= 1000000 {
        pv[j] = false;
        j += i;
      }
    }
    i += 1;
  }
  
  loop {
    let nx:Vec<usize> = read_vec();
    let n = nx[0];
    let x = nx[1];
    if n == 0 && x == 0 { break; }
    let mut dp: Vec<bool> = vec![false;x+1];
    dp[0] = true;
    
    for _ in 0 .. n {
      let i: usize = read();
      for j in 0 .. x + 1 {
        if dp[j] && i + j <= x {
          dp[i + j] = true;
        }
      }
    }
    let mut ans = 0;
    
    for i in (1 .. x + 1).rev() {
      if dp[i] && pv[i] {
        ans = i;
        break;
      }
    }
    if ans == 0 {
      println!();
    } else {
      println!(, ans);
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"#![allow(unused_mut, non_snake_case,unused_imports)]
use std::iter;
use std::cmp::{max, min, Ordering};
use std::mem::{swap};
use std::collections::{HashMap,BTreeMap,HashSet,BTreeSet,BinaryHeap,VecDeque};
use std::iter::FromIterator;
macro_rules! input {(source = $s:expr, $($r:tt)*) => {let mut iter = $s.split_whitespace();let mut next = || { iter.next().unwrap() };input_inner!{next, $($r)*}};($($r:tt)*) => {let stdin = std::io::stdin();let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));let mut next = move || -> String{bytes.by_ref().map(|r|r.unwrap() as char).skip_while(|c|c.is_whitespace()).take_while(|c|!c.is_whitespace()).collect()};input_inner!{next, $($r)*}};}
macro_rules! input_inner {($next:expr) => {};($next:expr, ) => {};($next:expr, $var:ident : $t:tt $($r:tt)*) => {let $var = read_value!($next, $t);input_inner!{$next $($r)*}};}
macro_rules! read_value {($next:expr, ( $($t:tt),* )) => {( $(read_value!($next, $t)),* )};($next:expr, [ $t:tt ; $len:expr ]) => {(0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()};($next:expr, chars) => {read_value!($next, String).chars().collect::<Vec<char>>()};($next:expr, usize1) => {read_value!($next, usize) - 1};($next:expr, $t:ty) => {$next().parse::<$t>().expect()};}
/*
 <url:>
 問題文============================================================
 =================================================================
 解説=============================================================
 ================================================================
 */
fn main(){
    input!(A:i32,B:i32,X:i32);
    let mut ans = (1e9) as i32;
    for i in 0..100{
        for j in 0..100{
            let litter = i*1000 + j*500;
            if litter < X {
                continue;
            }
            ans = min(ans,i*A+j*B);
        }
    }
    println!(,ans);
}"
Rust,"use std::cmp::{max, min};
use std::collections::{HashMap, HashSet};
use std::process::exit;
const MOD: usize = 1000000007;
pub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);
impl<R: std::io::Read, W: std::io::Write> IO<R, W> {
    pub fn new(r: R, w: W) -> IO<R, W> {
        IO(r, std::io::BufWriter::new(w))
    }
    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {
        use std::io::Write;
        self.1.write(s.as_bytes()).unwrap();
    }
    pub fn read<T: std::str::FromStr>(&mut self) -> T {
        use std::io::Read;
        let buf = self
            .0
            .by_ref()
            .bytes()
            .map(|b| b.unwrap())
            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')
            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')
            .collect::<Vec<_>>();
        unsafe { std::str::from_utf8_unchecked(&buf) }
            .parse()
            .ok()
            .expect()
    }
    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {
        (0..n).map(|_| self.read()).collect()
    }
    pub fn chars(&mut self) -> Vec<char> {
        self.read::<String>().chars().collect()
    }
}
#[derive(Debug)]
struct UnionFind {
    
    size: Vec<usize>,
    table: Vec<usize>,
}
impl UnionFind {
    fn new(n: usize) -> Self {
        let size = vec![1; n];
        let mut table = vec![0; n];
        for i in 0..n {
            table[i] = i;
        }
        UnionFind { table: table, size }
    }
}
impl UnionFind {
    fn root(&mut self, x: usize) -> usize {
        if self.table[x] == x {
            x
        } else {
            let tmp = self.table[x];
            self.table[x] = self.root(tmp);
            self.table[x]
        }
    }
    fn same(&mut self, a: usize, b: usize) -> bool {
        self.root(a) == self.root(b)
    }
    fn union(&mut self, a: usize, b: usize) -> () {
        let a_root = self.root(a);
        let b_root = self.root(b);
        if a_root == b_root {
            return ();
        }
        
        self.table[a_root] = b_root;
        self.size[b_root] += self.size[a_root];
    }
    
    fn size(&mut self, x: usize) -> usize {
        let ri = self.root(x);
        self.size[ri]
    }
}
fn main() {
    let (r, w) = (std::io::stdin(), std::io::stdout());
    let mut sc = IO::new(r.lock(), w.lock());
    'outer: loop {
        let n: usize = sc.read();
        if n == 0 {
            break;
        }
        let mut uf = UnionFind::new(26);
        let mut deg = vec![0; 26];
        let mut alp = HashSet::<usize>::new();
        for _ in 0..n {
            let s: String = sc.read();
            let s = s.as_bytes();
            let start = (s[0] - 'a' as u8) as usize;
            let end = (s[s.len() - 1] - 'a' as u8) as usize;
            alp.insert(start);
            alp.insert(end);
            deg[start] += 1;
            deg[end] -= 1;
            uf.union(start, end);
        }
        for a in &alp {
            if deg[*a] != 0 || uf.size(*a) != alp.len() {
                println!();
                continue 'outer;
            }
        }
        println!();
    }
}"
Rust,"use std::io::stdin;
use std::collections::HashMap;
fn main() {
    let mut s = String::new();
    stdin().read_line(&mut s).unwrap();
    let lines: i32 = s.trim().parse().unwrap();
    for _ in 0..lines {
        let mut s = String::new();
        stdin().read_line(&mut s).unwrap();
        let line = s.trim();
        println!(, calc(line));
    }
}
fn calc(line: &str) -> i32 {
    exec_rpn(sort_to_rpn(tokenize(line)))
}
fn tokenize(line: &str) -> Vec<String> {
    let ops = ['+', '-', '*', '/', '(', ')', '='];
    let mut tokens: Vec<String> = Vec::new();
    let mut after_ops = true;
    for c in line.chars() {
        let is_op = ops.contains(&c);
        if after_ops {
            tokens.push(String::new());
        }
        if !after_ops && is_op {
            tokens.push(String::new());
        }
        let last = tokens.len() - 1;
        tokens[last].push(c);
        after_ops = is_op;
    }
    tokens
}
fn sort_to_rpn(tokens: Vec<String>) -> Vec<String> {
    let mut rpn: Vec<String> = Vec::new();
    let mut buf: Vec<String> = Vec::new();
    let op_priority: HashMap<String, i32> =
        [(, 1), (, 1), (, 2), (, 2)].iter().map(
            |tuple| { (tuple.0.to_string(), tuple.1) }
        ).collect();
    for token in tokens {
        match op_priority.get(&token) {
            Some(priority) => {
                
                loop {
                    match buf.clone().last() {
                        Some(last_token) => {
                            match op_priority.get(last_token) {
                                Some(last_priority) => {
                                    if priority <= last_priority {
                                        rpn.push(buf.pop().unwrap());
                                    } else {
                                        break
                                    }
                                }
                                
                                None => { break }
                            }
                        },
                        None => { break }
                    }
                }
                buf.push(token);
            },
            None => {
                
                match &*token {
                     => {
                        loop {
                            match buf.pop() {
                                Some(v) => rpn.push(v),
                                None => break
                            }
                        }
                    },
                     => buf.push(token),
                     => {
                        loop {
                            let v = buf.pop().unwrap();
                            if &*v ==  {
                                break
                            }
                            rpn.push(v);
                        }
                    },
                    
                    _ => rpn.push(token)
                }
            }
        }
    }
    rpn
}
fn exec_rpn(rpn: Vec<String>) -> i32 {
    let mut buf: Vec<i32> = Vec::new();
    for token in rpn {
        match &*token {
             => {
                let v = buf.pop().unwrap() + buf.pop().unwrap();
                buf.push(v)
            },
             => {
                let v1 = buf.pop().unwrap();
                let v2 = buf.pop().unwrap();
                buf.push(v2 - v1)
            },
             => {
                let v = buf.pop().unwrap() * buf.pop().unwrap();
                buf.push(v)
            },
             => {
                let v1 = buf.pop().unwrap();
                let v2 = buf.pop().unwrap();
                buf.push(v2 / v1)
            },
            _ => buf.push(token.parse().unwrap())
        }
    }
    buf.pop().unwrap()
}"
Rust,"#![allow(non_snake_case)]
use std::cmp::Ordering;
use std::io::{stdin, BufRead, BufReader};
use std::f64;
fn main(){
    let eps=1e-10;
    let pi=f64::consts::PI;
    let input = BufReader::new(stdin());
    for line in input.lines() {
        let values: Vec<f64> = line.unwrap()
            .split_whitespace()
            .filter_map(|x| x.parse::<f64>().ok())
            .collect();
        let x1=values[0];
        let y1=values[1];
        let x2=values[2];
        let y2=values[3];
        let x3=values[4];
        let y3=values[5];
        let xp=values[6];
        let yp=values[7];
        let mut v12=vec![x2-x1,y2-y1];
        let mut v23=vec![x3-x2,y3-y2];
        let mut v31=vec![x1-x3,y1-y3];
        let mut v1p=vec![xp-x1,yp-y1];
        let mut v2p=vec![xp-x2,yp-y2];
        let mut v3p=vec![xp-x3,yp-y3];
        
        if (cross_product(&v12,&v1p)>eps && cross_product(&v23,&v2p)>eps && cross_product(&v31,&v3p)>eps) || (cross_product(&v12,&v1p)<eps && cross_product(&v23,&v2p)<eps && cross_product(&v31,&v3p)<eps){
            println!();
        }
        else{
            println!();
        }
    }
}
fn cross_product(v1:&Vec<f64>,v2:&Vec<f64>)->f64{
    return (v1[0]*v2[1]-v1[1]*v2[0]);
}
fn center_of_circle(v: Vec<f64>) -> (f64,f64,f64){
    let x1=v[0];let x2=v[2];let x3=v[4];let y1=v[1];let y2=v[3];let y3=v[5];
    let mut x0 = (x1*x1+y1*y1)*(y2-y3)+(x2*x2+y2*y2)*(y3-y1)+(x3*x3+y3*y3)*(y1-y2);
    x0=0.5*x0/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    
    let mut y0 = (x1*x1+y1*y1)*(x2-x3)+(x2*x2+y2*y2)*(x3-x1)+(x3*x3+y3*y3)*(x1-x2);
    y0=0.5*y0/(y1*(x2-x3)+y2*(x3-x1)+y3*(x1-x2));
    let mut R=(( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) )*( (x2-x3)*(x2-x3) + (y2-y3)*(y2-y3) )*( (x3-x1)*(x3-x1) + (y3-y1)*(y3-y1) )).sqrt();
    R=R*0.5/(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)).abs();
    return (x0,y0,R);
}
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"use std::cmp;
fn main(){
  loop {
    let n: usize = read();
    if n == 0 { break; }
    let mut mt: Vec<Vec<usize>> = Vec::new();
    
    for _ in 0 .. n {
      mt.push(read_vec());
    }
    
    let m: usize = read();
    
    for _ in 0 .. m {
      mt.push(read_vec());
    }
    
    mt.sort();
    let mut dp: Vec<usize> = vec![1;n+m];
    for i in 1 .. n+m {
      for j in 0 .. i {
        if mt[i][1] > mt[j][1] && mt[i][0] > mt[j][0] {
          dp[i] = cmp::max(dp[i], dp[j]+1);
        }
      }
    }
    
    println!(, dp.iter().max().unwrap());
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"use std::env;
use std::io::*;
use std::str::FromStr;
use std::char;
use std::error::Error;
use std::io::prelude::*;
fn read<T: FromStr>() -> T {
    let stdin = stdin();
    let stdin = stdin.lock();
    let token: String = stdin
        .bytes()
        .map(|c| c.expect() as char) 
        .skip_while(|c| c.is_whitespace())
        .take_while(|c| !c.is_whitespace())
        .collect();
    token.parse().ok().expect()
}
fn main() {
    
    let n: u32 = read();
    
    let mut cnt:u32 = 0;
    while n != cnt {
        let query: String = read();
        let v: Vec<char> = query.chars().collect();
            
            
            let mut i = 0_i32;
            println!(, expr(&v, &mut i));
            
        
        cnt+=1;
    }
}
fn expr(s: &Vec<char>, i: &mut i32) -> i32 {
    let mut val = term(s, i);
    let mut idx = *i as usize;
    
    while idx < s.len() && (s[idx] == '+' || s[idx] == '-') {
        let op = s[idx];
        *i += 1;
        let val2 = term(s, i);
        val = if op == '+' {
            val + val2
        }else {
            val - val2
        };
        idx = *i as usize;
    }
    
    val
}
fn term(s: &Vec<char>, i: &mut i32) -> i32 {
    let mut val = factor(s, i);
    
    let mut idx = *i as usize;
    while idx < s.len() && (s[idx] == '*' || s[idx] == '/') {
        let op = s[idx];
        *i += 1;
        let val2 = factor(s, i);
        val =  if op == '*' {
            val * val2
        } else {
            val / val2
        };
        idx = *i as usize;
    }
    val
}
fn factor(s: &Vec<char>, i: &mut i32) -> i32 {
    let idx = *i as usize;
    if idx < s.len() && s[idx].is_digit(10){
         return number(s, i);
    }
    *i += 1;
    let res = expr(s, i);
    *i += 1;
    res
}
fn number(s: &Vec<char>, i: &mut i32) -> i32 {
    let mut idx = *i as usize;
    
    let mut n: u32 = s[idx].to_digit(10).unwrap();
    
    *i += 1;
    idx = *i as usize;
    while idx < s.len() && s[idx].is_digit(10) {
        
        let m: u32 = s[idx].to_digit(10).unwrap();
        n = n * 10 + m;
        *i += 1;
        idx = *i as usize;
    }
    n as i32
}
/* 参考 
 - http:
 <expr>   ::= <term> [ ('+'|'-') <term> ]*
 <term>   ::= <factor> [ ('*'|'/') <factor> ]*
 <factor> ::= <number> | '(' <expr> ')'
 <number> :== 1つ以上の数字
*/
/* &str型
・文字列を固定する（メモリサイズ）
・スライスで参照できる
・文字列長は不変
   String型
・文字列長は可変
・サイズが可変であるため参照ができない
*/"
Rust,"fn main(){
   let eps: f64 = 0.000000001;
   
   loop {
     let mut buf = String::new();
     if let Ok(c) = std::io::stdin().read_line(&mut buf) {
       
       if c < 2 { break; }
       
       let wr: Vec<usize> = buf.split_whitespace().map(|e| e.parse().unwrap()).collect();
       let w = wr[0] as f64;
       let l: usize = wr.len() - 1;
       let rv: Vec<f64> = (1 .. l+1).map(|i| wr[i] as f64).collect();
       
       let mut dp: Vec<Vec<f64>> = vec![vec![2000.0; l]; 1 << l];
       for i in 0 .. l {
         dp[1 << i][i] = rv[i];
       }
       for s in 1 .. (1 << l) {
         for i in 0 .. l {
           if s & (1 << i) > 0 {
             for j in 0 .. l {
               if s & (1 << j) == 0 {
                 let nw = dp[s][i] + dist(rv[i], rv[j]);
                 dp[s | (1 << j)][j] = if nw < dp[s | (1 << j)][j] { nw } else {dp[s | (1 << j)][j]};
               }
             }
           }
         }
       }
       
       for i in 0 .. l {
           dp[(1<<l)-1][i] += rv[i];
       }
       let mut mnl: f64 = dp[(1<<l)-1][0];
       
       for i in 1 .. l {
           if mnl > dp[(1<<l)-1][i] {
              mnl = dp[(1<<l)-1][i];
           }
       }
       
       println!(, if (w - mnl).abs() < eps || w > mnl {} else {});
     }
   }
}
fn dist(r1: f64, r2: f64) -> f64 {
   2.0 * (r1 * r2).sqrt()
}"
Rust,"fn main(){
    let n=readln();
    for _i in 0..n{
        let a:String=readln();
        let b:String=readln();
        let mut aaa=a.as_bytes();
        let mut bbb=b.as_bytes();
        let mut aa=Vec::new();
        let mut bb=Vec::new();
        for k in 0..aaa.len(){
            aa.push(aaa[k] as i32);
        }
        for k in 0..bbb.len(){
            bb.push(bbb[k] as i32);
        }
        aa.reverse();
        bb.reverse();
        let mut res:Vec<i32>=Vec::new();
        let mut bef=0;
        let mut xx=0;
        if bb.len()<aa.len(){
            xx=bb.len();
        }
        else {
            xx=aa.len();
        }
        for j in 0..xx{
            let tmp=bef+aa[j]+bb[j]-96;
            if tmp>=10{
                res.push(tmp-10);
                bef=1;
            }
            else {
                res.push(tmp);
                bef=0;
            }
        }
        if aa.len()>bb.len(){
            for j in bb.len()..aa.len(){
                let tmp=bef+aa[j]-48;
            
                if tmp>=10{
                    res.push(tmp-10);
                    bef=1;
                }
                else {
                    res.push(tmp);
                    bef=0;
                }
            }
        }
        else if bb.len()>aa.len(){              
              for j in aa.len()..bb.len(){   
                  let tmp=bef+bb[j]-48;
                  if tmp>=10{
                    res.push(tmp-10);
                    bef=1;
                  }
                  else {
                    res.push(tmp);
                  bef=0;
                  }
              }
        }
        if bef==1{
            res.push(1);
        }
        if res.len()>80{
            println!();
        }
        else{
            res.reverse();
            for l in res{
                print!(,l);
            }
            println!();
        }
        
    }
}
fn center_of_circle(v: Vec<f64>) -> (f64,f64,f64){
    let x1=v[0];let x2=v[2];let x3=v[4];let y1=v[1];let y2=v[3];let y3=v[5];
    let mut x0 = (x1*x1+y1*y1)*(y2-y3)+(x2*x2+y2*y2)*(y3-y1)+(x3*x3+y3*y3)*(y1-y2);
    x0=0.5*x0/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    
    let mut y0 = (x1*x1+y1*y1)*(x2-x3)+(x2*x2+y2*y2)*(x3-x1)+(x3*x3+y3*y3)*(x1-x2);
    y0=0.5*y0/(y1*(x2-x3)+y2*(x3-x1)+y3*(x1-x2));
    let mut R=(( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) )*( (x2-x3)*(x2-x3) + (y2-y3)*(y2-y3) )*( (x3-x1)*(x3-x1) + (y3-y1)*(y3-y1) )).sqrt();
    R=R*0.5/(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)).abs();
    return (x0,y0,R);
}
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"#![allow(non_snake_case)]
fn main(){
   let dataset  = readln();
   for d in 0..dataset{
       let mut v:Vec<f64> = readln();
       let res=center_of_circle(v);
       println!(,res.0,res.1,res.2);
    }
}
fn center_of_circle(v: Vec<f64>) -> (f64,f64,f64){
    let x1=v[0];let x2=v[2];let x3=v[4];let y1=v[1];let y2=v[3];let y3=v[5];
    let mut x0 = (x1*x1+y1*y1)*(y2-y3)+(x2*x2+y2*y2)*(y3-y1)+(x3*x3+y3*y3)*(y1-y2);
    x0=0.5*x0/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
    
    let mut y0 = (x1*x1+y1*y1)*(x2-x3)+(x2*x2+y2*y2)*(x3-x1)+(x3*x3+y3*y3)*(x1-x2);
    y0=0.5*y0/(y1*(x2-x3)+y2*(x3-x1)+y3*(x1-x2));
    let mut R=(( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) )*( (x2-x3)*(x2-x3) + (y2-y3)*(y2-y3) )*( (x3-x1)*(x3-x1) + (y3-y1)*(y3-y1) )).sqrt();
    R=R*0.5/(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)).abs();
    return (x0,y0,R);
}
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"#![allow(unused_mut, non_snake_case,unused_imports)]
use std::iter;
use std::cmp::{max, min, Ordering};
use std::mem::{swap};
use std::collections::{HashMap,BTreeMap,HashSet,BTreeSet,BinaryHeap,VecDeque};
use std::iter::FromIterator;
macro_rules! input {(source = $s:expr, $($r:tt)*) => {let mut iter = $s.split_whitespace();let mut next = || { iter.next().unwrap() };input_inner!{next, $($r)*}};($($r:tt)*) => {let stdin = std::io::stdin();let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));let mut next = move || -> String{bytes.by_ref().map(|r|r.unwrap() as char).skip_while(|c|c.is_whitespace()).take_while(|c|!c.is_whitespace()).collect()};input_inner!{next, $($r)*}};}
macro_rules! input_inner {($next:expr) => {};($next:expr, ) => {};($next:expr, $var:ident : $t:tt $($r:tt)*) => {let $var = read_value!($next, $t);input_inner!{$next $($r)*}};}
macro_rules! read_value {($next:expr, ( $($t:tt),* )) => {( $(read_value!($next, $t)),* )};($next:expr, [ $t:tt ; $len:expr ]) => {(0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()};($next:expr, chars) => {read_value!($next, String).chars().collect::<Vec<char>>()};($next:expr, usize1) => {read_value!($next, usize) - 1};($next:expr, $t:ty) => {$next().parse::<$t>().expect()};}
/*
 <url:>
 問題文============================================================
 =================================================================
 解説=============================================================
 ================================================================
 */
fn main(){
    input!(a:i64,n:i64,m:i64);
    let mut ans = 0;
    for y  in 1..100{
        let mut x = 1;
        for _ in 0..n{
            x *= (y+a);
            if x > m{
                break;
            }
        }
        if x > m{
            continue;
        }
        let mut t = 0;
        while x != 0{
            t += x%10;
            x/=10;
        }
        if t == y{
            ans+=1;
        }
    }
    println!(,ans);
}"
Rust,"use std::collections::HashSet;
fn main(){
  loop {
    let n: usize = read();
    if n == 0 { break; }
    let mut adj: Vec<Vec<usize>> = vec![vec![0;26];26];
    let mut set: HashSet<usize> = HashSet::new();
    let mut uf: UnionFind = UnionFind::new(26);
    
    for _ in 0 .. n {
      let s:String = read();
      let h = s.chars().next().unwrap() as usize - 97;
      let t = s.chars().last().unwrap() as usize - 97;
      adj[h][t] += 1;
      set.insert(h);
      set.insert(t);
      uf.unite(h, t);
    }
    let mut link = true;
    let sl = set.len();
    
    for i in set.iter() {
      if sl != uf.size(*i) {
        link = false;
        break;
      }
    }
    let mut eg = true;
    for i in 0 .. 26 {
      let mut sr = 0;
      for j in 0 .. 26 {
        sr += adj[i][j];
      }
      let mut sc = 0;
      for j in 0 .. 26 {
        sc += adj[j][i];
      }
      if sr != sc {
        eg = false;
        break;
      }
    }
    
    println!(, if link && eg {  } else {  });
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
#[derive(Debug)]
struct UnionFind {
  p: Vec<isize>
}
#[allow(dead_code)]
impl UnionFind {
  fn new(n: usize) -> UnionFind {
    UnionFind {
      p: vec![-1;n]
    }
  }
  fn root(&mut self, a: usize) -> usize {
    let u = self.p[a];
    if u < 0 { a }
    else {
      let rt = self.root( u as usize);
      self.p[a] = rt as isize;
      rt
    }
  }
  fn unite(&mut self, a: usize, b: usize){
    let ra = self.root(a);
    let rb = self.root(b);
    if ra != rb {
      if self.p[ra] < self.p[rb] {
        self.p[ra] = self.p[ra] + self.p[rb];
        self.p[rb] = ra as isize;
      } else {
        self.p[rb] = self.p[ra] + self.p[rb];
        self.p[ra] = rb as isize;
      }
    }
  }
  fn same(&mut self, a: usize, b:usize) -> bool {
    self.root(a) == self.root(b)
  }
  fn size(&mut self, a: usize) -> usize {
    let ra = self.root(a);
    (-1 * self.p[ra]) as usize
  }
}"
Rust,"use std::fmt;
use std::io::stdin;
use std::io::BufRead;
use std::str;
use std::str::FromStr;
use std::vec::Vec;
use std::collections::{VecDeque, HashSet};
fn main() {
    let stdin = stdin();
    let mut scan = InputScanner::new(stdin.lock(),256);
    let mut answer:Vec<i64> = Vec::new();
    loop {
        let n:usize = scan.next();
        let m:usize = scan.next();
        if n == 0 || m == 0 {
            break;
        }
        let abc = {
            let mut abc = Vec::new();
            for _ in 0..3 {
                let n: usize = scan.next();
                abc.push((0..n).map(|_| scan.next::<usize>()).collect::<Vec<usize>>());
            }
            abc
        };
        let mut queue = VecDeque::new();
        let mut s:HashSet<(u16,u16,u16)> = HashSet::new();
        let (ha,hb,hc) = calc_hash(&abc[0],&abc[1],&abc[2]);
        queue.push_back((ha,hb,hc));
        s.insert((ha,hb,hc));
        let mut count = 0;
        let mut found = false;
        'search: while queue.len() > 0 && count <= m {
            let mut current = queue.drain(0..).collect::<VecDeque<_>>();
            while let Some((ha,hb,hc)) = current.pop_front() {
                let abc = abc_from_hash(ha,hb,hc);
                if abc[0].len() == n || abc[2].len() == n {
                    found = true;
                    break 'search;
                }
                for &(i,d) in &[(0,1),(1,-1),(1,1),(2,-1)] {
                    let i = i as i64;
                    if abc[i as usize].len() > 0 {
                        let top = abc[i as usize][abc[i as usize].len()-1];
                        if abc[(i+d) as usize].len() == 0 || abc[(i+d) as usize][abc[(i+d) as usize].len()-1] < top {
                            let mut abc = abc.iter().map(|c| c.clone()).collect::<Vec<Vec<usize>>>();
                            abc[i as usize].pop();
                            abc[(i+d) as usize].push(top);
                            let h = calc_hash(&abc[0],&abc[1],&abc[2]);
                            if !s.contains(&h) {
                                s.insert(h);
                                queue.push_back(h);
                            }
                        }
                    }
                }
            }
            count += 1;
        }
        if found {
            answer.push(count as i64);
        } else {
            answer.push(-1);
        }
    }
    println!(,answer.into_iter().map(|a| format!(,a)).collect::<Vec<String>>().join());
}
fn calc_hash(a:&Vec<usize>,b:&Vec<usize>,c:&Vec<usize>) -> (u16,u16,u16) {
    let mut ha:u16 = 0;
    let mut hb:u16 = 0;
    let mut hc:u16 = 0;
    for n in a {
        ha |= 1 << *n;
    }
    for n in b {
        hb |= 1 << *n;
    }
    for n in c {
        hc |= 1 << *n;
    }
    (ha,hb,hc)
}
fn abc_from_hash(ha:u16,hb:u16,hc:u16) -> Vec<Vec<usize>> {
    let mut abc:Vec<Vec<usize>> = Vec::new();
    abc.push(Vec::new());
    let mut ha = ha;
    while ha > 0 {
        abc[0].push(ha.trailing_zeros() as usize);
        ha = ha & (ha - 1);
    }
    abc.push(Vec::new());
    let mut hb = hb;
    while hb > 0 {
        abc[1].push(hb.trailing_zeros() as usize);
        hb = hb & (hb - 1);
    }
    abc.push(Vec::new());
    let mut hc = hc;
    while hc > 0 {
        abc[2].push(hc.trailing_zeros() as usize);
        hc = hc & (hc - 1);
    }
    abc
}
struct InputScanner<R: BufRead> {
	reader: R,
	buf: Vec<u8>, 
	pos: usize,   
}
impl<R: BufRead> InputScanner<R> {
	fn new(reader: R, capacity: usize) -> Self {
		InputScanner {
			reader: reader,
			buf: Vec::with_capacity(capacity),
			pos: 0,
		}
	}
	#[inline]
	fn next<T: FromStr>(&mut self) -> T
	where
		T::Err: fmt::Debug,
	{
		if self.buf.is_empty() {
			self._read_next_line();
		}
		let mut start = None;
		loop {
			match (self.buf[self.pos], start.is_some()) {
				(b' ', true) | (b'\\n', true) | (b'\\r', true) => break,
				(_, true) | (b' ', false) => self.pos += 1,
				(b'\\n', false) | (b'\\r', false) => self._read_next_line(),
				(_, false) => start = Some(self.pos),
			}
		}
		let target = &self.buf[start.unwrap()..self.pos];
		unsafe { str::from_utf8_unchecked(target) }.parse().unwrap()
	}
	#[inline]
	fn _read_next_line(&mut self) {
		self.pos = 0;
		self.buf.clear();
		if self.reader.read_until(b'\\n', &mut self.buf).unwrap() == 0 {
			panic!();
		}
	}
}"
Rust,"fn solve() {
    loop {
        let n: usize = read();
        if n == 0 {
            break;
        }
        let a: Vec<i64> = (0..n).map(|_| read::<i64>()).collect();
        let mut s = a[0];
        let mut ans = s;
        for i in 1..n {
            s = max(s + a[i], a[i]);
            ans = max(ans, s);
        }
        println!(, ans);
    }
}
fn main() {
    let stack_size = 104_857_600;
    let thd = std::thread::Builder::new().stack_size(stack_size);
    thd.spawn(|| solve()).unwrap().join().unwrap();
}
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
use std::collections::{BinaryHeap, HashMap, HashSet};
#[allow(unused_imports)]
use std::process::exit;
#[allow(dead_code)]
const MOD: usize = 1000000007;
fn read<T: std::str::FromStr>() -> T {
    use std::io::Read;
    let stdin = std::io::stdin();
    let stdin = stdin.lock();
    let token: String = stdin
        .bytes()
        .map(|c| c.expect() as char)
        .skip_while(|c| c.is_whitespace())
        .take_while(|c| !c.is_whitespace())
        .collect();
    token.parse().ok().expect()
}"
Rust,"/**
 *  _           _                 __                            _   _ _   _                                 _                    _                  _
 * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |
 * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___
 * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|
 * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\
 * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/
 *                                                  | |                                                                           | |   | |
 *                                                  |_|                                                                           |_|   |_|
 *
 * https:
 */
#[allow(unused_imports)]
use std::cmp::{max, min, Ordering};
#[allow(unused_imports)]
use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
#[allow(unused_imports)]
use std::iter::FromIterator;
#[allow(unused_imports)]
use std::io::{stdin, stdout, BufWriter, Write};
mod util {
    use std::io::{stdin, stdout, BufWriter, StdoutLock};
    use std::str::FromStr;
    use std::fmt::Debug;
    #[allow(dead_code)]
    pub fn line() -> String {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.trim().to_string()
    }
    #[allow(dead_code)]
    pub fn chars() -> Vec<char> {
        line().chars().collect()
    }
    #[allow(dead_code)]
    pub fn gets<T: FromStr>() -> Vec<T>
    where
        <T as FromStr>::Err: Debug,
    {
        let mut line: String = String::new();
        stdin().read_line(&mut line).unwrap();
        line.split_whitespace()
            .map(|t| t.parse().unwrap())
            .collect()
    }
    #[allow(dead_code)]
    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {
        let out = stdout();
        let writer = BufWriter::new(out.lock());
        f(writer)
    }
}
#[allow(unused_macros)]
macro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }
#[allow(unused_macros)]
macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) ,  ) ,* ) , $ ( $ a ) ,* ) ; } }
fn search((from, to): (usize, usize), m: usize, s: &[Vec<usize>; 3]) -> Option<usize> {
    let mut s = s.to_vec();
    let x = s[from].pop().unwrap();
    s[to].push(x);
    let mut last = (from, to);
    'outer: for i in 1..m + 1 {
        if (s[0].is_empty() && s[1].is_empty()) || (s[1].is_empty() && s[2].is_empty()) {
            return Some(i);
        }
        for &(f, t) in &[(0, 1), (1, 2), (1, 0), (2, 1)] {
            if last != (t, f) && !s[f].is_empty()
                && s[t].last()
                    .map(|x| x < s[f].last().unwrap())
                    .unwrap_or(true)
            {
                let x = s[f].pop().unwrap();
                s[t].push(x);
                last = (f, t);
                continue 'outer;
            }
        }
    }
    None
}
#[allow(dead_code)]
fn main() {
    loop {
        let (n, m) = get!(usize, usize);
        if n == 0 && m == 0 {
            return;
        }
        let mut s1 = util::gets::<usize>();
        s1.remove(0);
        let mut s2 = util::gets::<usize>();
        s2.remove(0);
        let mut s3 = util::gets::<usize>();
        s3.remove(0);
        if s1.len() == n || s3.len() == n {
            println!(, 0);
            continue;
        }
        let s = [s1, s2, s3];
        let mut ans = None;
        for &(f, t) in &[(0, 1), (1, 2), (1, 0), (2, 1)] {
            if !s[f].is_empty()
                && s[t].last()
                    .map(|x| x < s[f].last().unwrap())
                    .unwrap_or(true)
            {
                if let Some(x) = search((f, t), m, &s) {
                    ans = Some(ans.map(|y| min(x, y)).unwrap_or(x));
                }
            }
        }
        if let Some(x) = ans {
            println!(, x);
        } else {
            println!(, -1);
        }
    }
}"
Rust,"fn main(){
  loop {
    let n: usize = read();
    if n == 0 { break; }
    let mut fd: Vec<(String, usize, usize)> = Vec::new();
    for _ in 0 .. n {
      let buf: Vec<String> = read_vec();
      fd.push((buf[0].parse().unwrap(), buf[1].parse().unwrap(), buf[2].parse().unwrap()));
    }
    let mut iv: Vec<usize> = (0..n).collect();
    let mut miv: Vec<usize> = vec![0;n];
    let mut mcg: usize = 100000;
    if let Some(cg) = calc_cg(&fd, &iv) {
      if mcg > cg {
        mcg = cg;
        miv = iv.clone();
      }
    }
    
    while next_permutation(&mut iv) {
      if let Some(cg) = calc_cg(&fd, &iv) {
        if mcg > cg {
          mcg = cg;
          miv = iv.clone();
        }
      }
    }
    for i in miv {
      println!(, fd[i].0);
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn next_permutation(v: &mut Vec<usize>) -> bool {
  let ln = v.len();
  let mut u: usize = ln;
  for i in (0 .. ln-1).rev() {
    if v[i] < v[i+1] { u = i; break;}
  }
  if u == ln { false }
  else {
    let mut w: usize = u + 1;
    for i in (u+1 .. ln).rev() {
      if v[i] > v[u] { w = i; break; }
    }
    v.swap(u, w);
    u += 1;
    w = ln - 1;
    while u < w {
      v.swap(u, w);
      u += 1;
      w -= 1;
    }
    true
  }
}
fn calc_cg(fd: &Vec<(String, usize, usize)>, iv: &Vec<usize>) -> Option<usize> {
  let mut cg: Option<usize> = Some(0);
  let mut aw: usize = 0;
  
  for (i, &j) in iv.iter().enumerate().rev() {
    if fd[j].2 >= aw {
      aw += fd[j].1;
      cg = Some (cg.unwrap() + (i + 1) * fd[j].1);
    } else {
      cg = None;
      break;
    }
  }
  
  cg
}"
Rust,"use std::ops::Sub;
use std::fmt::Debug;
fn read_line() -> String {
    let mut buffer = String::new();
    std::io::stdin().read_line(&mut buffer).expect();
    buffer
}
fn read_values<T: std::str::FromStr>() -> Vec<T> {
    read_line().trim().split(' ').map(|x| x.parse().ok().expect()).collect::<Vec<T>>()
}
fn read_multi_line<T: std::str::FromStr>(count: usize) -> Vec<T> {
    let mut buffer = String::new();
    let mut vec = Vec::with_capacity(count);
    for i in 0 .. count {
        std::io::stdin().read_line(&mut buffer).expect();
        vec.push(buffer.parse().ok().expect());
    }
    vec
}
macro_rules! ignore {
    ($id:ident) => {};
}
macro_rules! assign {
    (let $($id:ident),* = $value:expr) => {
        let ($($id), *) = {
            let mut iter = $value.into_iter();
            ($({ignore!($id); iter.next().unwrap()}), *)
        }
    };
}
fn inspect<T: Debug>(vec: &Vec<T>) -> () {
    if let Some(first) = vec.first() {
        println!(, first);
        for i in 1..vec.len() {
            println!(, vec[i]);
        }
        println!();
    }else {
        println!();
    }
}
#[derive(Copy, Clone, Debug)]
struct Angle {
    sin: f64,
    cos: f64
}
impl Angle {
    fn from_degree(degree: f64) -> Angle {
        if degree > 180f64 {Angle::from_degree(degree - 360f64)} else if degree < -180f64 {Angle::from_degree(degree + 360f64)} else {
            let rad = degree / 180f64 * std::f64::consts::PI;
            Angle { sin: rad.sin(), cos: rad.cos() }
        }
    }
}
impl Sub for Angle {
    type Output = Angle;
    fn sub(self, rhs: Self) -> Self::Output {
        Angle{sin: self.sin * rhs.cos - self.cos * rhs.sin, cos: self.cos * rhs.cos + self.sin * rhs.sin}
    }
}
fn main() {
    let radius = 6378.1f64;
    loop {
        assign!(let a, b, c, d = read_values::<f64>());
        if a == -1f64 && b == -1f64 && c == -1f64 && d == -1f64 {break;}
        let h1 = Angle::from_degree(a);
        let h2 = Angle::from_degree(c);
        let v1 = Angle::from_degree(b);
        let v2 = Angle::from_degree(d);
        let rad = (h1.sin * h2.sin + h1.cos * h2.cos * Angle::from_degree((b - d).abs()).cos).acos();
        println!(, (rad * radius + 0.5) as i32);
    }
}"
Rust,"use std::io::prelude::*;
use std::io;
#[derive(PartialEq)]
enum Direction {
  TOP,
  BOTTOM,
  NORTH,
  EAST,
  SOUTH,
  WEST,
}
struct Dice {
  one_d: Direction,
  two_d: Direction,
  three_d: Direction,
}
use Direction::*;
impl Dice {
  fn new() -> Dice {
    Dice { one_d: TOP, two_d: SOUTH, three_d: EAST }
  }
  
  fn top(&self) -> u32 {
    if self.one_d == TOP {
      1
    } else if self.one_d == BOTTOM {
      6
    } else if self.two_d == TOP {
      2
    } else if self.two_d == BOTTOM {
      5
    } else if self.three_d == TOP {
      3
    } else if self.three_d == BOTTOM {
      4
    } else {
      unreachable!()
    }
  }
  fn north(&mut self) {
    self.one_d = Dice::north_roll(&self.one_d);
    self.two_d = Dice::north_roll(&self.two_d);
    self.three_d = Dice::north_roll(&self.three_d);
  }
  
  fn north_roll(d: &Direction) -> Direction {
    match *d {
      TOP => NORTH,
      BOTTOM => SOUTH,
      NORTH => BOTTOM,
      EAST => EAST,
      SOUTH => TOP,
      WEST => WEST,
    }
  }
  
  fn east(&mut self) {
    self.one_d = Dice::east_roll(&self.one_d);
    self.two_d = Dice::east_roll(&self.two_d); 
    self.three_d = Dice::east_roll(&self.three_d);
  }
  
  fn east_roll(d: &Direction) -> Direction {
    match *d {
      TOP => EAST,
      BOTTOM => WEST,
      NORTH => NORTH,
      EAST => BOTTOM,
      SOUTH => SOUTH,
      WEST => TOP,
    }
  }
  fn south(&mut self) {
    self.one_d = Dice::south_roll(&self.one_d);
    self.two_d = Dice::south_roll(&self.two_d);
    self.three_d = Dice::south_roll(&self.three_d);
  }
  
  fn south_roll(d: &Direction) -> Direction {
    match *d {
      TOP => SOUTH,
      BOTTOM => NORTH,
      NORTH => TOP,
      EAST => EAST,
      SOUTH => BOTTOM,
      WEST => WEST,
    }
  }
  
  fn west(&mut self) {
    self.one_d = Dice::west_roll(&self.one_d);
    self.two_d = Dice::west_roll(&self.two_d);
    self.three_d = Dice::west_roll(&self.three_d);
  }
  
  fn west_roll(d: &Direction) -> Direction {
    match *d {
      TOP => WEST,
      BOTTOM => EAST,
      NORTH => NORTH,
      EAST => TOP,
      SOUTH => SOUTH,
      WEST => BOTTOM,
    }
  }
  fn right(&mut self) {
      self.one_d = Dice::right_roll(&self.one_d);
      self.two_d = Dice::right_roll(&self.two_d);
      self.three_d = Dice::right_roll(&self.three_d);
  }
  fn right_roll(d: &Direction) -> Direction {
    match *d {
      TOP => TOP,
      BOTTOM => BOTTOM,
      NORTH => EAST,
      EAST => SOUTH,
      SOUTH => WEST,
      WEST => NORTH,
    }
  }
  fn left(&mut self) {
      self.one_d = Dice::left_roll(&self.one_d);
      self.two_d = Dice::left_roll(&self.two_d);
      self.three_d = Dice::left_roll(&self.three_d);
  }
  fn left_roll(d: &Direction) -> Direction {
    match *d {
      TOP => TOP,
      BOTTOM => BOTTOM,
      NORTH => WEST,
      EAST => NORTH,
      SOUTH => EAST,
      WEST => SOUTH,
    }
  }
}
fn sum_dice_roll(handle: &mut std::io::StdinLock, times: u32) -> u32 {
  let mut sum: u32 = 0;
  let mut dice = Dice::new();
  sum += dice.top();
  let mut buffer = String::new();
  for _ in 0..times {
    buffer.clear();
    handle.read_line(&mut buffer).unwrap();
    let input = buffer.trim();
    match input {
       => dice.north(),
       => dice.east(),
       => dice.south(),
       => dice.west(),
       => dice.right(),
       => dice.left(),
      _ => unreachable!(),
    }
    sum += dice.top();
  }
  sum
}
fn main() {
  let stdin = io::stdin();
  let mut handle = stdin.lock();
  
  loop {
    let mut buffer = String::new();
    handle.read_line(&mut buffer).unwrap();
    let n = buffer.trim().parse::<u32>().unwrap();
    if n == 0 {
      break;
    } else {
      let result = sum_dice_roll(&mut handle, n);
      println!(, result);
    }
  }
}"
Rust,"use std::collections::VecDeque;
use std::collections::HashMap;
fn main(){
  let dv: Vec<i32> = vec![-4, 1, 4, -1];
  
  let mut que: VecDeque<(Vec<u32>, i32, u32)> = VecDeque::new();
  let mut mp: HashMap<u32, u32> = HashMap::new();
  let v0: Vec<u32> = vec![0, 1, 2, 3, 4, 5, 6, 7];
  
  mp.insert(hash(&v0), 0);
  que.push_back((v0, 0, 0));
    
  loop {
    match que.pop_front() {
      Some((v, i, c)) => {
        for d in &dv {
          let ni = i + d;
            
          if ni >= 0 && ni <= 7 &&
             (i != 3 || ni != 4) &&
             (i != 4 || ni != 3) {
            let mut nv: Vec<u32> = v.clone();
            nv[i as usize] = v[ni as usize];
            nv[ni as usize] = v[i as usize];
            let nh = hash(&nv);
            
            if !mp.contains_key(&nh) {
              mp.insert(nh, c + 1);
              que.push_back((nv, ni, c + 1));
            }
          }
        }
      },
      None => { break; }
    }
  }
  
  loop {
    let mut buf = String::new();
    
    if let Ok(c) = std::io::stdin().read_line(&mut buf) {
      if c < 15 { break; }
    }
    let v: Vec<u32> = buf.split_whitespace().map(|e| e.parse().unwrap()).collect();
    let h: u32 = hash(&v);
    println!(, mp.get(&h).unwrap());
  }
}
fn hash(v: &Vec<u32>) -> u32{
  v.iter().fold(0, |s, a| s * 10 + a)
}"
Rust,"fn main(){
  loop {
    let nc: Vec<usize> = read_vec();
    let n = nc[0];
    let c = nc[1];
    if n == 0 && c == 0 { break; }
    let mut lt: Vec<usize> = Vec::new();
    let mut bt: Vec<usize> = Vec::new();
    
    for _ in 0 .. n {
      let a: Vec<usize> = read_vec();
      let an: usize = a.iter().fold(0, |acc, x| acc * 2 + x);
      lt.push(an);
    }
    for _ in 0 .. c {
      let b: Vec<usize> = read_vec();
      let bn: usize = b.iter().fold(0, |acc, x| acc * 2 + x);
      bt.push(bn);
    }
    let mut pt: Vec<isize> = vec![-1 ; 65536];
    pt[0] = 0;
    
    for h in 0 .. n {
      let mut npt: Vec<isize> = vec![-1 ; 65536];
      
      for i in 0 .. 65536 {
        if pt[i] >= 0 {
          let ni: usize = i | lt[h];
          
          for j in 0 .. c {
            let mut p: isize = 0;
            let mut nni: usize = 0;
            
            for k in (0 .. 16).rev() {
              if bt[j] & (1 << k) > 0 && ni & (1 << k) > 0 {
                p += 1;
                nni *= 2;
              } else if ni & (1 << k) > 0 {
                nni = nni * 2 + 1;
              } else {
                nni *= 2;
              }
            }
            if pt[i] + p > npt[nni] {
              npt[nni] = pt[i] + p;
            }
          }
        }
      }
      pt = npt;
    }
    let ans: &isize = pt.iter().max().unwrap();
    println!(, *ans);
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	public String[] inputMountain = new String[10];
	public int[] mountain = new int[10];
	
	public static void main(String args[])throws IOException{
		int i;
		Main app = new Main();
		
		app.input();
		app.stringToInteger();
		app.sortMountain();
		app.output();
	}
	
	public void input()throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);
		int i;
		for(i=0;i<10;i++)
			inputMountain[i] = br.readLine();
	}
	
	public void stringToInteger(){
		int i;
		for(i=0;i<10;i++)
			mountain[i] = Integer.parseInt(inputMountain[i]);
	}
	
	public void sortMountain(){
		int i,j,t;
		
		for(i=0;i<9;i++){
			for(j=9;j>i;j--){
				if(mountain[j]<mountain[j-1]){
					t = mountain[j];
					mountain[j] = mountain[j-1];
					mountain[j-1] = t;
				}
			}
		}
	}
	
	public void output(){
		int i;
		for(i=9;i>6;i--)
			System.out.println(mountain[i]);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in),1024);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.util.*;
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int[] a = new int[10];
        for(int i = 0; i < 10; i++){
            a[i] = sc.nextInt();
        }
        int top1 = 0;
        int top2 = 0;
        int top3 = 0;
        int num1 = 0;
        int num2 = 0;
        for(int i = 0; i < 10; i++){
            if(a[i] > top1){
                top1 = a[i];
                num1 = i;
            }
        }
        for(int i = 0; i < 10; i++){
            if(i == num1){
                continue;
            }else if(a[i] > top2){
                top2 = a[i];
                num2 = i;
            }
        }
        for(int i = 0; i < 10; i++){
            if(i == num1 || i == num2){
                continue;
            }else if(a[i] > top3){
                top3 = a[i];
            }
        }
        System.out.println(top1);
        System.out.println(top2);
        System.out.println(top3);
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.lang.Exception;
import java.lang.Integer;
import java.lang.String;
import java.lang.System;
import java.util.StringTokenizer;
class Main {
    public static void main(String[] a) throws IOException {
        java.io.BufferedReader r = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
        try {
            int count = Integer.parseInt(r.readLine());
            String[] ans = new String[count];
            for(int i = 0; i < count; i++) {
                String s = r.readLine();
                StringTokenizer st = new StringTokenizer(s);
                int num[] = new int[4];
                for(int j = 0; j < 3;j++) {
                    num[j] = Integer.parseInt(st.nextToken());
                    if(num[0] < num[j]) {
                        int tmp = num[0];
                        num[0] = num[j];
                        num[j] = tmp;
                    }
                }
                if ( num[0] * num[0] == num[1] * num[1] + num[2] * num[2]) {
                    ans[i] = ;
                } else {
                    ans[i] = ;
                }
            }
            for(int i = 0; i < count; i++) {
                System.out.println(ans[i]);
            }
        } catch (Exception ex) {
            System.exit(0);
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.StringTokenizer;
public class Main {
	private StringTokenizer st;
	private BufferedReader bf;
	private int w;
	
	Main() {
		
		Scanner sc = new Scanner(System.in);
		
		while (sc.hasNext()){
			int m = sc.nextInt();
			int n = sc.nextInt();
			System.out.println(Integer.toString(m+n).length());
		}
		sc.close();
	}
	
	private void readData() {
		try {
			bf = new BufferedReader(new InputStreamReader(System.in));
			st = new StringTokenizer(bf.readLine());
			
			int m = nextInt();
			int n = nextInt();
			System.out.println(Integer.toString(m+n).length());
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	
	
	private String next() throws IOException {
		if (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(bf.readLine());
		return st.nextToken();
	}
	
	public static void main(String[] args) {
		
		Main m = new Main();
	}
}"
Java,"import java.io.*;
import java.util.*;
import java.math.BigInteger;
public class Main{
	
	public static void main(String[] args){
		try{
			final int INF = Integer.MAX_VALUE, MINF = Integer.MIN_VALUE;
			SpecialComparator scomparator = new SpecialComparator();
			Scanner s = new Scanner(System.in);
			
			for(int i = 1; i <= 9; i++){
				for(int j = 1; j <= 9; j++){
					debugl(i++j++i*j);
				}
			}
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	private static void debugl(Object obj){
		System.out.println(obj);
	}
	private static void debug(Object obj){
		System.out.print(obj);
	}
	private static String toStrmd(Object[] obj){
		return Arrays.deepToString(obj);
	}
}
class SpecialComparator implements Comparator{
	private int index = 0;
	public void setIndex(int index){
		this.index = index;
	}
	public int compare(Object a, Object b){
		String[] sa = (String[])a;
		String[] sb = (String[])b;
		return (sa[index].compareTo(sb[index]));
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
public class Main {
	/**
	 * AOJ001 List of Top 3 Hills
	 *
	 * @param args
	 */
	public static void main(String[] args) throws IOException {
		ArrayList<Integer> mountainList = getMountainList();
		Collections.sort(mountainList);
		Collections.reverse(mountainList);
		for (int i = 0; i < 3; i++) {
			System.out.println(mountainList.get(i));
		}
	}
	/**
	 * ??\\??????????????¨??????10???????±±????????????????´???????????????????????????´??????
	 *
	 * @return 10???????±±????????????????´???????????????????
	 * @throws IOException ??\\????????¨??????
	 */
	private static ArrayList<Integer> getMountainList() throws IOException {
		BufferedReader bufferedReader = new BufferedReader(
				new InputStreamReader(System.in));
		ArrayList<Integer> mountainList = new ArrayList<Integer>();
		String strInput;
		for (int i = 0; i < 10; i++) {
			strInput = bufferedReader.readLine();
			mountainList.add(Integer.parseInt(strInput));
		}
		bufferedReader.close();
		return mountainList;
	}
}"
Java,"import java.util.Arrays;
import java.util.Scanner;
public class Main {
	MyScanner sc = new MyScanner();
	Scanner sc2 = new Scanner(System.in);
	long start = System.currentTimeMillis();
	long fin = System.currentTimeMillis();
	final int MOD = 1000000007;
	int[] dx = { 1, 0, 0, -1 };
	int[] dy = { 0, 1, -1, 0 };
	void run() {
		int n = 10;
		int[] array = new int[n];
		for(int i=0;i<n;i++) array[i] = sc.nextInt();
		mergeSort(array, 0, n);
		System.out.println(array[9]);
		System.out.println(array[8]);
		System.out.println(array[7]);
	}
	void mergeSort(int a[], int left, int right) {
		if (right - left <= 1) return;
		int mid = (left + right) / 2;
		mergeSort(a, left, mid);
		mergeSort(a, mid, right);
		merge(a, left, mid, right);
	}
	void merge(int[] a, int left, int mid, int right) {
		int[] L = new int[mid - left + 1];
		int[] R = new int[right - mid + 1];
		int li = 0;
		int ri = 0;
		for (int i = 0; i < L.length-1; i++) L[i] = a[left + i];
		for (int i = 0; i < R.length-1; i++) R[i] = a[mid + i];
		L[L.length - 1] = R[R.length -1] = Integer.MAX_VALUE/2;
		for (int i = left; i < right; i++) {
			if (L[li] < R[ri]) a[i] = L[li++];
			else a[i] = R[ri++];
		}
	}
	public static void main(String[] args) {
		new Main().run();
	}
	void debug(Object... o) {
		System.out.println(Arrays.deepToString(o));
	}
	void debug2(int[][] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				System.out.print(array[i][j]);
			}
			System.out.println();
		}
	}
	boolean inner(int h, int w, int limH, int limW) {
		return 0 <= h && h < limH && 0 <= w && w < limW;
	}
	void swap(int[] x, int a, int b) {
		int tmp = x[a];
		x[a] = x[b];
		x[b] = tmp;
	}
	
	int lower_bound(int a[], int border) {
		int l = -1;
		int r = a.length;
		while (r - l > 1) {
			int mid = (l + r) / 2;
			if (border <= a[mid]) {
				r = mid;
			} else {
				l = mid;
			}
		}
		
		return r;
	}
	boolean palindrome(String s) {
		for (int i = 0; i < s.length() / 2; i++) {
			if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {
				return false;
			}
		}
		return true;
	}
	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}
		double nextDouble() {
			return Double.parseDouble(next());
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		String next() {
			try {
				StringBuilder res = new StringBuilder();
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
		int[] nextIntArray(int n) {
			int[] in = new int[n];
			for (int i = 0; i < n; i++) {
				in[i] = nextInt();
			}
			return in;
		}
		int[][] nextInt2dArray(int n, int m) {
			int[][] in = new int[n][m];
			for (int i = 0; i < n; i++) {
				in[i] = nextIntArray(m);
			}
			return in;
		}
		double[] nextDoubleArray(int n) {
			double[] in = new double[n];
			for (int i = 0; i < n; i++) {
				in[i] = nextDouble();
			}
			return in;
		}
		long[] nextLongArray(int n) {
			long[] in = new long[n];
			for (int i = 0; i < n; i++) {
				in[i] = nextLong();
			}
			return in;
		}
		char[][] nextCharField(int n, int m) {
			char[][] in = new char[n][m];
			for (int i = 0; i < n; i++) {
				String s = sc.next();
				for (int j = 0; j < m; j++) {
					in[i][j] = s.charAt(j);
				}
			}
			return in;
		}
	}
}"
Java,"import static java.lang.System.out;
import java.io.File;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
public class Main extends BaseExe {
    public static void main(String[] args) {
        new Main().exeSysIn();
    }
    @Override
    protected void execute() throws Exception {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
        nums.forEach(x -> nums.forEach(y -> out.println(x +  + y +  + x * y)));
    }
    public void recursionQQ() {
        recursionQQ(1);
    }
    public void recursionQQ(int i) {
        if (i > 9)
            return;
        recursionQ(i, 1);
        recursionQQ(++i);
    }
    public void recursionQ(int i, int j) {
        if (j > 9)
            return;
        out.println(i +  + j +  + i * j);
        recursionQ(i, ++j);
    }
}
abstract class BaseExe {
    private Scanner scan;
    private String inData;
    public void exeSysIn() {
        try (Scanner scan = new Scanner(System.in)) {
            exeCtrl(scan);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public void exeFileIn(String inDataPath) {
        try (Scanner scan = new Scanner(new File(inDataPath))) {
            exeCtrl(scan);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    private void exeCtrl(Scanner scan) throws Exception {
        this.scan = scan;
        execute();
    }
    protected abstract void execute() throws Exception;
    protected String nextLine() {
        return scan.nextLine();
    }
    protected boolean judgeInData() {
        return hasNextLine() && isNotEmptyInData();
    }
    protected boolean hasNextLine() {
        return scan.hasNextLine();
    }
    protected boolean isNotEmptyInData() {
        inData = nextLine();
        return !inData.isEmpty();
    }
    protected String getInData() throws Exception {
        if (inData.isEmpty())
            throw new Exception();
        return inData;
    }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Stack;
import java.util.StringTokenizer;
public class Main
{
	public static void main(String[] args)
	{
		try
		{
			BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
			LinkedList<String> list = new LinkedList<String>();
			list.clear();
			for(int i = 0; ; i++)
			{
				String s = in.readLine();
				if(s != null && !s.equals())
				{
					list.add(s);
				} else
				{
					break;
				}
			}
			for(String str : list)
			{
				Long[] ds = getParsedLonga(str);
				long ans = (ds[0] + ds[1]);
				System.out.println(String.valueOf(Long.valueOf(ans)).length());
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	
	private static Long[] getParsedLonga(String str)
	{
		LinkedList<Long> relist = new LinkedList<Long>();
		relist.clear();
		StringTokenizer sz = new StringTokenizer(str);
		while(sz.hasMoreTokens())
		{
			relist.add(Long.valueOf(sz.nextToken()));
		}
		
		Long[] result = relist.toArray(new Long[relist.size()]);
		return result;
	}
	
	private static void doWork(LinkedList<String> orderList)
	{
		
		int num = Integer.valueOf(orderList.getFirst());
		orderList.removeFirst();
		@SuppressWarnings()
		Stack<String>[] stacka = new Stack[num];
		for(int i = 0; i < stacka.length; i++)
		{
			stacka[i] = new Stack<String>();
		}
		for(int c = 0; c < orderList.size(); c++)
		{
			String order = orderList.get(c);
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				String pushString = orderList.get(++c);
				stacka[sa].push(pushString);
			} else
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				String poped = stacka[sa].pop();
				System.out.println(poped);
			}
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				int sb = Integer.valueOf(orderList.get(++c)) - 1;
				String poped = stacka[sa].pop();
				stacka[sb].push(poped);
			}
		}
	}
	
	private static int getPoint(String string1, String string2)
	{
		if(string1.equals(string2))
		{
			return 1;
		}
		LinkedList<String> list = new LinkedList<String>();
		list.clear();
		list.add(string1);
		list.add(string2);
		Collections.sort(list);
		if(list.get(0).equals(string1))
		{
			return 0;
		} else
		{
			return 3;
		}
	}
	private static String[] getSplitStrings(String s)
	{
		LinkedList<String> relist = new LinkedList<String>();
		relist.clear();
		StringTokenizer sz = new StringTokenizer(s);
		while(sz.hasMoreTokens())
		{
			relist.add(sz.nextToken());
		}
		
		String[] result = relist.toArray(new String[relist.size()]);
		return result;
	}
	private static double getDevideChild(double[] scores, double average)
	{
		double result = 0D;
		for(int i = 0; i < scores.length; i++)
		{
			result += Math.pow((scores[i] - average), 2D);
		}
		return result;
	}
	private static double getAverage(double[] scores)
	{
		double result = 0D;
		for(int i = 0; i < scores.length; i++)
		{
			result += scores[i];
		}
		return (result /= scores.length);
	}
	private static double getDistance(double[] points)
	{
		double dx0 = points[0];
		double dy0 = points[1];
		double dx1 = points[2];
		double dy1 = points[3];
		double dx = dx1 - dx0;
		double dy = dy1 - dy0;
		return Math.sqrt(dx*dx+dy*dy);
	}
	private static double[] getParsedDoublea(String s)
	{
		StringTokenizer sz = new StringTokenizer(s);
		ArrayList<Double> reslist = new ArrayList<Double>();
		while(sz.hasMoreTokens())
		{
			reslist.add(Double.valueOf(sz.nextToken()));
		}
		double[] result = new double[reslist.size()];
		for(int i = 0; i < result.length; i++)
		{
			result[i] = reslist.get(i);
		}
		return result;
	}
	private static String shuffle(String reg, int i)
	{
		System.out.println(reg++reg.substring(i, reg.length()) + reg.substring(0, i));
		return reg.substring(i, reg.length()) + reg.substring(0, i);
	}
	private static int[] getCharCounts(String s)
	{
		int[] result = new int['z'-'a'+1];
		for(int i = 0; i < s.length(); i++)
		{
			Character c = s.charAt(i);
			if(Character.isLetter(c))
			{
				c = Character.toLowerCase(c);
				int num = (int)c - 'a';
				result[num]++;
			}
		}
		return result;
	}
	private static int getCount(String s)
	{
		int result = 0;
		for(int i = 0; i < s.length(); i++)
		{
			result += Integer.valueOf(s.substring(i, i+1));
		}
		return result;
	}
	private static String getParsedString(String s)
	{
		String result = ;
		for(int i = 0; i < s.length(); i++)
		{
			char c = s.charAt(i);
			if(Character.isLowerCase(c))
			{
				c = Character.toUpperCase(c);
			} else
			if(Character.isUpperCase(c))
			{
				c = Character.toLowerCase(c);
			}
			result += c;
		}
		return result;
	}
	private static int getCount(int num, int max)
	{
		int result = 0;
		LinkedList<String> buffer = new LinkedList<String>();
		buffer.clear();
		for(int i = 1; i <= num; i++)
		{
			for(int j = 1; j <= num; j++)
			{
				for(int k = 1; k <= num; k++)
				{
					if(i + j + k == max && nEq(i, j, k))
					{
						int[] res = getSorted(i, j, k);
						String s = String.valueOf(res[0]++res[1]++res[2]);
						if(!buffer.contains(s))
						{
							buffer.add(s);
							result++;
						}
					}
				}
			}
		}
		return result;
	}
	private static boolean nEq(int i, int j, int k)
	{
		return i != j && i != k && j != k;
	}
	private static int[] getSorted(int ... param)
	{
		for(int i = 0; i < param.length - 1; i++)
		{
			for(int j = 0; j < param.length - 1 - i; j++)
			{
				if(param[j] > param[j+1])
				{
					param = swap(param.clone(), j, j+1);
				}
			}
		}
		return param;
	}
	private static int[] swap(int[] param, int i, int j)
	{
		int tmp = param[i];
		param[i] = param[j];
		param[j] = tmp;
		return param;
	}
	public static int[] getSpritIntegers(String s) throws Exception
	{
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.clear();
		StringTokenizer sz = new StringTokenizer(s);
		while(sz.hasMoreTokens())
		{
			list.add(Integer.valueOf(sz.nextToken()));
		}
		int[] result = new int[list.size()];
		for(int i = 0; i < list.size(); i++)
		{
			result[i] = list.get(i);
		}
		return result;
	}
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;
public class Main {
    final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    final String LINE_SPR = System.getProperty();
    final int BIG_MOD = 1000000007;
    void run() throws Exception {
        String line;
        PriorityQueue<Integer> nums = new PriorityQueue<Integer>();
        while((line = br.readLine()) != null) 
            nums.add(Integer.parseInt(line) * -1);
        for(int i = 0; i < 3; i++) 
            System.out.println(nums.poll() * -1);
    }
    /*
     * Templates
     */
    void dumpObjArr(Object[] arr, int n) {
        for(int i = 0; i < n; i++) {
            System.out.print(arr[i]);
            if(i < n - 1)
                System.out.print();
        }
        System.out.println();
    }
    void dumpObjArr2(Object[][] arr, int m, int n) {
        for(int j = 0; j < m; j++) 
            dumpObjArr(arr[j], n);
    }
    int ni() throws Exception {
        return Integer.parseInt(br.readLine().trim());
    }
    long nl() throws Exception {
        return Long.parseLong(br.readLine().trim());
    }
    String ns() throws Exception {
        return br.readLine();
    }
    boolean isPrime(int n) {
        for(int i=2;i<n;i++) {
            if(n%i==0)
                return false;
        }
        return true;
    }
    int getPrime(int n) {
        List<Integer> primes = new ArrayList<Integer>();
        primes.add(2);
        int count = 1;
        int x = 1;
        while(primes.size() < n) {
            x+=2;
            int m = (int)Math.sqrt(x);
            for(int p : primes) {
                if(p > m) {
                    primes.add(x);
                    break;
                }
                if(x % p == 0) 
                    break;
            }
        }
        return primes.get(primes.size() - 1);
    }
    void gcjPrint(String str, int t) {
        System.out.println( + t +  + str);
    }
    public static void main(String[] args) throws Exception {
        new Main().run();
    }
}"
Java,"import java.awt.event.MouseAdapter;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Stack;
import java.util.StringTokenizer;
public class Main
{
	public static void main(String[] args)
	{
		try
		{
			BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
			LinkedList<String> list = new LinkedList<String>();
			list.clear();
			for(int i = 0; i < 10; i++)
			{
				String s = in.readLine();
				if(s != null && !s.equals())
				{
					list.add(s);
				} else
				{
					break;
				}
			}
			LinkedList<Integer> mountains = new LinkedList<Integer>();
			for(int i = 0; i < 10; i++)
			{
				mountains.add(Integer.valueOf(list.get(i)));
			}
			Collections.sort(mountains);
			for(int i = 0; i < 3; i++)
			{
				int h = mountains.removeLast();
				System.out.println(h);
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	private static void doWork(LinkedList<String> orderList)
	{
		
		int num = Integer.valueOf(orderList.getFirst());
		orderList.removeFirst();
		@SuppressWarnings()
		Stack<String>[] stacka = new Stack[num];
		for(int i = 0; i < stacka.length; i++)
		{
			stacka[i] = new Stack<String>();
		}
		for(int c = 0; c < orderList.size(); c++)
		{
			String order = orderList.get(c);
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				String pushString = orderList.get(++c);
				stacka[sa].push(pushString);
			} else
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				String poped = stacka[sa].pop();
				System.out.println(poped);
			}
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				int sb = Integer.valueOf(orderList.get(++c)) - 1;
				String poped = stacka[sa].pop();
				stacka[sb].push(poped);
			}
		}
	}
	private static int getPoint(String string1, String string2)
	{
		if(string1.equals(string2))
		{
			return 1;
		}
		LinkedList<String> list = new LinkedList<String>();
		list.clear();
		list.add(string1);
		list.add(string2);
		Collections.sort(list);
		if(list.get(0).equals(string1))
		{
			return 0;
		} else
		{
			return 3;
		}
	}
	private static String[] getSplitStrings(String s)
	{
		LinkedList<String> relist = new LinkedList<String>();
		relist.clear();
		StringTokenizer sz = new StringTokenizer(s);
		while(sz.hasMoreTokens())
		{
			relist.add(sz.nextToken());
		}
		
		String[] result = relist.toArray(new String[relist.size()]);
		return result;
	}
	private static double getDevideChild(double[] scores, double average)
	{
		double result = 0D;
		for(int i = 0; i < scores.length; i++)
		{
			result += Math.pow((scores[i] - average), 2D);
		}
		return result;
	}
	private static double getAverage(double[] scores)
	{
		double result = 0D;
		for(int i = 0; i < scores.length; i++)
		{
			result += scores[i];
		}
		return (result /= scores.length);
	}
	private static double getDistance(double[] points)
	{
		double dx0 = points[0];
		double dy0 = points[1];
		double dx1 = points[2];
		double dy1 = points[3];
		double dx = dx1 - dx0;
		double dy = dy1 - dy0;
		return Math.sqrt(dx*dx+dy*dy);
	}
	private static double[] getParsedDoublea(String s)
	{
		StringTokenizer sz = new StringTokenizer(s);
		ArrayList<Double> reslist = new ArrayList<Double>();
		while(sz.hasMoreTokens())
		{
			reslist.add(Double.valueOf(sz.nextToken()));
		}
		double[] result = new double[reslist.size()];
		for(int i = 0; i < result.length; i++)
		{
			result[i] = reslist.get(i);
		}
		return result;
	}
	private static String shuffle(String reg, int i)
	{
		System.out.println(reg++reg.substring(i, reg.length()) + reg.substring(0, i));
		return reg.substring(i, reg.length()) + reg.substring(0, i);
	}
	private static int[] getCharCounts(String s)
	{
		int[] result = new int['z'-'a'+1];
		for(int i = 0; i < s.length(); i++)
		{
			Character c = s.charAt(i);
			if(Character.isLetter(c))
			{
				c = Character.toLowerCase(c);
				int num = (int)c - 'a';
				result[num]++;
			}
		}
		return result;
	}
	private static int getCount(String s)
	{
		int result = 0;
		for(int i = 0; i < s.length(); i++)
		{
			result += Integer.valueOf(s.substring(i, i+1));
		}
		return result;
	}
	private static String getParsedString(String s)
	{
		String result = ;
		for(int i = 0; i < s.length(); i++)
		{
			char c = s.charAt(i);
			if(Character.isLowerCase(c))
			{
				c = Character.toUpperCase(c);
			} else
			if(Character.isUpperCase(c))
			{
				c = Character.toLowerCase(c);
			}
			result += c;
		}
		return result;
	}
	private static int getCount(int num, int max)
	{
		int result = 0;
		LinkedList<String> buffer = new LinkedList<String>();
		buffer.clear();
		for(int i = 1; i <= num; i++)
		{
			for(int j = 1; j <= num; j++)
			{
				for(int k = 1; k <= num; k++)
				{
					if(i + j + k == max && nEq(i, j, k))
					{
						int[] res = getSorted(i, j, k);
						String s = String.valueOf(res[0]++res[1]++res[2]);
						if(!buffer.contains(s))
						{
							buffer.add(s);
							result++;
						}
					}
				}
			}
		}
		return result;
	}
	private static boolean nEq(int i, int j, int k)
	{
		return i != j && i != k && j != k;
	}
	private static int[] getSorted(int ... param)
	{
		for(int i = 0; i < param.length - 1; i++)
		{
			for(int j = 0; j < param.length - 1 - i; j++)
			{
				if(param[j] > param[j+1])
				{
					param = swap(param.clone(), j, j+1);
				}
			}
		}
		return param;
	}
	private static int[] swap(int[] param, int i, int j)
	{
		int tmp = param[i];
		param[i] = param[j];
		param[j] = tmp;
		return param;
	}
	public static int[] getSpritIntegers(String s) throws Exception
	{
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.clear();
		StringTokenizer sz = new StringTokenizer(s);
		while(sz.hasMoreTokens())
		{
			list.add(Integer.valueOf(sz.nextToken()));
		}
		int[] result = new int[list.size()];
		for(int i = 0; i < list.size(); i++)
		{
			result[i] = list.get(i);
		}
		return result;
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
/**
 * 0001：List of Top 3 Hills
 * 
 * @author Lyu
 * @version 2015/06/21
 */
public class Main {
    /**
     * 10個のデータを読み込み、高い順に3つ出力する。
     * 
     * @param args
     * @throws IOException 
     * @throws NumberFormatException 
     */
    public static void main(String[] args) throws NumberFormatException, IOException {
        
        int[] heightOfHills = getHeightOfHills();
        
        
        printTop3(heightOfHills);
    }
    
    /**
     * 標準入力を読み取り、山の高さを表すデータを要素数10の配列で返す。
     * 
     * @return 山の高さを表す配列
     * @throws NumberFormatException
     * @throws IOException
     */
    private static int[] getHeightOfHills() throws NumberFormatException, IOException {
        
        InputStreamReader streamReader = new InputStreamReader(System.in);
        BufferedReader bufferedReader = new BufferedReader(streamReader);
        String line = null;
        int[] heightOfHills = new int[10];
        int count = 0;
        try {
            while ((line = bufferedReader.readLine()) != null) {
                heightOfHills[count] = Integer.parseInt(line);
                ++count;
            }
        } finally {
            bufferedReader.close();
            streamReader.close();
        }
        return heightOfHills;
    }
    /**
     * 受け取ったint型配列要素を、数値の大きい順に3つ出力する。
     * 
     * @param array int型の配列
     */
    private static void printTop3(int[] array) {
        
        Arrays.sort(array);
        
        
        for (int i = 1; i <= 3; ++i) {
            System.out.println(array[array.length - i]);
        }
    }
}"
Java,"import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.Set;
public class Main {
	public static void main(String[] args) {
		Map<Integer, Integer> heightsOfMountain = new HashMap<>();
		Scanner scanner = new Scanner(System.in);
		for(int i=1;i<=10;i++){
			int height = scanner.nextInt();
			heightsOfMountain.put(i, height);
		}
		
		Set<Entry<Integer, Integer>> set = heightsOfMountain.entrySet();
        List<Entry<Integer, Integer>> list = new ArrayList<Entry<Integer, Integer>>(set);
        Collections.sort( list, new Comparator<Map.Entry<Integer, Integer>>()
        {
        			@Override
			public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2) {
				
				 return (o2.getValue()).compareTo( o1.getValue() );
			}
        } );
        for(int i=0;i<3;i++){
        		Map.Entry<Integer, Integer> entry = list.get(i);
            System.out.println(entry.getValue());
        }
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;
class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			String tmp = in.readLine();
			if (tmp == null) {
				break;
			}
			String[] ab = tmp.split();
			int a = Integer.parseInt(ab[0]);
			int b = Integer.parseInt(ab[1]);
			
			
			
			int i = 0;
			while (true) {
				i++;
				if (Math.pow(10, i) > a + b) {
					break;
				}
			}
			System.out.println(i);
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws NumberFormatException,
            IOException {
        final String SPACE = ;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        final int cntData = Integer.parseInt(br.readLine());
        int a;
        int b;
        int c;
        String data[] = new String[3];
        String lineString;
        for (int i = 0; i < cntData; i++) {
            lineString = br.readLine();
            data = lineString.split(SPACE);
            a = Integer.parseInt(data[0]);
            b = Integer.parseInt(data[1]);
            c = Integer.parseInt(data[2]);
            if (a * a + b * b == c * c) {
                sb.append();
            } else if (a * a + c * c == b * b) {
                sb.append();
            } else if (b * b + c * c == a * a) {
                sb.append();
            } else {
                sb.append();
            }
        }
        System.out.print(sb);
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.StringTokenizer;
public class Main {
  static InputReader in;
  static PrintWriter out;
  
  static class Solution {
    void solve() throws IOException {
      for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <=9; j++) {
          out.println(i +  + j +  + i*j);
        }
      }
    }
}
  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out);
    Solution solver = new Solution();
    solver.solve();
    out.close();
}
  static class InputReader {
    public BufferedReader br;
    public StringTokenizer st;
    public InputReader(InputStream stream) {
      br = new BufferedReader(new InputStreamReader(stream));
    }
    public int nextInt() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Integer.parseInt(st.nextToken());
    }
    public long nextLong() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Long.parseLong(st.nextToken());
    }
    public String next() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return st.nextToken();
    }
    public double nextDouble() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Double.parseDouble(st.nextToken());
    }
  }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	private static final int NO_DATA = -1;
	public static void main(String[] args) {
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(
				System.in));
		while (true) {
			
			int sum = getSum(reader);
			
			if (sum == NO_DATA) {
				return;
			}
			
			System.out.println(String.valueOf(sum).length());
		}
	}
	/**
	 * ストリームから1行読み込んで、2つの数値を合計して返す。 値が取得できなかった場合は-1を返す。
	 *
	 * @param reader
	 *            入力ストリーム
	 * @return 数値の合計
	 */
	private static int getSum(BufferedReader reader) {
		int result = NO_DATA;
		try {
			String line = reader.readLine();
			if (line == null || line.length() == 0) {
				return result;
			}
			String[] numArray = line.split();
			result = Integer.parseInt(numArray[0])
					+ Integer.parseInt(numArray[1]);
		} catch (IOException e) {
			throw new RuntimeException();
		}
		return result;
	}
}"
Java,"import java.io.*;
public class Main {
	static int n;
	static void swap(int[] array, int i, int j) {
		int temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}
	static void quick_sort(int[] array, int left, int right) {
		int pivot = array[(left + right) / 2];
		int i = left;
		int j = right;
		while (true) {
			while (pivot > array[i])
				i++;
			while (pivot < array[j])
				j--;
			if (i >= j)
				break;
			swap(array, i, j);
			i++; 
			j--;
		}
		if (left < i - 1) 
			quick_sort(array, left, i - 1); 
		if (j + 1 < right) 
			quick_sort(array, j + 1, right); 
	}
	static void display(int[] array, int m, int n) {
		for (int i = n-1; i > m-1; i--) {
			System.out.print(array[i] + );
		}
		
	}
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int array[] = new int[10];
		for (int i = 0; i <= 9; i++) {
			String s = br.readLine();
			array[i] = Integer.parseInt(s);
		}
		
		n = array.length;
		
		
		quick_sort(array, n - n, n - 1);
		
		
		
		display(array, 7, 9+1);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    /**
     * 会津大学オンラインジャッジシステムのうち、<br>
     * volume 0のList Of Top 3 Hillsの問題の解答です。
     *
     * @param args
     */
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] inputData = new String[10];
        try {
            for(int i = 0; i < 10; i++) {
                inputData[i] = in.readLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
            return;
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
        }
        int firstHill = 0;
        int secondHill = 0;
        int thirdHill = 0;
        int nowHill = 0;
        for (String nowHillStr : inputData) {
            nowHill = Integer.parseInt(nowHillStr);
            if (nowHill > firstHill) {
                thirdHill = secondHill;
                secondHill = firstHill;
                firstHill = nowHill;
            } else if(nowHill > secondHill) {
                thirdHill = secondHill;
                secondHill = nowHill;
            } else if(nowHill > thirdHill) {
                thirdHill = nowHill;
            }
        }
        System.out.println(firstHill);
        System.out.println(secondHill);
        System.out.println(thirdHill);
    }
}"
Java,"import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] array = new int[10];
		for(int i = 0; i < array.length; i++)
		array[i] = sc.nextInt();
		array = mergeSort(array);
		for(int i = 0; i < 3; i++)
		System.out.println(array[i]);
		}
		public static int[] mergeSort(int[] array) {
		if(array.length <= 1)
		return array;
		int[] head = split(array, 0, array.length / 2);
		int[] tail = split(array, array.length / 2, array.length);
		return merge(mergeSort(head), mergeSort(tail));
		}
		private static int[] split(int[] array, int start, int end) {
		int[] newArray = new int[end-start];
		for(int i = start, j = 0; i < end; i++, j++)
		newArray[j] = array[i];
		return newArray;
		}
		private static int[] merge(int[] a, int[] b) {
		int[] merged = new int[a.length + b.length];
		for(int i = 0, j = 0, k = 0; i < a.length + b.length; i++) {
		if(j == a.length || k == b.length)
		merged[i] = (j == a.length ? b[k++] : a[j++]);
		else
		merged[i] = (a[j] > b[k] ? a[j++] : b[k++]);
		}
		return merged;
		}
		}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public class Main {
	/**
	 * 引数で与えられた10の山の高さのうち、高い順に3つ出力する。
	 *
	 * @param args
	 *            利用しない
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		List<Integer> heightsOfMountain = new ArrayList<Integer>();
		String line = null;
		while ((line = br.readLine()) != null) {
			heightsOfMountain.add(Integer.valueOf(line));
		}
		
		 Collections.sort(heightsOfMountain);
		 Collections.reverse(heightsOfMountain);
		 
		 System.out.println(heightsOfMountain.get(0));
		 System.out.println(heightsOfMountain.get(1));
		 System.out.println(heightsOfMountain.get(2));
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Stack;
import java.util.Scanner;
import java.util.Queue;
/**
 * @author yoshikyoto
 */
class Main{
	static final boolean DEBUG = false;
	static Scanner sc = new Scanner(new InputStreamReader(System.in));
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
	public static void main(String args[]) throws Exception{
		for(int i = 1; i <= 9; i++)
			for(int j = 1; j <= 9; j++)
				p(i +  + j +  + (i*j));
	}
	public static void pa(Object[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(int[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(double[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(boolean[] arr){System.out.println(Arrays.toString(arr));}
	public static void p(Object o){System.out.println(o.toString());}
	public static void d(Object o){if(DEBUG)System.out.println(o.toString());}
	public static int[] parseInt(String[] arr){
		int[] res = new int[arr.length];
		for(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);
		return res;
	}
	public static int parseInt(Object o){return Integer.parseInt(o.toString());};
}
class MyHashMap<E> extends HashMap<E, Integer>{
	ArrayList<E> keyArray = new ArrayList<E>();
	public void add(E key){add(key, 1);}
	public void add(E key, Integer value){
		if(containsKey(key)){
			value += get(key);
		}else{
			keyArray.add(key);
		}
		put(key, value);
	}
}"
Java,"import java.io.*;
import java.util.*;
import java.math.BigInteger;
public class Main{
	
	public static void main(String[] args){
		try{
			final int INF = Integer.MAX_VALUE, MINF = Integer.MIN_VALUE;
			SpecialComparator scomparator = new SpecialComparator();
			Scanner s = new Scanner(System.in);
			
			while(s.hasNext()){
				int a = s.nextInt(), b = s.nextInt();
				debugl(String.valueOf(a+b).length());
			}
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	private static void debugl(Object obj){
		System.out.println(obj);
	}
	private static void debug(Object obj){
		System.out.print(obj);
	}
	private static String toStrmd(Object[] obj){
		return Arrays.deepToString(obj);
	}
}
class SpecialComparator implements Comparator{
	private int index = 0;
	public void setIndex(int index){
		this.index = index;
	}
	public int compare(Object a, Object b){
		String[] sa = (String[])a;
		String[] sb = (String[])b;
		return (sa[index].compareTo(sb[index]));
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public class Main {
    
    private static final int NUMBER_OF_INPUT_MOUNTAIN = 10;
    
    private static final int NUMBER_OF_OUTPUT_MOUNTAIN = 3;
    /**
     * 入力された山の高さから一番高い山を取得する。
     * 山の高さは 0 <= height <= 10000、データの数は 10 個。
     *
     * @param args
     */
    public static void main(String[] args) throws IOException {
        
        List<Integer> heightList = readHeight();
        
        Collections.sort(heightList);
        Collections.reverse(heightList);
        
        printHeight(heightList);
    }
    /**
     * 既定の回数だけ、標準入力から数字を読み、数値のリストにして返却する。
     *
     * @return 入力された山の高さを表す数値のリスト
     */
    protected static List<Integer> readHeight() throws IOException {
        List<Integer> heightList = new ArrayList<Integer>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        
        for (int i = 0; i < NUMBER_OF_INPUT_MOUNTAIN; i++) {
            String line = reader.readLine();
            heightList.add(Integer.parseInt(line));
        }
        
        if (reader != null) {
            reader.close();
        }
        return heightList;
    }
    /**
     * 既定の回数だけ、ソート済みの山の高さを表す整数リストを出力する。
     *
     * @param heightList ソート済みの山の高さを表す整数リスト
     */
    protected static void printHeight(List<Integer> heightList) {
        for (int i = 0; i < NUMBER_OF_OUTPUT_MOUNTAIN; i++) {
            System.out.println(heightList.get(i));
        }
    }
}"
Java,"import java.util.Scanner;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main{
    public static void main(String[] args){
        InputStreamReader inputStreamReader = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(inputStreamReader);
        String str;
        int[] num = new int[2];
        try {
            while(reader.ready()){
                str = reader.readLine();
                num = getNum(str);
                System.out.println(cntDigit(num[0] + num[1]));
            }   
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private static int[] getNum(String str){
        String[] data = str.split(); 
        int[] num = new int[data.length];
        for (int i = 0; i < data.length; i++){
            num[i] = Integer.parseInt(data[i]);
        }
        return num;
    }
    private static int cntDigit(int num) {
        int n = 1;
        while(num >= 10) {
            n++;
            num /= 10;
        }
        return n;
    }
}"
Java,"import java.util.*;
public class Main{
        public static void main(String[] args)throws Exception{
                Scanner sc = new Scanner(System.in);
                int[] res = new int[3];
                for(int i = 0; i < 10; i++){
                        int now = sc.nextInt();
                        if(now >= res[0]){
                                int x = res[0];
                                int y = res[1];
                                res[0] = now;
                                res[1] = x;
                                res[2] = y;
                        }else{
                                if(now >= res[1]){
                                        int x = res[1];
                                        res[1] = now;
                                        res[2] = x;
                                }else{
                                        if(now >= res[2]){
                                                res[2] = now;
                                        }
                                }
                         }
                }
                for(int j = 0; j < res.length; j++){
                        System.out.println(res[j]);
                }
        }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Stack;
import java.util.Scanner;
import java.util.Queue;
/**
 * @author yoshikyoto
 */
class Main{
	static final boolean DEBUG = false;
	static Scanner sc = new Scanner(new InputStreamReader(System.in));
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
	public static void main(String args[]) throws Exception{
		int n = parseInt(readLine());
		for(int i = 0; i < n; i++){
			int t[] = parseInt(readLine().split());
			Arrays.sort(t);
			t[0] *= t[0]; t[1] *= t[1]; t[2] *= t[2];
			if(t[0] + t[1] == t[2]){
				p();
			}else{
				p();
			}
		}
	}
	public static String readLine() throws IOException{return br.readLine();}
	public static int readInt(){return sc.nextInt();}
	public static void pa(Object[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(int[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(double[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(boolean[] arr){System.out.println(Arrays.toString(arr));}
	public static void p(Object o){System.out.println(o.toString());}
	public static void d(Object o){if(DEBUG)System.out.println(o.toString());}
	public static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}
	public static void sort(int[] a){Arrays.sort(a);}
	public static int[] parseInt(String[] arr){
		int[] res = new int[arr.length];
		for(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);
		return res;
	}
	public static int parseInt(Object o){return Integer.parseInt(o.toString());}
	public static int digit(int n){return String.valueOf(n).length();}
}
class MyHashMap<E> extends HashMap<E, Integer>{
	ArrayList<E> keyArray = new ArrayList<E>();
	public void add(E key){add(key, 1);}
	public void add(E key, Integer value){
		if(containsKey(key)){
			value += get(key);
		}else{
			keyArray.add(key);
		}
		put(key, value);
	}
}"
Java,"import java.util.Scanner;
public class Main{
	static void swap(int[] a, int idx1, int idx2) {
        int t = a[idx1];
        a[idx1] = a[idx2];
        a[idx2] = t;
    }
    static void quickSort(int[] a, int left, int right) {
        int pl = left;
        int pr = right;
        int x = a[(pl + pr) / 2];
 
        do {
            while (a[pl] < x) {
                pl++;
            }
            while (a[pr] > x) {
                pr--;
            }
            if (pl <= pr) {
                swap(a, pl++, pr--);
            }
        } while (pl <= pr);
 
        if (left < pr) {
            quickSort(a, left, pr);
        }
        if (pl < right) {
            quickSort(a, pl, right);
        }
    }
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int[] hill=new int[10];
		for(int i=0;i<10;i++){
			hill[i]=scan.nextInt();
		}	
		quickSort(hill,0,9);
		System.out.println(hill[9]);
		System.out.println(hill[8]);
		System.out.println(hill[7]);
	}
}"
Java,"import java.util.*;
import java.io.*;
public class Main {
	void solve (FastScanner in, PrintWriter out, Methods ms) {
		
		while (in.hasNext()) {
			out.println(String.valueOf(in.nextInt()+in.nextInt()).length());
		}
		
	}
	public static void main(String[] args) {
		Main main = new Main();
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		Methods ms = new Methods();
		main.solve(in, out, ms);
		in.close();
		out.close();
	}
	static class Methods {
		public void print (Object... ar) {System.out.println(Arrays.deepToString(ar));}
		public void yesno (PrintWriter out, boolean b) {out.println(b?:);}
		public void YESNO (PrintWriter out, boolean b) {out.println(b?:);}
		public int max (int... ar) {Arrays.sort(ar); return ar[ar.length-1];}
		public int min (int... ar) {Arrays.sort(ar); return ar[0];}
		public long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}
		public long lcm (long a, long b) {return a/gcd(a,b)*b;}
		public boolean isPrime (int n) {
			if (n==2) return true;
			if (n<2 || n%2==0) return false;
			double d = Math.sqrt(n);
			for (int i=3; i<=d; i+=2) if(n%i==0){return false;}
			return true;
		}
	}
	static class FastScanner {
		private InputStream in;
		private byte[] buffer = new byte[1024];
		private  int length = 0, p = 0;
		public FastScanner (InputStream stream) {
			in = stream;
		}
		public boolean hasNextByte () {
			if (p < length) return true;
			else {
				p = 0;
				try {length = in.read(buffer);}
				catch (Exception e) {e.printStackTrace();}
				if (length <= 0) return false;
			}
			return true;
		}
		public int readByte () {
			if (hasNextByte() == true) return buffer[p++];
			return -1;
		}
		public boolean isPrintable (int n) {return 33<=n&&n<=126;}
		public void skip () {
			while (hasNextByte() && !isPrintable(buffer[p])) p++;
		}
		public boolean hasNext () {skip(); return hasNextByte();}
		public String next () {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int t = readByte();
			while (isPrintable(t)) {
				sb.appendCodePoint(t);
				t = readByte();
			}
			return sb.toString();
		}
		public String[] nextArray (int n) {
			String[] ar = new String[n];
			for (int i=0; i<n; i++) ar[i] = next();
			return ar;
		}
		public int nextInt () {return Math.toIntExact(nextLong());}
		public int[] nextIntArray (int n) {
			int[] ar = new int[n];
			for (int i=0; i<n; i++) ar[i] = nextInt();
			return ar;
		}
		public long nextLong () {
			if (!hasNext()) throw new NoSuchElementException();
			boolean minus = false;
			int temp = readByte();
			if (temp == '-') {
				minus = true;
				temp = readByte();
			}
			if (temp<'0' || '9'<temp) throw new NumberFormatException();
			long n = 0;
			while (isPrintable(temp)) {
				if ('0'<=temp && temp<='9') {
					n *= 10;
					n += temp - '0';
				}
				else throw new NumberFormatException();
				temp = readByte();
			}
			return minus? -n : n;
		}
		public long[] nextLongArray (int n) {
			long[] ar = new long[n];
			for (int i=0; i<n; i++) ar[i] = nextLong();
			return ar;
		}
		public double nextDouble () {
			return Double.parseDouble(next());
		}
		public double[] nextDoubleArray (int n) {
			double[] ar = new double[n];
			for (int i=0; i<n; i++) ar[i] = nextDouble();
			return ar;
		}
		public void close () {
			try {in.close();}
			catch(Exception e){}
		}
	}
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Stack;
import java.util.StringTokenizer;
public class Main
{
	public static void main(String[] args)
	{
		for(int i = 1; i <= 9; i++)
		{
			for(int j = 1; j <= 9; j++)
			{
				System.out.println(i++j++(i*j));
			}
		}
		/*
		try
		{
			BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
			LinkedList<String> list = new LinkedList<String>();
			list.clear();
			for(;;)
			{
				String s = in.readLine();
				if(s != null && !s.equals())
				{
					list.add(s);
				} else
				{
					break;
				}
			}
			LinkedList<String> stateList = new LinkedList<String>();
			stateList.clear();
			for(String s : list)
			{
				String[] strs = getSplitStrings(s);
				for(int i = 0; i < strs.length; i++)
				{
					stateList.add(strs[i]);
				}
			}
			doWork(stateList);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}*/
	}
	private static void doWork(LinkedList<String> orderList)
	{
		
		int num = Integer.valueOf(orderList.getFirst());
		orderList.removeFirst();
		@SuppressWarnings()
		Stack<String>[] stacka = new Stack[num];
		for(int i = 0; i < stacka.length; i++)
		{
			stacka[i] = new Stack<String>();
		}
		for(int c = 0; c < orderList.size(); c++)
		{
			String order = orderList.get(c);
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				String pushString = orderList.get(++c);
				stacka[sa].push(pushString);
			} else
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				String poped = stacka[sa].pop();
				System.out.println(poped);
			}
			if(order.equals())
			{
				int sa = Integer.valueOf(orderList.get(++c)) - 1;
				int sb = Integer.valueOf(orderList.get(++c)) - 1;
				String poped = stacka[sa].pop();
				stacka[sb].push(poped);
			}
		}
	}
	private static int getPoint(String string1, String string2)
	{
		if(string1.equals(string2))
		{
			return 1;
		}
		LinkedList<String> list = new LinkedList<String>();
		list.clear();
		list.add(string1);
		list.add(string2);
		Collections.sort(list);
		if(list.get(0).equals(string1))
		{
			return 0;
		} else
		{
			return 3;
		}
	}
	private static String[] getSplitStrings(String s)
	{
		LinkedList<String> relist = new LinkedList<String>();
		relist.clear();
		StringTokenizer sz = new StringTokenizer(s);
		while(sz.hasMoreTokens())
		{
			relist.add(sz.nextToken());
		}
		
		String[] result = relist.toArray(new String[relist.size()]);
		return result;
	}
	private static double getDevideChild(double[] scores, double average)
	{
		double result = 0D;
		for(int i = 0; i < scores.length; i++)
		{
			result += Math.pow((scores[i] - average), 2D);
		}
		return result;
	}
	private static double getAverage(double[] scores)
	{
		double result = 0D;
		for(int i = 0; i < scores.length; i++)
		{
			result += scores[i];
		}
		return (result /= scores.length);
	}
	private static double getDistance(double[] points)
	{
		double dx0 = points[0];
		double dy0 = points[1];
		double dx1 = points[2];
		double dy1 = points[3];
		double dx = dx1 - dx0;
		double dy = dy1 - dy0;
		return Math.sqrt(dx*dx+dy*dy);
	}
	private static double[] getParsedDoublea(String s)
	{
		StringTokenizer sz = new StringTokenizer(s);
		ArrayList<Double> reslist = new ArrayList<Double>();
		while(sz.hasMoreTokens())
		{
			reslist.add(Double.valueOf(sz.nextToken()));
		}
		double[] result = new double[reslist.size()];
		for(int i = 0; i < result.length; i++)
		{
			result[i] = reslist.get(i);
		}
		return result;
	}
	private static String shuffle(String reg, int i)
	{
		System.out.println(reg++reg.substring(i, reg.length()) + reg.substring(0, i));
		return reg.substring(i, reg.length()) + reg.substring(0, i);
	}
	private static int[] getCharCounts(String s)
	{
		int[] result = new int['z'-'a'+1];
		for(int i = 0; i < s.length(); i++)
		{
			Character c = s.charAt(i);
			if(Character.isLetter(c))
			{
				c = Character.toLowerCase(c);
				int num = (int)c - 'a';
				result[num]++;
			}
		}
		return result;
	}
	private static int getCount(String s)
	{
		int result = 0;
		for(int i = 0; i < s.length(); i++)
		{
			result += Integer.valueOf(s.substring(i, i+1));
		}
		return result;
	}
	private static String getParsedString(String s)
	{
		String result = ;
		for(int i = 0; i < s.length(); i++)
		{
			char c = s.charAt(i);
			if(Character.isLowerCase(c))
			{
				c = Character.toUpperCase(c);
			} else
			if(Character.isUpperCase(c))
			{
				c = Character.toLowerCase(c);
			}
			result += c;
		}
		return result;
	}
	private static int getCount(int num, int max)
	{
		int result = 0;
		LinkedList<String> buffer = new LinkedList<String>();
		buffer.clear();
		for(int i = 1; i <= num; i++)
		{
			for(int j = 1; j <= num; j++)
			{
				for(int k = 1; k <= num; k++)
				{
					if(i + j + k == max && nEq(i, j, k))
					{
						int[] res = getSorted(i, j, k);
						String s = String.valueOf(res[0]++res[1]++res[2]);
						if(!buffer.contains(s))
						{
							buffer.add(s);
							result++;
						}
					}
				}
			}
		}
		return result;
	}
	private static boolean nEq(int i, int j, int k)
	{
		return i != j && i != k && j != k;
	}
	private static int[] getSorted(int ... param)
	{
		for(int i = 0; i < param.length - 1; i++)
		{
			for(int j = 0; j < param.length - 1 - i; j++)
			{
				if(param[j] > param[j+1])
				{
					param = swap(param.clone(), j, j+1);
				}
			}
		}
		return param;
	}
	private static int[] swap(int[] param, int i, int j)
	{
		int tmp = param[i];
		param[i] = param[j];
		param[j] = tmp;
		return param;
	}
	public static int[] getSpritIntegers(String s) throws Exception
	{
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.clear();
		StringTokenizer sz = new StringTokenizer(s);
		while(sz.hasMoreTokens())
		{
			list.add(Integer.valueOf(sz.nextToken()));
		}
		int[] result = new int[list.size()];
		for(int i = 0; i < list.size(); i++)
		{
			result[i] = list.get(i);
		}
		return result;
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.StringTokenizer;
public class Main {
  static InputReader in;
  static PrintWriter out;
  
  static class Solution {
    void solve() throws IOException {
      Scanner sc = new Scanner(System.in);
      while(sc.hasNext()){
        int a = sc.nextInt();
        int b = sc.nextInt();
        int sum = a + b;
        int cnt = 0;
        
        while (true) {
          sum /= 10;
          cnt++;
          if (sum == 0) {
            break;
          }
        }
        
        out.println(cnt);
      }
    }
}
  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out);
    Solution solver = new Solution();
    solver.solve();
    out.close();
}
  static class InputReader {
    public BufferedReader br;
    public StringTokenizer st;
    public InputReader(InputStream stream) {
      br = new BufferedReader(new InputStreamReader(stream));
    }
    public int nextInt() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Integer.parseInt(st.nextToken());
    }
    public long nextLong() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Long.parseLong(st.nextToken());
    }
    public String next() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return st.nextToken();
    }
    public double nextDouble() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Double.parseDouble(st.nextToken());
    }
  }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	public static void main (String [] a){
		int numMountain = 10;
		int minConst = 0;
		int maxConst = 10000;
		int[] mountainList = new int[numMountain];
		int topOne = 0;
		int topTwo = 0;
		int topThree = 0;
		
		BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
		String line;
		int i = 0;
		
		try {
			while (i < numMountain && (line = stdin.readLine()) != null && 
					line.length()!= 0 ) {
					
					try {
						int tempHeight = Integer.parseInt(line);
						if (tempHeight < minConst || tempHeight > maxConst) {
						} else {
							mountainList[i] = tempHeight;
							i++;
						}
					} catch (NumberFormatException e){
						
						
					}
					
			}
			
			for (int j=0; j<numMountain; j++){
				if (mountainList[j] >= topOne){
					topThree = topTwo;
					topTwo = topOne;
					topOne = mountainList[j];
				} else if (mountainList[j] >= topTwo){
					topThree = topTwo;
					topTwo = mountainList[j];
				} else if (mountainList[j] >= topThree){
					topThree = mountainList[j];
				}
			}
			
			System.out.println(topOne ++ topTwo ++ topThree);
		} catch (IOException e) {
			
			
		}
	}
}"
Java,"import java.util.Scanner;
public class Main {
	static Scanner scanner = new Scanner(System.in);
	static int Hillta[]= new int[10];
	public static void main(String args[]){
		for(int i=0; i <= 9; i++){
			Hillta[i] = S_content();
		}								
		judge();
	}
	public static int S_content(){
		int high = scanner.nextInt();
		return high;
	}
	public static void judge(){
		int rank1=0, rank2=0, rank3=0;
		rank1 = Hillta[0];
		for(int i=1; i <= 9; i++){
			
			if(Hillta[i] > rank3){
				if(Hillta[i] > rank2){
					if(Hillta[i] > rank1){
						rank3 = rank2;
						rank2 = rank1;
						rank1 = Hillta[i];
						
						continue;
					}
					rank3 = rank2;
					rank2 = Hillta[i];
					
					continue;
				}
				rank3 = Hillta[i];
				
				continue;
			}
		}
		System.out.println(rank1);
		System.out.println(rank2);
		System.out.println(rank3);
	}
}"
Java,"import java.util.*;
import java.io.*;
public class Main {
	void solve (FastScanner in, PrintWriter out, Methods ms) {
		
		for (int i=1; i<=9; i++) {
			for (int j=1; j<=9; j++) {
				out.println(i++j++(i*j));
			}
		}
		
	}
	public static void main(String[] args) {
		Main main = new Main();
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		Methods ms = new Methods();
		main.solve(in, out, ms);
		in.close();
		out.close();
	}
	static class Methods {
		public void print (Object... ar) {System.out.println(Arrays.deepToString(ar));}
		public void yesno (PrintWriter out, boolean b) {out.println(b?:);}
		public void YESNO (PrintWriter out, boolean b) {out.println(b?:);}
		public int max (int... ar) {Arrays.sort(ar); return ar[ar.length-1];}
		public int min (int... ar) {Arrays.sort(ar); return ar[0];}
		public long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}
		public long lcm (long a, long b) {return a/gcd(a,b)*b;}
		public boolean isPrime (int n) {
			if (n==2) return true;
			if (n<2 || n%2==0) return false;
			double d = Math.sqrt(n);
			for (int i=3; i<=d; i+=2) if(n%i==0){return false;}
			return true;
		}
	}
	static class FastScanner {
		private InputStream in;
		private byte[] buffer = new byte[1024];
		private  int length = 0, p = 0;
		public FastScanner (InputStream stream) {
			in = stream;
		}
		public boolean hasNextByte () {
			if (p < length) return true;
			else {
				p = 0;
				try {length = in.read(buffer);}
				catch (Exception e) {e.printStackTrace();}
				if (length <= 0) return false;
			}
			return true;
		}
		public int readByte () {
			if (hasNextByte() == true) return buffer[p++];
			return -1;
		}
		public boolean isPrintable (int n) {return 33<=n&&n<=126;}
		public void skip () {
			while (hasNextByte() && !isPrintable(buffer[p])) p++;
		}
		public boolean hasNext () {skip(); return hasNextByte();}
		public String next () {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int t = readByte();
			while (isPrintable(t)) {
				sb.appendCodePoint(t);
				t = readByte();
			}
			return sb.toString();
		}
		public String[] nextArray (int n) {
			String[] ar = new String[n];
			for (int i=0; i<n; i++) ar[i] = next();
			return ar;
		}
		public int nextInt () {return Math.toIntExact(nextLong());}
		public int[] nextIntArray (int n) {
			int[] ar = new int[n];
			for (int i=0; i<n; i++) ar[i] = nextInt();
			return ar;
		}
		public long nextLong () {
			if (!hasNext()) throw new NoSuchElementException();
			boolean minus = false;
			int temp = readByte();
			if (temp == '-') {
				minus = true;
				temp = readByte();
			}
			if (temp<'0' || '9'<temp) throw new NumberFormatException();
			long n = 0;
			while (isPrintable(temp)) {
				if ('0'<=temp && temp<='9') {
					n *= 10;
					n += temp - '0';
				}
				else throw new NumberFormatException();
				temp = readByte();
			}
			return minus? -n : n;
		}
		public long[] nextLongArray (int n) {
			long[] ar = new long[n];
			for (int i=0; i<n; i++) ar[i] = nextLong();
			return ar;
		}
		public double nextDouble () {
			return Double.parseDouble(next());
		}
		public double[] nextDoubleArray (int n) {
			double[] ar = new double[n];
			for (int i=0; i<n; i++) ar[i] = nextDouble();
			return ar;
		}
		public void close () {
			try {in.close();}
			catch(Exception e){}
		}
	}
}"
Java,"import java.util.*;
import java.io.*;
public class Main {
    static IO io = new IO();
    public static void main(String[] args) {
        int n[] = new int[10];
        for (int i=0; i<10; i++) n[i] = io.nextInt();
        Arrays.sort(n);
        System.out.println(n[9]);
        System.out.println(n[8]);
        System.out.println(n[7]);
    }
    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;
        IO() {
            this(System.in);
        }
        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }
        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }
        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }
        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }
        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }
        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }
        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }
        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }
        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}"
Java,"import java.util.*;                                                                 
public class Main{                                                               
  public static void main(String [] args){                                          
    Scanner sc = new Scanner(System.in);                                            
    int m_count = 10, ans_count = 3;                                                
    int[] m = new int[m_count];                                                     
    int i;                                                                          
    for(i = 0;i < m_count;i++){                                                     
      m[i] = sc.nextInt();                                                          
    }                                                                               
    Arrays.sort(m);
    int t = 0; 
    for (i = 0; i < m_count / 2; i++){
      t = m[i];
      m[i] = m[m_count - i - 1];
      m[m_count - i - 1] = t;
    }
    for(i = 0;i < ans_count;i++){
      System.out.println(m[i]);
    }
  }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;
public class Main {
    final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    final String LINE_SPR = System.getProperty();
    final int BIG_MOD = 1000000007;
    void run() throws Exception {
        int nt = ni();
        for(int t = 0; t < nt; t++) {
            String[] nums = ns().split();
            int a = Integer.parseInt(nums[0]);
            int b = Integer.parseInt(nums[1]);
            int c = Integer.parseInt(nums[2]);
            if(a * a + b * b == c * c || b * b + c * c == a * a
                    || c * c + a * a == b * b)
                System.out.println();
            else
                System.out.println();
        }
    }
    /*
     * Templates
     */
    void dumpObjArr(Object[] arr, int n) {
        for(int i = 0; i < n; i++) {
            System.out.print(arr[i]);
            if(i < n - 1)
                System.out.print();
        }
        System.out.println();
    }
    void dumpObjArr2(Object[][] arr, int m, int n) {
        for(int j = 0; j < m; j++) 
            dumpObjArr(arr[j], n);
    }
    int ni() throws Exception {
        return Integer.parseInt(br.readLine().trim());
    }
    long nl() throws Exception {
        return Long.parseLong(br.readLine().trim());
    }
    String ns() throws Exception {
        return br.readLine();
    }
    boolean isPrime(int n) {
        for(int i=2;i<n;i++) {
            if(n%i==0)
                return false;
        }
        return true;
    }
    int getPrime(int n) {
        List<Integer> primes = new ArrayList<Integer>();
        primes.add(2);
        int count = 1;
        int x = 1;
        while(primes.size() < n) {
            x+=2;
            int m = (int)Math.sqrt(x);
            for(int p : primes) {
                if(p > m) {
                    primes.add(x);
                    break;
                }
                if(x % p == 0) 
                    break;
            }
        }
        return primes.get(primes.size() - 1);
    }
    void gcjPrint(String str, int t) {
        System.out.println( + t +  + str);
    }
    public static void main(String[] args) throws Exception {
        new Main().run();
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
class Main {
	public static void main(String[] args) {
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(
				System.in));
		
		int loop = Integer.parseInt(readLine(reader));
		for (int i = 0; i < loop; i++) {
			String[] sideArray = readLine(reader).split();
			int[] sideNumArray = new int[sideArray.length];
			for (int j = 0; j < sideNumArray.length; j++) {
				sideNumArray[j] = Integer.parseInt(sideArray[j]);
			}
			
			Arrays.sort(sideNumArray);
			int smallTwo = sideNumArray[0] * sideNumArray[0] + sideNumArray[1]
					* sideNumArray[1];
			int largeOne = sideNumArray[2] * sideNumArray[2];
			
			if (smallTwo == largeOne) {
				System.out.println();
			} else {
				System.out.println();
			}
		}
	}
	/**
	 * ストリームから1行読み込んで、文字列として返す。
	 *
	 * @param reader
	 *            入力ストリーム
	 * @return　文字列
	 */
	private static String readLine(BufferedReader reader) {
		String line = null;
		try {
			line = reader.readLine();
		} catch (IOException e) {
			throw new RuntimeException();
		}
		return line;
	}
}"
Java,"import java.util.*;
import java.io.*;
public class Main {
	void solve (FastScanner in, PrintWriter out, Methods ms) {
		
		int[] a = in.nextIntArray(10);
		Arrays.sort(a);
		out.println(a[9]);
		out.println(a[8]);
		out.println(a[7]);
		
	}
	public static void main(String[] args) {
		Main main = new Main();
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		Methods ms = new Methods();
		main.solve(in, out, ms);
		in.close();
		out.close();
	}
	static class Methods {
		public void print (Object... ar) {System.out.println(Arrays.deepToString(ar));}
		public void yesno (PrintWriter out, boolean b) {out.println(b?:);}
		public void YESNO (PrintWriter out, boolean b) {out.println(b?:);}
		public int max (int... ar) {Arrays.sort(ar); return ar[ar.length-1];}
		public int min (int... ar) {Arrays.sort(ar); return ar[0];}
		public long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}
		public long lcm (long a, long b) {return a/gcd(a,b)*b;}
		public boolean isPrime (int n) {
			if (n==2) return true;
			if (n<2 || n%2==0) return false;
			double d = Math.sqrt(n);
			for (int i=3; i<=d; i+=2) if(n%i==0){return false;}
			return true;
		}
	}
	static class FastScanner {
		private InputStream in;
		private byte[] buffer = new byte[1024];
		private  int length = 0, p = 0;
		public FastScanner (InputStream stream) {
			in = stream;
		}
		public boolean hasNextByte () {
			if (p < length) return true;
			else {
				p = 0;
				try {length = in.read(buffer);}
				catch (Exception e) {e.printStackTrace();}
				if (length <= 0) return false;
			}
			return true;
		}
		public int readByte () {
			if (hasNextByte() == true) return buffer[p++];
			return -1;
		}
		public boolean isPrintable (int n) {return 33<=n&&n<=126;}
		public void skip () {
			while (hasNextByte() && !isPrintable(buffer[p])) p++;
		}
		public boolean hasNext () {skip(); return hasNextByte();}
		public String next () {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int t = readByte();
			while (isPrintable(t)) {
				sb.appendCodePoint(t);
				t = readByte();
			}
			return sb.toString();
		}
		public String[] nextArray (int n) {
			String[] ar = new String[n];
			for (int i=0; i<n; i++) ar[i] = next();
			return ar;
		}
		public int nextInt () {return Math.toIntExact(nextLong());}
		public int[] nextIntArray (int n) {
			int[] ar = new int[n];
			for (int i=0; i<n; i++) ar[i] = nextInt();
			return ar;
		}
		public long nextLong () {
			if (!hasNext()) throw new NoSuchElementException();
			boolean minus = false;
			int temp = readByte();
			if (temp == '-') {
				minus = true;
				temp = readByte();
			}
			if (temp<'0' || '9'<temp) throw new NumberFormatException();
			long n = 0;
			while (isPrintable(temp)) {
				if ('0'<=temp && temp<='9') {
					n *= 10;
					n += temp - '0';
				}
				else throw new NumberFormatException();
				temp = readByte();
			}
			return minus? -n : n;
		}
		public long[] nextLongArray (int n) {
			long[] ar = new long[n];
			for (int i=0; i<n; i++) ar[i] = nextLong();
			return ar;
		}
		public double nextDouble () {
			return Double.parseDouble(next());
		}
		public double[] nextDoubleArray (int n) {
			double[] ar = new double[n];
			for (int i=0; i<n; i++) ar[i] = nextDouble();
			return ar;
		}
		public void close () {
			try {in.close();}
			catch(Exception e){}
		}
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
	        BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1);
	        String str = ;
	        StringTokenizer st;
	        while ((str = br.readLine()) != null) {
	            st = new StringTokenizer(str, );
	            if(st.countTokens() > 2)
	            	System.out.println();
	            int n1;
				int n2;
				try {
					n1 = Integer.parseInt(st.nextToken());
					n2 = Integer.parseInt(st.nextToken());
		            if(n1<0 || n2 < 0 || n1 > 1000000 || n2 > 1000000)
		            	System.out.println();
		            
		            str = String.valueOf(n1+n2);
		            System.out.println(str.length());
				} catch (NumberFormatException e) {
					System.out.println();
				}
	        }
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
class Main {
	public static void main(String[] args) {
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(
				System.in));
		
		List<Integer> heightList = new ArrayList<Integer>();
		for (int i = 0; i < 10; i++) {
			heightList.add(getHeight(reader));
		}
		
		Collections.sort(heightList);
		
		for (int i = 0; i < 3; i++) {
			System.out.println(heightList.get(9 - i));
		}
	}
	/**
	 * ストリームから1行読み込んで、高さを数値として返す。
	 *
	 * @param reader
	 *            入力ストリーム
	 * @return 高さ
	 */
	private static Integer getHeight(BufferedReader reader) {
		Integer height = null;
		try {
			String line = reader.readLine();
			height = new Integer(line);
		} catch (IOException e) {
			throw new RuntimeException();
		}
		return height;
	}
}"
Java,"import java.util.*;
import static java.lang.Math.*;
import static java.lang.System.out;
public class Main {
	Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		new Main().AOJ0001();
	}
	
	void AOJ0001(){	
		int[] m = new int[10];
		for(int i=0; i<10; i++)	m[i]=sc.nextInt();
		Arrays.sort(m);
		for(int i=9; i>=7; i--)	out.println(m[i]);
	}
	
	void AOJ10029(){	
		int n=sc.nextInt();
		int[] ans = new int[n];
		for(int i=0; i<n; i++)	ans[i]=sc.nextInt();
		Arrays.sort(ans);
		out.print(ans[0]);
		for(int i=1; i<n; i++)	out.print(+ans[i]);
		out.println();
	}
	
	int[][] p26 = new int[10][10];
	int c26=100;
	void AOJ0026(){	
		int ans=0;
		while(sc.hasNext()){
			Scanner sc2 = new Scanner(sc.nextLine()).useDelimiter();
			int x=sc2.nextInt(), y=sc2.nextInt(), s=sc2.nextInt();
			
			ans=max(solve26(x,y),ans);
			ans=max(solve26(x-1,y),ans);	ans=max(solve26(x+1,y),ans);
			ans=max(solve26(x,y-1),ans);	ans=max(solve26(x,y+1),ans);
			if(s>=2){
				ans=max(solve26(x-1,y-1),ans);	ans=max(solve26(x-1,y+1),ans);
				ans=max(solve26(x+1,y-1),ans);	ans=max(solve26(x+1,y+1),ans);
			}
			if(s>=3){
				ans=max(solve26(x-2,y),ans);	ans=max(solve26(x+2,y),ans);
				ans=max(solve26(x,y-2),ans);	ans=max(solve26(x,y+2),ans);
			}
		}
		out.println(c26);
		out.println(ans);
	}
	int solve26(int x, int y){
		int r=-1;
		if(0<=x && x<=9 && 0<=y && y<=9){
			c26 -= p26[x][y]==0? 1: 0;
			p26[x][y]++;
			r=p26[x][y];
		}
		return r;	
	}
	
	void AOJ0008(){	
		while(sc.hasNext()){
			int ans=0, n=sc.nextInt();
			for(int a=0; a<10; a++){
				for(int b=0; b<10; b++){
					for(int c=0; c<10; c++){
						for(int d=0; d<10; d++){
							if((a+b+c+d)==n)	ans++;
						}
					}
				}
			}
			out.println(ans);
		}
	}
	
	void AOJ0055(){	
		while(sc.hasNext()){
			double last=sc.nextDouble(), ans=last;
			for(int i=2; i<=10; i++){
				ans+= i%2==0? last*2: last/3;
				last = i%2==0? last*2: last/3;
				
			}
			out.println(ans);
		}
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[] top3 = new int[3];
        for(int i=0; i<10; i++){
            try {
                String line = br.readLine();
                if(line != null){
                    int tmp = Integer.parseInt(line.trim());
                    if(tmp>top3[0]){
                        top3[2] = top3[1];
                        top3[1] = top3[0];
                        top3[0] = tmp;
                    } else if(tmp>top3[1]){
                        top3[2] = top3[1];
                        top3[1] = tmp;
                    } else if(tmp>top3[2]){
                        top3[2] = tmp;
                    }
                }
            } catch (IOException e) {
            }
        }
        for(int i=0; i<3; i++) {
            System.out.println(top3[i]);
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;
public class Main {
	private StringTokenizer st;
	private BufferedReader bf;
	private int w,h,x,y,r;
	
	Main() {
		
		for (int i=1;i<=9;i++) {
			for (int j=1;j<=9;j++) {
				System.out.println(i++j++(i*j));
			}
		}
	}
	
	private void readData() {
		try {
			bf = new BufferedReader(new InputStreamReader(System.in));
			st = new StringTokenizer(bf.readLine());
			
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	
	private String next() throws IOException {
		if (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(bf.readLine());
		return st.nextToken();
	}
	
	public static void main(String[] args) {
		
		Main m = new Main();
	}
}"
Java,"import java.util.Random;
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int[] heights = new int[10];
		for (int i = 0; i < 10; i++) {
			heights[i] = in.nextInt();
		}
		
		quicksort(heights, 0, heights.length - 1);
		
		for (int i = heights.length - 1; i >= heights.length - 3; i--) {
			System.out.println(heights[i]);
		}
	}
	private static void quicksort(int[] data, int start, int end) {
		if (start > end) {
			return;
		}
		int index = partition(data, start, end);
		quicksort(data, start, index - 1);
		quicksort(data, index + 1, end);
	}
	private static int partition(int[] data, int start, int end) {
		int index = -1;
		Random rd = new Random();
		while (index < start || index > end) {
			index = rd.nextInt(end + 1);
		}
		swap(data, index, end);
		int pivot = data[end];
		int i = -1, j = 0;
		for (; j < end; j++) {
			if (data[j] <= pivot) {
				swap(data, ++i, j);
			}
		}
		
		swap(data, ++i, end);
		
		return i;
	}
	private static void swap(int[] data, int i, int j) {
		int tmp = data[i];
		data[i] = data[j];
		data[j] = tmp;
	}
}"
Java,"import java.util.*;
public class Main {
    public static void topThreeHills() {
        
        Scanner scanner = new Scanner(System.in);
        int[] heights = new int[10];
        for (int i = 0; i < heights.length; i++) {
            heights[i] = scanner.nextInt();
        }
        
        /*
        int[] threeHighest = Arrays.copyOfRange(heights, 0, 3);
        for (int i = 3; i < 10; i++) {
            if (heights[i] > threeHighest[0])
                threeHighest[0] = heights[i];
            else if (heights[i] > threeHighest[1])
                threeHighest[1] = heights[i];
            else if (heights[i] > threeHighest[2])
                threeHighest[2] = heights[i];
        }
        System.out.println();
        System.out.println(threeHighest[0]);
        System.out.println(threeHighest[1]);
        System.out.println(threeHighest[2]);
        */
        Arrays.sort(heights);
        System.out.println(heights[9]);
        System.out.println(heights[8]);
        System.out.println(heights[7]);
    }
    public static void main (String args[]) {
        topThreeHills();
    }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main{
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		int productAB;
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (((productAB = sides[0] * sides[1]) % 12) != 0) {
				builder.append(NEGATIVE);
			} else if (productAB * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"public class Main {
    public static void main(String[] args) {
int s=0,s1=0,res = 0;
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 1; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 2; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 3; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 4; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 5; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 6; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 7; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 8; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
for(int cont = 1;cont<10;cont ++)
{
  int n1 = 9; 
  res = n1*cont;
  System.out.println(+n1 ++cont + +res);
  s = n1+1;
  
}
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private StringTokenizer st;
	private BufferedReader bf;
	private int w;
	
	Main() {
		readData();
		
	}	
	private void readData() {
		try {
			bf = new BufferedReader(new InputStreamReader(System.in));
			st = new StringTokenizer(bf.readLine());
			
			int n = nextInt();
			int[] a;
			for (int i = 0;i < n ; i++) {
				a = new int[3];
				a[0] = nextInt();
				a[1] = nextInt();
				a[2] = nextInt();
				Arrays.sort(a);
				
					
				if ((a[0]*a[0]+a[1]*a[1])==a[2]*a[2])
					System.out.println();
				else
					System.out.println();
			}
			
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	
	
	private String next() throws IOException {
		if (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(bf.readLine());
		return st.nextToken();
	}
	
	public static void main(String[] args) {
		
		Main m = new Main();
	}
}"
Java,"import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;
public class Main{
static PrintWriter out;
static InputReader ir;
static void solve(){
 int[] h=ir.nextIntArray(10);
 Arrays.sort(h);
 for(int i=0;i<3;i++) out.println(h[9-i]);
}
public static void main(String[] args) throws Exception{
 ir=new InputReader(System.in);
 out=new PrintWriter(System.out);
 solve();
 out.flush();
}
static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;
 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
 
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }
 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}
 
 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
 
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}
 
 public boolean hasNext(){skip(); return hasNextByte();}
 
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
 
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 public double nextDouble(){return Double.parseDouble(next());}
 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }
 public long[] nextLongArray(int n){
  long[] a=new long[n];
  for(int i=0;i<n;i++) a[i]=nextLong();
  return a;
 }
 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}"
Java,"import java.util.*;
import java.lang.*;
public class Main
{
    public static void main (String[] args) throws java.lang.Exception
	{
        
        int top = 0;
        int second = 0;
        int third = 0;
        int wk = 0;
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int height = sc.nextInt();
            
            if( !(0 <= height && height <= 10000)) {
                continue;
            }
            
            if (top < height) {
                wk = top;
                top = height;
                height = wk;
            }
            if (second < height) {
                wk = second;
                second = height;
                height = wk;
            }
            if (third < height) {
                wk = third;
                third = height;
                height = wk;
            }
	    }
        
        System.out.println(top);
        System.out.println(second);
        System.out.println(third);
    }   
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in),1024);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"public class Main{
  public static void main(String[] args){
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
  }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;
public class Main {
    final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    final String LINE_SPR = System.getProperty();
    final int BIG_MOD = 1000000007;
    void run() throws Exception {
        String line;
        while((line = br.readLine()) != null) {
            String[] nums = line.split();
            int a = Integer.parseInt(nums[0]);
            int b = Integer.parseInt(nums[1]);
            int sum = a + b;
            int c = 0;
            while(sum > 0) {
                sum /= 10;
                c++;
            }
            System.out.println(c);
        }
    }
    /*
     * Templates
     */
    void dumpObjArr(Object[] arr, int n) {
        for(int i = 0; i < n; i++) {
            System.out.print(arr[i]);
            if(i < n - 1)
                System.out.print();
        }
        System.out.println();
    }
    void dumpObjArr2(Object[][] arr, int m, int n) {
        for(int j = 0; j < m; j++) 
            dumpObjArr(arr[j], n);
    }
    int ni() throws Exception {
        return Integer.parseInt(br.readLine().trim());
    }
    long nl() throws Exception {
        return Long.parseLong(br.readLine().trim());
    }
    String ns() throws Exception {
        return br.readLine();
    }
    boolean isPrime(int n) {
        for(int i=2;i<n;i++) {
            if(n%i==0)
                return false;
        }
        return true;
    }
    int getPrime(int n) {
        List<Integer> primes = new ArrayList<Integer>();
        primes.add(2);
        int count = 1;
        int x = 1;
        while(primes.size() < n) {
            x+=2;
            int m = (int)Math.sqrt(x);
            for(int p : primes) {
                if(p > m) {
                    primes.add(x);
                    break;
                }
                if(x % p == 0) 
                    break;
            }
        }
        return primes.get(primes.size() - 1);
    }
    void gcjPrint(String str, int t) {
        System.out.println( + t +  + str);
    }
    public static void main(String[] args) throws Exception {
        new Main().run();
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;
public class Main {
	private StringTokenizer st;
	private BufferedReader bf;
	private int w;
	
	Main() {
		readData();
		
	}
	
	private void readData() {
		try {
			bf = new BufferedReader(new InputStreamReader(System.in));
			st = new StringTokenizer(bf.readLine());
			
			int[] h = new int[10];
			for (int i=0;i<10;i++) {
				h[i] = nextInt();
			}
			Arrays.sort(h);
			
			for (int i=9;i>6;i--) {
				System.out.println(h[i]);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	
	private String next() throws IOException {
		if (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(bf.readLine());
		return st.nextToken();
	}
	
	public static void main(String[] args) {
		
		Main m = new Main();
	}
}"
Java,"import java.util.Scanner;
class Main{
        public static void main(String[] args){
                Scanner scan = new Scanner(System.in);
                int data=0;
                int top[] = new int[3];
                top[0]=0;
                top[1]=0;
                top[2]=0;
                for(int i=0;i<10;i++){
                        data=scan.nextInt();
                        if(data>top[2]){
                                if(data>top[1]){
                                        if(data>top[0]){
                                                top[2]=top[1];
                                                top[1]=top[0];
                                                top[0]=data;
                                                continue;
                                        }
                                        top[2]=top[1];
                                        top[1]=data;
                                        continue;
                                }
                                top[2]=data;
                                continue;
                        }
                }
                System.out.println(top[0]++top[1]++top[2]);
                
        }
}"
Java,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
public class Main {
	Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		@SuppressWarnings()
		Scanner sc = new Scanner(System.in);
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		int num3 = sc.nextInt();
		int num4 = sc.nextInt();
		int num5 = sc.nextInt();
		int num6 = sc.nextInt();
		int num7 = sc.nextInt();
		int num8 = sc.nextInt();
		int num9 = sc.nextInt();
		int num10 = sc.nextInt();
		checkNum(num1);
		checkNum(num2);
		checkNum(num3);
		checkNum(num4);
		checkNum(num5);
		checkNum(num6);
		checkNum(num7);
		checkNum(num8);
		checkNum(num9);
		checkNum(num10);
		List<Integer> list = new ArrayList<Integer>();
		list.add(num1);
		list.add(num2);
		list.add(num3);
		list.add(num4);
		list.add(num5);
		list.add(num6);
		list.add(num7);
		list.add(num8);
		list.add(num9);
		list.add(num10);
		Collections.sort(list);
		Collections.reverse(list);
		for(int cnt = 0; cnt < 3; cnt++){
			System.out.println(list.get(cnt));
		}
	}
	public static void checkNum(int x){
		if(x < 0 || 10000 < x){
			throw new IllegalArgumentException();
		}
	}
}"
Java,"import java.io.*;
class Main {
	public static void main(String args[]) {
		try {
			BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
			String s[], t;
			int i, j, ans, l, m;
			boolean flag = false;
			while((t = reader.readLine()) != null) {
				s = t.split();
				i = s[0].length()-1 >= s[1].length()-1 ? s[0].length()-1 : s[1].length()-1;
				j = s[0].length()-1 <= s[1].length()-1 ? s[0].length()-1 : s[1].length()-1;
				l = s[0].length()-1 >= s[1].length()-1 ? 0 : 1;
				int a[][] = {new int[i+1], new int[j+1]};
				for(int k = 0;k < i+1;k++) {
					a[0][k] = s[l].charAt(k)-'0';
				}
				int f = Math.abs(l-1);
				for(int k = 0;k < j+1;k++) {
					a[1][k] = s[f].charAt(k)-'0';
				}
				while(i>=0) {
					if(j >= 0)
						m = a[1][j];
					else
						m = 0;
					a[0][i] = a[0][i] + m;
					if(a[0][i]>9) {
						if(i>0) {
							a[0][i] %= 10; 
							a[0][i-1]++;
						}
						else if(i==0){
							flag = true;
							break;
						}
					}
					i--;
					j--;
				}
				ans = flag ? a[0].length+1 : a[0].length;
				System.out.println(ans);
				flag = false;
			}
		}
		catch(IOException e) {
			System.out.println(e);
		}
	}
}"
Java,class Main{public static void main(String a[]){System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();}}
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
class Main {
    private static final int MOUNTAIN_COUNT = 10;
    public static void main(final String[] args) throws IOException, NumberFormatException {
        Integer[] mountainHeights = new Integer[10];
        BufferedReader input = null;
        try {
            input = new BufferedReader(new InputStreamReader(System.in));
            for (int i = 0; i < MOUNTAIN_COUNT; i++) {
                mountainHeights[i] = Integer.parseInt(input.readLine());
            }
        } finally {
            if (input != null) {
                input.close();
            }
        }
        Arrays.sort(mountainHeights, new Comparator<Integer>() {
            @Override
            public int compare(final Integer lhs, final Integer rhs) {
                return rhs.compareTo(lhs);
            }
        });
        for (int i = 0; i < 3; i++) {
            System.out.println(mountainHeights[i]);
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Stack;
import java.util.Scanner;
import java.util.Queue;
/**
 * @author yoshikyoto
 */
class Main{
	static final boolean DEBUG = false;
	static Scanner sc = new Scanner(new InputStreamReader(System.in));
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
	public static void main(String args[]) throws Exception{
		int[] m = new int[10];
		for(int i = 0; i < 10; i++) m[i] = readInt();
		Arrays.sort(m);
		for(int i = 0; i < 3; i++) p(m[9-i]);
	}
	public static String readLine() throws IOException{return br.readLine();}
	public static int readInt(){return sc.nextInt();}
	public static void pa(Object[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(int[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(double[] arr){System.out.println(Arrays.toString(arr));}
	public static void pa(boolean[] arr){System.out.println(Arrays.toString(arr));}
	public static void p(Object o){System.out.println(o.toString());}
	public static void d(Object o){if(DEBUG)System.out.println(o.toString());}
	public static int[] parseInt(String[] arr){
		int[] res = new int[arr.length];
		for(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);
		return res;
	}
	public static int parseInt(Object o){return Integer.parseInt(o.toString());};
}
class MyHashMap<E> extends HashMap<E, Integer>{
	ArrayList<E> keyArray = new ArrayList<E>();
	public void add(E key){add(key, 1);}
	public void add(E key, Integer value){
		if(containsKey(key)){
			value += get(key);
		}else{
			keyArray.add(key);
		}
		put(key, value);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main {
	public static void main(String[] a) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1);
		String str = ;
		StringTokenizer st;
		int num[] = new int[3];
		int index[] = new int[2];
		int max = 0, i, j, k;
		
		str = br.readLine();
		int datasets =  Integer.parseInt(str);
		
		for (i = 0; i < datasets; i++) {
			str = br.readLine();
			st = new StringTokenizer(str, );
			num[0] = Integer.parseInt(st.nextToken());
			num[1] = Integer.parseInt(st.nextToken());
			num[2] = Integer.parseInt(st.nextToken());
			for (j =0; j < 3; j++) 
	            if(num[max] < num[j]) max = j;
			k = 0;
			for (j = 0; j < 3; j++) 
	            if(num[j] != num[max]) index[k++] = j;
			if ((num[max] * num[max]) == (num[index[0]] * num[index[0]] + num[index[1]] * num[index[1]]))
				System.out.println();
			else
				System.out.println();
		}
	}
}"
Java,"import java.io.*;
import java.util.*;
class Main{
	private static ArrayList<Integer> sum_dig(ArrayList<Integer> a){
		ArrayList<Integer> b = new ArrayList<Integer>();
		for(int i = 0;i<a.size()/2;i++){
			int sum = 0;
			if(i == 0) sum = a.get(0)+a.get(1);
			sum =  a.get(i*2)+a.get(i*2+1);
			String sums;
			sums = String.valueOf(sum);
			b.add(sums.length());
			}
		return b;
	}
	private static void print_dig(ArrayList<Integer> a){
		for(int i = 0;i<a.size();i++){
			System.out.println(a.get(i));
		}
	}
		public static void main(String args[]) throws IOException{
			ArrayList<Integer> dig = new ArrayList<Integer>();
			Scanner scan = new Scanner(System.in);
			int n1,n2;
			while(scan.hasNext()){
				try{
				String str1 = scan.next();
				String str2 = scan.next();
				
				n1 = Integer.parseInt(str1);
				n2 = Integer.parseInt(str2);
				dig.add(n1);
				dig.add(n2);
			}
			catch(NumberFormatException e){
				break;
			}
		}
			ArrayList<Integer> res = new ArrayList<Integer>();
			res = sum_dig(dig);
			print_dig(res);
	}
}"
Java,"import java.util.Scanner;
public class Main {
	private final static int LIST_MAX = 10;
	private final static int INPUT_MIN = 0;
	private final static int INPUT_MAX = 10000;
	
	public static void main(String[]args){
		int Mt_list[];
		Mt_list = input();
		
		sort(Mt_list);
		
		show(Mt_list);
	}
	
	public static void show(int[] list){
		for(int i = 0;i < 3;i++){
			System.out.println(list[i]);
		}
	}
	
	public static int[] input(){
		Scanner stdIn = new Scanner(System.in);
		int list[] = new int[LIST_MAX];
		
		for(int i = 0;i < LIST_MAX;i++){
			int tmp = stdIn.nextInt();
			if(input_ck(tmp)){
				list[i] = tmp;
			}else{
				continue;
			}
		}
		
		stdIn.close();
		return list;
	}
	
	public static boolean input_ck(int x){
		if(INPUT_MIN <= x && x <= INPUT_MAX){
			return true;
		}
		return false;
	}
	
	public static int[] sort(int[] list){
		for(int i = 0;i < LIST_MAX - 1;i++){
			for(int j = LIST_MAX - 1;j >= i + 1;j--){
				if(list[j - 1] < list[j]){
					int work = list[j - 1];
					list[j - 1] = list[j];
					list[j] = work;
				}
			}
		}
		return list;
	}
}"
Java,"class Main {
  public static void main (String[] args) {
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
    System.out.println();
  }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.util.*;
import java.io.*;
public class Main {
    static IO io = new IO();
    public static void main(String[] args) {
        while (io.hasNext()) System.out.println(String.valueOf(io.nextInt()+io.nextInt()).length());
    }
    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;
        IO() {
            this(System.in);
        }
        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }
        boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }
        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }
        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }
        boolean isNewLine(int c) {
            return c == '\\n' || c == '\\r';
        }
        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }
        void skipNewLine() {
            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;
        }
        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }
        boolean hasNextLine() {
            skipNewLine();
            return hasNextByte();
        }
        String next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }
        char[] nextCharArray(int len) {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            char[] s = new char[len];
            int i = 0;
            int b = readByte();
            while (isPrintableChar(b)) {
                if (i == len) {
                    throw new InputMismatchException();
                }
                s[i++] = (char) b;
                b = readByte();
            }
            return s;
        }
        String nextLine() {
            if (!hasNextLine()) {
                throw new NoSuchElementException();
            }
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (!isNewLine(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }
        long nextLong() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) {
                throw new NumberFormatException();
            }
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) {
                    return minus ? -n : n;
                } else {
                    throw new NumberFormatException();
                }
                b = readByte();
            }
        }
        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {
                throw new NumberFormatException();
            }
            return (int) nl;
        }
        char nextChar() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return (char) readByte();
        }
        double nextDouble() {
            return Double.parseDouble(next());
        }
        int[] arrayInt(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = nextInt();
            return a;
        }
        long[] arrayLong(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) a[i] = nextLong();
            return a;
        }
        double[] arrayDouble(int n) {
            double[] a = new double[n];
            for (int i = 0; i < n; i++) a[i] = nextDouble();
            return a;
        }
        void arrayInt(int[]... a) {
            for (int i = 0; i < a[0].length; i++) for (int j = 0; j < a.length; j++) a[j][i] = nextInt();
        }
        int[][] matrixInt(int n, int m) {
            int[][] a = new int[n][];
            for (int i = 0; i < n; i++) a[i] = arrayInt(m);
            return a;
        }
        char[][] charMap(int n, int m) {
            char[][] a = new char[n][];
            for (int i = 0; i < n; i++) a[i] = nextCharArray(m);
            return a;
        }
        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException e) {
            }
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in),1024);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;
class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			String tmp = in.readLine();
			if (tmp == null) {
				break;
			}
			String[] ab = tmp.split();
			int a = Integer.parseInt(ab[0]);
			int b = Integer.parseInt(ab[1]);
			 String out =Integer.toString(a+b);
			 System.out.println(out.length());
			
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.StringTokenizer;
public class Main {
  static InputReader in;
  static PrintWriter out;
  
  static class Solution {
    void solve() throws IOException {
      int[] height = new int[10];
      int first;
      int second;
      int third;
      
      
      height[0] = in.nextInt();
      int max = height[0];
      int memmax = 0;
      
      for (int i = 1; i < 10; i++) {
        height[i] = in.nextInt();
        max = Math.max(max, height[i]);
        if (max == height[i]) {
          memmax = i;
        }
      }
      first = max;
      
      height[memmax] = -1;
      max = height[0];
      memmax = 0;
      for (int i = 1; i < 10; i++) {
        max = Math.max(max, height[i]);
        if (max == height[i]) {
          memmax = i;
        }
      }
      second = max;
      
      height[memmax] = -1;
      max = height[0];
      memmax = 0;
      for (int i = 1; i < 10; i++) {
        max = Math.max(max, height[i]);
        if (max == height[i]) {
          memmax = i;
        }
      }
      third = max;
      
      out.println(first);
      out.println(second);
      out.println(third);
      
    }
}
  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out);
    Solution solver = new Solution();
    solver.solve();
    out.close();
}
  static class InputReader {
    public BufferedReader br;
    public StringTokenizer st;
    public InputReader(InputStream stream) {
      br = new BufferedReader(new InputStreamReader(stream));
    }
    public int nextInt() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Integer.parseInt(st.nextToken());
    }
    public long nextLong() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Long.parseLong(st.nextToken());
    }
    public String next() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return st.nextToken();
    }
    public double nextDouble() throws IOException {
      while (st == null || !st.hasMoreTokens()) {
        st = new StringTokenizer(br.readLine());
      }
      return Double.parseDouble(st.nextToken());
    }
  }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
public class Main {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		String lineCountStr = br.readLine();
		
		for (int lineCount = 0; lineCount < Integer.parseInt(lineCountStr); lineCount ++) {
			String[] dataSetStr = br.readLine().split();
			int[] dataSet = new int[dataSetStr.length];
			for (int i = 0; i < dataSetStr.length; i ++) {
				dataSet[i] = Integer.parseInt(dataSetStr[i]);
			}
			
			if (dataSet[0] > dataSet[1]) {
				int tmp = dataSet[0];
				dataSet[0] = dataSet[1];
				dataSet[1] = tmp;
			}
			if (dataSet[1] > dataSet[2]) {
				int tmp = dataSet[1];
				dataSet[1] = dataSet[2];
				dataSet[2] = tmp;
			}
			
			if (Math.pow(dataSet[0], 2) + Math.pow(dataSet[1], 2) == Math.pow(dataSet[2], 2)) {
				System.out.println();
			} else {
				System.out.println();
			}
		}
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
	public static void main(String[] args) throws IOException{
	    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	    int i;
		int [] mountain;
		int escape = 0;
		mountain = new int[10];
		/*
		mountain[0] = 2362;
		mountain[1] = 1121;
		mountain[2] = 1462;
		mountain[3] = 1896;
		mountain[4] = 1082;
		mountain[5] = 2362;
		mountain[6] = 953;
		mountain[7] = 1545;
		mountain[8] = 3532;
		mountain[9] = 1170;
		*/
		/*System.out.println();
		for(int i = 0; i < 10; i++) {
			System.out.println(mountain[i]);
		}
		*/
		for(i=0;i<10;i++)
	        mountain[i]=Integer.parseInt(br.readLine());
		
		for(int a = 0; a < 9; a++) {
		    for(int b = a + 1; b < 10; b++) {
		    	if(mountain[a] < mountain[b]) {
		    		escape = mountain[b];
					mountain[b] = mountain[a];
					mountain[a] = escape;
				}
		    }
		    
		}
		
		System.out.println(mountain[0]);
        System.out.println(mountain[1]);
        System.out.println(mountain[2]);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Comparator;
import static java.util.Arrays.sort;
public class Main {
    public static void main(String[] args) throws IOException {
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br   = new BufferedReader(isr);
        PrintWriter out     = new PrintWriter(System.out);
        int i = 0;
        String line;
        String[] numList = new String[2];
        try {
            while ((line = br.readLine()) != null) {
                numList = line.split();
                int num0 = Integer.parseInt(numList[0]);
                int num1 = Integer.parseInt(numList[1]);
                int sum = num0 + num1;
                System.out.println((int)Math.log10(sum) + 1);
            }
        } catch (Exception e) {
            System.exit(0);
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
/**
 * 0002：Digit Number
 * 
 * @author MS14A
 * @version 2015/07/11
 */
public class Main {
    
    private static final String DELIMITER_SPACE = ;
    /**
     * 与えられた２つの整数 a と b の和の桁数を出力する。
     * 
     * @param args
     * @throws IOException
     * @throws NumberFormatException
     */
    public static void main(String[] args) throws NumberFormatException, IOException {
        
        List<Integer> a = new ArrayList<Integer>();
        List<Integer> b = new ArrayList<Integer>();
        getTarget(a, b);
        
        for (int i = 0; i < a.size(); ++i) {
            System.out.println(getDigitNumber(a.get(i) + b.get(i)));
        }
    }
    /**
     * 与えられた数の桁数を求める
     * 
     * @param target 桁数を求める整数
     * @return 引数の桁数
     */
    private static int getDigitNumber(int target) {
        return String.valueOf(target).length();
    }
    /**
     * 標準入力を読み取り、データセットを取得する。
     * 
     * @param a 1つ目の整数
     * @param b 2つ目の整数
     * @throws NumberFormatException
     * @throws IOException
     */
    private static void getTarget(List<Integer> a, List<Integer> b) throws NumberFormatException, IOException {
        
        InputStreamReader streamReader = new InputStreamReader(System.in);
        BufferedReader bufferedReader = new BufferedReader(streamReader);
        String line = null;
        try {
            while ((line = bufferedReader.readLine()) != null) {
                
                String[] ab = line.split(DELIMITER_SPACE);
                a.add(Integer.parseInt(ab[0]));
                b.add(Integer.parseInt(ab[1]));
            }
        } finally {
            bufferedReader.close();
            streamReader.close();
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
/**
 * 0002：Digit Number
 * 
 * @author MS14A
 * @version 2015/07/11
 */
public class Main {
    /**
     * 与えられた２つの整数 a と b の和の桁数を出力する。
     * 
     * @param args
     * @throws IOException 
     * @throws NumberFormatException 
     */
    public static void main(String[] args) throws NumberFormatException, IOException {
        List<Integer> a = new ArrayList<Integer>();
        List<Integer> b = new ArrayList<Integer>();
        getTarget(a, b);
        
        for (int i = 0; i < a.size(); ++i) {
            System.out.println(getDigitNumber(a.get(i)+b.get(i)));
        }
    }
    private static int getDigitNumber(int target) {
        return String.valueOf(target).length();
    }
    private static void getTarget(List<Integer> a, List<Integer> b) throws NumberFormatException, IOException {
        
        InputStreamReader streamReader = new InputStreamReader(System.in);
        BufferedReader bufferedReader = new BufferedReader(streamReader);
        String line = null;
        try {
            while ((line = bufferedReader.readLine()) != null) {
                String[] ab = line.split();
                a.add(Integer.parseInt(ab[0]));
                b.add(Integer.parseInt(ab[1]));
            }
        } finally {
            bufferedReader.close();
            streamReader.close();
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main{
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        try {
            Integer dataNum = Integer.valueOf(in.readLine());
            for (int i = 0; i < dataNum.intValue(); i++) {
                String[] problemData = in.readLine().split();
                int max = 0;
                int other1 = 0;
                int other2 = 0;
                for (String data : problemData) {
                    int dataInt = Integer.valueOf(data);
                    other2 = other1;
                    if (dataInt > max) {
                        other1 = max;
                        max = dataInt;
                    } else {
                        other1 = dataInt;
                    }
                }
                if ((max * max) == (other1 * other1 + other2 * other2)) {
                    System.out.println();
                } else {
                    System.out.println();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in),1024);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.Exception;
import java.lang.Integer;
import java.lang.System;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
    public static void main(String[] a){
        try {
            BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
            int n = Integer.parseInt(r.readLine());
            StringTokenizer st;
            int side[] = new int[3];
            for(int i = 0; i < n; i++) {
                st = new StringTokenizer(r.readLine());
                for(int j = 0; j < 3; j++) {
                    side[j] = Integer.parseInt(st.nextToken());
                }
                Arrays.sort(side);
                if((side[0]*side[0] + side[1]*side[1]) == side[2]*side[2]) {
                    System.out.println();
                } else {
                    System.out.println();
                }
            }
        } catch (Exception ex) {
            System.exit(0);
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 512);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.*;
import java.util.*;
import java.math.BigInteger;
public class Main{
	
	public static void main(String[] args){
		try{
			final int INF = Integer.MAX_VALUE, MINF = Integer.MIN_VALUE;
			SpecialComparator scomparator = new SpecialComparator();
			Scanner s = new Scanner(System.in);
			
			int[] in = new int[10];
			for(int i = 0; i < 10; i++) in[i] = s.nextInt();
			Arrays.sort(in);
			for(int i = 0; i < 3; i++) debugl(in[9-i]);
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	private static void debugl(Object obj){
		System.out.println(obj);
	}
	private static void debug(Object obj){
		System.out.print(obj);
	}
	private static String toStrmd(Object[] obj){
		return Arrays.deepToString(obj);
	}
}
class SpecialComparator implements Comparator{
	private int index = 0;
	public void setIndex(int index){
		this.index = index;
	}
	public int compare(Object a, Object b){
		String[] sa = (String[])a;
		String[] sb = (String[])b;
		return (sa[index].compareTo(sb[index]));
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws IOException {
        final String SPACE = ;
        final String EMPTY = ;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        try {
            String str = br.readLine();
            int a;
            int b;
            String[] temp = new String[2];
            for (int i = 0; i < 200; i++) {
                
                if (EMPTY.equals(str) || str == null) {
                    break;
                }
                temp = str.split(SPACE);
                a = Integer.parseInt(temp[0]);
                b = Integer.parseInt(temp[1]);
                sb.append(String.valueOf(a + b).length() + );
                str = br.readLine();
            }
        } catch (IOException e) {
            
        } finally {
            if (br != null) {
                br.close();
            }
        }
        System.out.print(sb);
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
	public static void main(String[] args) throws IOException {
		
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int[] best = {0, 0, 0};		
        
        for(int i=0; i<10; i++){
            String line = br.readLine();			
            int height = Integer.parseInt(line);	
        	
            if(height > best[0]){	
            	best[2] = best[1];
            	best[1] = best[0];
            	best[0] = height;
            }
            else if(height > best[1]){
            	best[2] = best[1];
            	best[1] = height;
            }
            else if(height > best[2]){
            	best[2] = height;
            }
        }
        
        for(int h: best){
        	System.out.println(h);
        }
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = ;
        while ((line = br.readLine()) != null && !line.isEmpty()) {
            int N = Integer.parseInt(line);
            next:
            for (int i = 0; i < N; i++) {
                int[] num = new int[3];
                StringTokenizer st = new StringTokenizer(br.readLine());
                num[0] = Integer.parseInt(st.nextToken());
                num[1] = Integer.parseInt(st.nextToken());
                num[2] = Integer.parseInt(st.nextToken());
                num[0] *= num[0];
                num[1] *= num[1];
                num[2] *= num[2];
                for (int j = 0; j < 3; j++) {
                    if (num[j % 3] == num[(j + 1) % 3] + num[(j + 2) % 3]) {
                        System.out.println();
                        continue next;
                    }
                }
                System.out.println();
            }
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try {
			String s;
			int input = Integer.parseInt(br.readLine());
			List<String> rightAngleList = new ArrayList<String>();
			for (int i = 1; i <= input; i++) {
				s = br.readLine();
				String[] num = s.split();
				Integer[] side = convertArray(num);
				if (1 <= side[0] && side[0] <= 1000 && 1 <= side[1]
						&& side[1] <= 1000 && 1 <= side[2] && side[2] <= 1000) {
					Arrays.sort(side);
					if (side[2] * side[2] == side[1] * side[1] + side[0]
							* side[0]) {
						rightAngleList.add();
					} else {
						rightAngleList.add();
					}
				} else {
					break;
				}
			}
			String[] rightAngles = rightAngleList.toArray(new String[0]);
			for(String rightAngle : rightAngles){
				System.out.println(rightAngle);
			}
		} finally {
			br.close();
		}
	}
	public static Integer[] convertArray(String[] str) {
		List<Integer> list = new ArrayList<Integer>();
		for (String num : str) {
			list.add(Integer.parseInt(num));
		}
		return list.toArray(new Integer[0]);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    
    private static final int NUMBER_OF_INPUT = 2;
    /**
     * 空白区切りの2つの数字を受け取り、その2つの数字の合計値の桁数を出力する。
     *
     * @param args
     */
    public static void main(String[] args) throws IOException {
        
        String line = null;
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        while((line = reader.readLine()) != null) {
            
            int[] input = convertStringToIntArray(line);
            
            int sum = calculateSum(input);
            int numberOfDigit = getNumberOfDigit(sum);
            
            System.out.println(numberOfDigit);
        }
        if (reader != null) {
            reader.close();
        }
     }
    /**
     * 空白区切りの数値を取得し、整数の配列として返却する。
     *
     * @param line 空白区切りの数値文字列
     * @return 整数の配列
     */
    protected static int[] convertStringToIntArray(String line){
        int [] result = new int[NUMBER_OF_INPUT];
        String[] splittedLine = line.split();
        for( int i = 0; i < splittedLine.length; i++){
            result[i] = Integer.parseInt(splittedLine[i]);
        }
        return result;
    }
    /**
     * 引数で渡された整数配列の合計値を返す。
     *
     * @param input 整数の配列
     * @return 整数の配列の合計値
     */
    protected static int calculateSum(int[] input) {
        int sum = 0;
        for (int i = 0; i < input.length; i++) {
            sum += input[i];
        }
        return sum;
    }
    /**
     * 指定された数値の桁数を返す。
     *
     * @param target 数値
     * @return 数値の桁数
     */
    protected static int getNumberOfDigit(int target) {
        
        return String.valueOf(target).length();
    }
}"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
import Data.IORef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
toSecond h m s = s + (m + h * 60) * 60
toHMSStr s = intercalate "":"" $ map show' [div s 3600, (flip mod 60 . flip div 60) s, mod s 60]
  where show' n = if n<10 then ""0"" ++ show n else show n
main = takeWhile (any (/=(-1))) . map (map readInt . words) . lines <$> getContents >>= mapM_ (\\[h,m,s] -> let remain = toSecond 2 0 0 - toSecond h m s in putStrLn (toHMSStr remain) >> putStrLn (toHMSStr (3 * remain)))"
Haskell,"import Data.Array.IO
import Data.List.Split
main = do
    inks <- fmap (map (map read.splitOn "","").lines)getContents
    f <- newArray ((0,0),(9,9)) 0 :: IO (IOArray (Int,Int) Int)
    field <- dropInks f inks
    inkDepth <- getElems field
    print $ length.filter (== 0) $ inkDepth
    print $ maximum inkDepth
dropInks :: IOArray (Int,Int) Int -> [[Int]] -> IO (IOArray (Int,Int) Int)
dropInks field [] = return field
dropInks field (x:xs) = do
    field' <- dropInk field x
    dropInks field' xs
dropInk :: IOArray (Int,Int) Int -> [Int] -> IO (IOArray (Int,Int) Int)
dropInk f [x,y,size] = mapM_ (flip (modifyField f) (+1)) region >> return f
    where region = getRegion [x,y,size]
getRegion [x,y,n] = case n of
                 1 -> [(i,j) | i <- [x-1..x+1], j <- [y-1..y+1], abs (i-x) + abs (j-y) <= 1]
                 2 -> [(i,j) | i <- [x-1..x+1], j <- [y-1..y+1]]
                 3 -> [(i,j) | i <- [x-2..x+2], j <- [y-2..y+2], abs (i-x) + abs (j-y) <= 2]
modifyArray a i f = writeArray a i =<< fmap f (readArray a i)
modifyField :: IOArray (Int,Int) Int -> (Int,Int) -> (Int->Int) -> IO ()
modifyField field ix func = do
    bound <- getBounds field
    if ix `elem` range bound then modifyArray field ix func
                             else return ()
printField :: IOArray (Int,Int) Int -> IO ()
printField f = do
    es <- mapM (\\i -> mapM (readArray f) [(x,y) | x <- [i], y <- [0..9]]) [0..9]
    mapM_ putStrLn $ map (unwords.map show) $ es"
Haskell,"import Data.Array.IO
import Data.Char
import System.IO
import Control.Monad
import Control.Applicative
{-
 - list から 1, 2 個選んで残りも一緒に返す
 - 2個選ぶときは順序付きのペアだとする (x,y) と (y,x) を一般に区別する
 - > one [1..6]
 - [(1,[2,3,4,5,6]),(2,[3,4,5,6,1]),(3,[4,5,6,2,1]),(4,[5,6,3,2,1]),(5,[6,4,3,2,1]),(6,[5,4,3,2,1])]
 - > two [1..6]
 - [(1,2,[3,4,5,6]),(1,3,[4,5,6,2]),(1,4,[5,6,3,2]),(1,5,[6,4,3,2]),(1,6,[5,4,3,2]),(2,3,[4,5,6,1]),(2,4,[5,6,1,3]),(2,5,[6,1,4,3]),(2,6,[1,5,4,3]),(2,1,[6,5,4,3]),(3,4,[5,6,2,1]),(3,5,[6,2,1,4]),(3,6,[2,1,5,4]),(3,2,[1,6,5,4]),(3,1,[2,6,5,4]),(4,5,[6,3,2,1]),(4,6,[3,2,1,5]),(4,3,[2,1,6,5]),(4,2,[1,3,6,5]),(4,1,[2,3,6,5]),(5,6,[4,3,2,1]),(5,4,[3,2,1,6]),(5,3,[2,1,4,6]),(5,2,[1,3,4,6]),(5,1,[2,3,4,6]),(6,5,[4,3,2,1]),(6,4,[3,2,1,5]),(6,3,[2,1,4,5]),(6,2,[1,3,4,5]),(6,1,[2,3,4,5])]
-}
one :: [a] -> [(a, [a])]
one xs = sub xs []
  where
    sub [] _ = []
    sub (x:xs) ac = (x, xs++ac) : (sub xs (x:ac))
two :: [a] -> [(a, a, [a])]
two [] = []
two [a] = []
two xs = do
  (x, rest) <- one xs
  do
    (y, rest) <- one rest
    return (x, y, rest)
data Expr = Val Int | Add Expr Expr | Sub Expr Expr | Mul Expr Expr
type Number = (Expr, Int)
eval :: Number -> Int
eval = snd
{-
 - n 個の Number に一回演算を適用して出来る (n-1) 個の Number を返す
 -}
apply :: [Number] -> [[Number]]
apply xs = concat $ do
  ((e, x), (f, y), rest) <- two xs
  return [
    (Add e f, x + y) : rest,
    (Sub e f, x - y) : rest,
    (Mul e f, x * y) : rest
    ]
{-
 - (bfs n xs) は xs に何度か apply を適用して
 - 評価結果が n になる Number を返す
 -}
bfs :: Int -> [[Number]] -> [Number]
bfs n [] = []
bfs n ([x] : rest) =
  (if (eval x) == n then [x] else []) ++ (bfs n rest)
bfs n (xs : rest) = bfs n (rest ++ (apply xs))
instance Show Expr where
  show (Val n) = show n
  show (Add e f) = ""("" ++ show e ++ "" + "" ++ show f ++ "")""
  show (Sub e f) = ""("" ++ show e ++ "" - "" ++ show f ++ "")""
  show (Mul e f) = ""("" ++ show e ++ "" * "" ++ show f ++ "")""
toVal :: Int -> Number
toVal n = (Val n, n)
solve a b c d = do
  let anss = bfs 10 [[toVal a, toVal b, toVal c, toVal d]]
  if null anss
    then print 0
    else print $ fst $ head $ anss
main = do
  [a,b,c,d] <- (map read . words)<$>getLine :: IO [Int]
  if (minimum [a,b,c,d]) == 0
    then return ()
    else solve a b c d >> main"
Haskell,"combi :: Int -> Int -> Int
combi n s
    | s <= 45   = (combis !! (n - 1)) s
    | otherwise = 0
    where
        combi1 :: Int -> Int
        combi1 s1 = if elem s1 [0 .. 9] then 1 else 0
        combi2 s2 = sum [1 | k1 <- [0 .. 9], k2 <- [k1 + 1 .. 9], k1 + k2 == s2]
        combi3 s3 = sum [1 | k1 <- [0 .. 9], k2 <- [k1 + 1 .. 9], k3 <- [k2 + 1 .. 9], k1 + k2 + k3 == s3]
        combi4 s4 = sum [1 | k1 <- [0 .. 9], k2 <- [k1 + 1 .. 9], k3 <- [k2 + 1 .. 9],
            k4 <- [k3 + 1 .. 9], k1 + k2 + k3 + k4 == s4]
        combi5 s5 = sum [1 | k1 <- [0 .. 9], k2 <- [k1 + 1 .. 9], k3 <- [k2 + 1 .. 9],
            k4 <- [k3 + 1 .. 9], k5 <- [k4 + 1 .. 9],  k1 + k2 + k3 + k4 + k5 == s5]
        combi6 s6 = combi4 (45 - s6)
        combi7 s7 = combi3 (45 - s7)
        combi8 s8 = combi2 (45 - s8)
        combi9 s9 = combi1 (45 - s9)
        combis = [combi1, combi2, combi3, combi4, combi5, combi6, combi7, combi8, combi9]
main :: IO ()
main = interact $ unlines . map show . map (\\[n, s] -> combi n s) . map (map read) . map words . takeWhile (/= ""0 0"") . lines"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Text.Printf
main :: IO ()
main = do
  n <- inp toInt
  xs <- inpn n $ splt toDbl
  mapM_ (\\[x,y,z] -> printf ""%.3f %.3f %.3f\\n"" (round3 x) (round3 y) (round3 z)) $ solve xs
solve :: [[Double]] -> [[Double]]
solve = map ccircle
ccircle :: [Double] -> [Double]
ccircle (x0:y0:x1:y1:x2:y2:_) = (fromPoint . head $ intersect pla plb) ++ [r]
  where
    p0 = toPoint x0 y0
    p1 = toPoint x1 y1
    p2 = toPoint x2 y2
    va = toVector p1 p0
    vb = toVector p2 p0
    vc = toVector p2 p1
    st = abs $ crossVector va vb / (lenVector va * lenVector vb)
    r = lenVector vc / (2.0 * st)
    la = sqrt $ r ^ 2 - (lenVector va / 2.0) ^ 2
    lb = sqrt $ r ^ 2 - (lenVector vb / 2.0) ^ 2
    pca = cntPoint p0 p1
    pcb = cntPoint p0 p2
    vua = toUVector $ toNVector va
    vub = toUVector $ toNVector vb
    pla = [mvPoint pca (mulSVector la vua), mvPoint pca (mulSVector (negate la) vua)]
    plb = [mvPoint pcb (mulSVector lb vub), mvPoint pcb (mulSVector (negate lb) vub)]
    
toInt :: String -> Int
toInt s = read s
toDbl :: String -> Double
toDbl s = read s
splt :: (String -> a) -> String -> [a]
splt f = map f . words
inp :: (String -> a) -> IO a
inp f = f <$> getLine
inpn :: Int -> (String -> a) -> IO [a]
inpn n f = map f <$> replicateM n getLine
round3 :: Double -> Double
round3 = (/ 1000) . fromIntegral . round . (* 1000)
data Point = Point Double Double deriving Show
data Vector = Vector Double Double deriving Show
toPoint :: Double -> Double -> Point
toPoint x y = Point x y
fromPoint :: Point -> [Double]
fromPoint (Point x y) = [x, y]
cntPoint :: Point -> Point -> Point
cntPoint (Point x0 y0) (Point x1 y1) = toPoint ((x0 + x1) / 2.0) ((y0 + y1) / 2.0)
toVector :: Point -> Point -> Vector
toVector (Point x0 y0) (Point x1 y1) = Vector (x1 - x0) (y1 - y0)
toNVector :: Vector -> Vector
toNVector (Vector x y) = Vector (negate y) x
toUVector :: Vector -> Vector
toUVector (Vector x y) = Vector (x / l) (y / l)
  where l = sqrt $ x ^ 2 + y ^ 2
mulSVector :: Double -> Vector -> Vector
mulSVector s (Vector x y) = Vector (s * x) (s * y)
lenVector :: Vector -> Double
lenVector (Vector x y) = sqrt $ x ^ 2 + y ^ 2
crossVector :: Vector -> Vector -> Double
crossVector (Vector x0 y0) (Vector x1 y1) = x0 * y1 - x1 * y0
mvPoint :: Point -> Vector -> Point
mvPoint (Point px py) (Vector vx vy) = toPoint (px + vx) (py + vy)
instance Eq Point where
  (Point x0 y0) == (Point x1 y1) = (abs (x0 - x1) < 0.000000001) && (abs (y0 - y1) < 0.000000001)"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import qualified Data.Vector.Unboxed as V
import qualified Data.Vector.Unboxed.Mutable as VM
sieve :: Int -> V.Vector Bool
sieve upto = runST $ do
    s <- VM.replicate (upto+1) True
    VM.write s 0 False
    VM.write s 1 False
    forM_ [2..(ceiling.sqrt.fromIntegral $ upto)] $ \\i -> do
        isP <- VM.read s i
        when isP $ forM_ [i*i, i*i+i..upto] (\\n -> VM.write s n False)
    V.unsafeFreeze s
primes :: Int -> [Int]
primes = V.toList . V.map fst . V.filter snd . V.imap (,) . sieve
findRange :: Ord a => [a] -> a -> (a,a)
findRange (x:p@(y:_)) a = if x < a && not (y < a)
                              then (x, head . dropWhile (<= a) $ p)
                              else findRange p a
main = do
    let
        ps = primes 50100
        f = findRange ps
    getContents >>=
        mapM_ ((\\(p0,p1) -> putStrLn . unwords . map show $ [p0,p1])
                . f . read) . lines"
Haskell,"main = getContents >>= putStr . solve
solve :: String -> String
solve = unlines . map (isIn . toTuples . map read . words) . lines
cross :: (Float, Float) -> (Float, Float) -> Float
cross a b = (fst a) * (snd b) - (snd a) * (fst b)
toTuples :: [Float] -> [(Float, Float)]
toTuples [] = []
toTuples (x1:x2:xs) = (x1,x2) : toTuples xs
sub :: (Float, Float) -> (Float, Float) -> (Float, Float)
sub a b = (fst a - fst b, snd a - snd b)
isIn :: [(Float, Float)] -> String
isIn [a,b,c,p]
  | counterClockWise || clockWise = ""YES""
  | otherwise = ""NO""
    where
      counterClockWise= cross (b `sub` a) (p `sub` b) > 0 && cross (c `sub` b) (p `sub` c) > 0 && cross (a `sub` c) (p `sub` a) > 0
      clockWise = cross (b `sub` a) (p `sub` b) < 0 && cross (c `sub` b) (p `sub` c) < 0 && cross (a `sub` c) (p `sub` a) < 0"
Haskell,"import Text.Printf
import Control.Monad
len :: Int
len = 8
grid :: Int -> Int -> [Bool] -> Bool
grid x y dat = (dat!!((x-1)+(y-1)*len))
getfalse :: Int -> Int -> [Bool] -> [Bool]
getfalse x y dat = map edit [0..((length dat)-1)]
    where edit i = if i==((x-1)+(y-1)*len) then False 
                   else (dat!!i)
explode :: Int -> Int -> [Bool] -> [Bool]
explode x y dat
    | (x<1 || y<1 || x>len || y>len)  = dat 
    | grid x y dat                    =     
        (explode (x+1) y) $ (explode (x+2) y) $  (explode (x+3) y) $ 
        (explode (x-1) y) $ (explode (x-2) y) $  (explode (x-3) y) $ 
        (explode x (y+1)) $ (explode x (y+2)) $  (explode x (y+3)) $
        (explode x (y-1)) $ (explode x (y-2)) $  (explode x (y-3)) $
        getfalse x y dat
    | otherwise                       = dat 
printres :: Int -> [Bool] -> IO ()
printres i res = do
    printf ""Data %d:\\n"" i
    let s = map (\\x->if x then '1' else '0') res
    let s' = map (\\i -> drop (i*len) $ take ((i+1)*len) s) [0..(len-1)]
    mapM_ putStrLn s'
solve :: Int -> IO ()
solve i = do
    dummy<-getLine
    str<-replicateM len getLine 
    x<-readLn::IO Int
    y<-readLn::IO Int
    let dat = map (\\x->(x=='1')) $ foldr (++) """" str
    printres i $ explode x y dat
main :: IO ()
main = do
    n_data<-readLn::IO Int
    mapM_ solve [1..n_data]"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
toFunc :: Char -> Int -> Int -> Int
toFunc '+' = (+)
toFunc '-' = (-)
toFunc '*' = (*)
ordering = [(1,2,3), (3,2,1), (1,2,1), (2,1,3), (3,1,2)]
opset = [[p,q,r] | p <- ""+-*"", q <- ""+-*"", r <- ""+-*""]
calc :: [Int] -> [Char] -> (Int,Int,Int) -> Maybe String
calc [a,b,c,d] [p,q,r] brs = guard (value == 10) $> text
  where
    (value, text) = case brs of
      (1,2,3) -> (((a `fp` b) `fq` c) `fr` d, oper (oper (oper sa p sb) q sc) r sd)
      (3,2,1) -> (a `fp` (b `fq` (c `fr` d)), oper sa p (oper sb q (oper sc r sd)))
      (1,2,1) -> ((a `fp` b) `fq` (c `fr` d), oper (oper sa p sb) q (oper sc r sd))
      (2,1,3) -> ((a `fp` (b `fq` c)) `fr` d, oper (oper sa p (oper sb q sc)) r sd)
      (3,1,2) -> (a `fp` ((b `fq` c) `fr` d), oper sa p (oper (oper sb q sc) r sd))
    [sa,sb,sc,sd] = map show [a,b,c,d]
    [fp,fq,fr] = map toFunc [p,q,r]
    oper x op y = '(' : x ++ op : y ++ "")""
f :: [Int] -> String
f ns = fromMaybe ""0"" $ getFirst $ Foldable.foldMap First [calc m o r | m <- permutations ns, o <- opset, r <- ordering]
main = takeWhile (any (/=0)) . map (map readInt . words) . lines <$> getContents >>= mapM_ (putStrLn . f)"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
main :: IO ()
main = do
  xs <- getl $ wrds toInt
  unless (all (==0) xs) $ do
    putStrLn $ solve xs
    main
data Expr = N Int | Op Char Expr Expr
f1 :: [Char] -> [Int] -> Expr
f1 [o1,o2,o3] [n1,n2,n3,n4] = Op o2 (Op o1 (N n1) (N n2)) (Op o3 (N n3) (N n4))
f2 :: [Char] -> [Int] -> Expr
f2 [o1,o2,o3] [n1,n2,n3,n4] = Op o3 (Op o2 (Op o1 (N n1) (N n2)) (N n3)) (N n4)
f3 :: [Char] -> [Int] -> Expr
f3 [o1,o2,o3] [n1,n2,n3,n4] = Op o3 (Op o1 (N n1) (Op o2 (N n2) (N n3))) (N n4)
f4 :: [Char] -> [Int] -> Expr
f4 [o1,o2,o3] [n1,n2,n3,n4] = Op o1 (N n1) (Op o3 (Op o2 (N n2) (N n3)) (N n4))
f5 :: [Char] -> [Int] -> Expr
f5 [o1,o2,o3] [n1,n2,n3,n4] = Op o1 (N n1) (Op o2 (N n2) (Op o3 (N n3) (N n4)))
calc :: Expr -> Int
calc (N x) = x
calc (Op '+' l r) = calc l + calc r
calc (Op '*' l r) = calc l * calc r
calc (Op '-' l r) = calc l - calc r
instance Show Expr where
  show (N x) = show x
  show (Op o l r) = ""(""++ show l ++ [' ',o,' '] ++ show r ++ "")""
solve :: [Int] -> String
solve xs
  | null ls = ""0""
  | otherwise = show . head $ ls
  where
    ls = filter ((== 10) . calc) [f [o1,o2,o3] ns | ns <- permutations xs, o1 <- ""*+-"", o2 <- ""*+-"", o3 <- ""*+-"", f <- [f1,f2,f3,f4,f5]]
toInt :: String -> Int
toInt s = read s
wrds :: (String -> a) -> String -> [a]
wrds f = map f . words
getl :: (String -> a) -> IO a
getl f = f <$> getLine"
Haskell,"main :: IO()
main = getContents >>= mapM_ (print . solve . read) . lines
solve :: Int -> Int
solve n | n < 100     = length $ takeWhile (<= n) primes
        | n < 1000    = (25 +)     . f $ [101, 103..n]
        | n < 10000   = (168 +)    . f $ [1001, 1003..n]
        | n < 100000  = (1229 +)   . f $ [10001, 10003..n]
        | n < 200000  = (9592 +)   . f $ [100001, 100003..n]
        | n < 300000  = (17984 +)  . f $ [200001, 200003..n]
        | n < 400000  = (25997 +)  . f $ [300001, 300003..n]
        | n < 500000  = (33860 +)  . f $ [400001, 400003..n]
        | n < 600000  = (41538 +)  . f $ [500001, 500003..n]
        | n < 700000  = (49098 +)  . f $ [600001, 600003..n]
        | n < 800000  = (56543 +)  . f $ [700001, 700003..n]
        | n < 900000  = (63951 +)  . f $ [800001, 800003..n]
        | n >= 999983 && n < 1000000 = 78498
        | n < 1000000 = (71724 +)  . f $ [900001, 900003..n]
    where f = length . (filter isPrime)
primes :: [Int]
primes = (2 :) . (3 :) . (5 :) . (7 :) $ filter isPrime [11, 13..] 
isPrime :: Int -> Bool
isPrime 2 = True
isPrime n
    | n < 2            = False
    | (n `mod` 2) == 0 = False
    | otherwise        = testDiv 3 n
    where testDiv :: Int -> Int -> Bool
          testDiv i n
              | i * i > n      = True
              | n `mod` i == 0 = False
              | otherwise      = testDiv (i + 2) n"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Fixed
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
blankline = replicate 11 '0'
hline ws = '0' : '0' : concat [[w, '0'] | w <- ws] ++ ['0']
vline ws = '0' : concat [[w,'0'] | w <- ws]
f walls = 'R' : f' walls (1, 3) 'R'
f' _ (1,1) _ = []
f' walls (y,x) 'R'
  | walls!(y-1,x) == '1' = 'U' : f' walls (y-2, x) 'U'
  | walls!(y,x+1) == '1' = 'R' : f' walls (y, x+2) 'R'
  | walls!(y+1,x) == '1' = 'D' : f' walls (y+2, x) 'D'
  | otherwise            = 'L' : f' walls (y, x-2) 'L'
f' walls (y,x) 'D'
  | walls!(y,x+1) == '1' = 'R' : f' walls (y, x+2) 'R'
  | walls!(y+1,x) == '1' = 'D' : f' walls (y+2, x) 'D'
  | walls!(y,x-1) == '1' = 'L' : f' walls (y, x-2) 'L'
  | otherwise            = 'U' : f' walls (y-2, x) 'U'
f' walls (y,x) 'L'
  | walls!(y+1,x) == '1' = 'D' : f' walls (y+2, x) 'D'
  | walls!(y,x-1) == '1' = 'L' : f' walls (y, x-2) 'L'
  | walls!(y-1,x) == '1' = 'U' : f' walls (y-2, x) 'U'
  | otherwise            = 'R' : f' walls (y, x+2) 'R'
f' walls (y,x) 'U'
  | walls!(y,x-1) == '1' = 'L' : f' walls (y, x-2) 'L'
  | walls!(y-1,x) == '1' = 'U' : f' walls (y-2, x) 'U'
  | walls!(y,x+1) == '1' = 'R' : f' walls (y, x+2) 'R'
  | otherwise            = 'D' : f' walls (y+2, x) 'D'
main = do
    ws <- replicateM 9 getLine
    let ds = blankline : zipWith (\\i t -> (cond hline vline $ odd i) t) [1..9] ws ++ [blankline]
    let walls = listArray ((0,0),(10,10)) $ concat ds
    putStrLn $ f walls"
Haskell,"emptyList :: [Int]
emptyList = replicate 9 0
add :: Int -> Int -> [Int] -> [Int]
add 1 x (a:d) = ((a+x):d)
add i x (a:d) = (a : add (i-1) x d)
get :: Int -> [Int] -> Int
get 1 (a:d) = a
get i (a:d) = get (i-1) d
readNums :: [Char] -> [Int]
readNums [] = emptyList
readNums (c:s) = add (read [c]) 1 $ readNums s
deletePung :: [Int] -> [Int]
deletePung s = add 1 (-3) s
deleteChow :: [Int] -> [Int]
deleteChow s = add 3 (-1) $ add 2 (-1) $ add 1 (-1) s
judge :: [Int] -> Bool
judge [] = True
judge (x:(y:(z:r)))
    | x>=3 && y>=1 && z>=1 = or [judge $ deletePung s, judge $ deleteChow s]
    | x>=1 && y>=1 && z>=1 = judge $ deleteChow s
    | x>=3 = judge $ deletePung s
    | x==0 = judge $ tail s
    | otherwise = False
    where s = (x:(y:(z:r)))
judge (x:s) 
    | x==0 = judge s
    | x>=3 = judge $ deletePung (x:s)
judge _ = False
checkAny :: [Int] -> Bool
checkAny [] = False
checkAny s = any (\\i -> (get i s)>=2 && judge (add i (-2) s)) [1..9]
result :: [Int] -> [Int]
result s = filter (\\i -> (get i s)<=3 && checkAny (add i 1 s)) [1..9]
resultStr str = if null s then ""0"" else unwords $ map show s
    where s = result $ readNums str
main = getContents >>= mapM putStrLn . map resultStr . lines
    "
Haskell,"main = getContents >>= putStr . solve
solve :: String -> String
solve = unlines . map (isIn . toTuples . map read . words) . lines
cross :: (Float, Float) -> (Float, Float) -> Float
cross a b = (fst a) * (snd b) - (snd a) * (fst b)
toTuples :: [Float] -> [(Float, Float)]
toTuples [] = []
toTuples (x1:x2:xs) = (x1,x2) : toTuples xs
sub :: (Float, Float) -> (Float, Float) -> (Float, Float)
sub a b = (fst a - fst b, snd a - snd b)
isIn :: [(Float, Float)] -> String
isIn [a,b,c,p]
  | counterClockWise || clockWise = ""YES""
  | otherwise = ""NO""
    where
      counterClockWise= cross (b `sub` a) (p `sub` b) > 0 && cross (c `sub` b) (p `sub` c) > 0 && cross (a `sub` c) (p `sub` a) > 0
      clockWise = cross (b `sub` a) (p `sub` b) < 0 && cross (c `sub` b) (p `sub` c) < 0 && cross (a `sub` c) (p `sub` a) < 0"
Haskell,"import Control.Monad
import Control.Applicative
import Control.Monad.State
type Weight = Int
type Counters = [Weight]
type WeightState = (Weight, Counters)
solve :: State WeightState Weight
solve = do
  (weight, counters) <- get
  if weight == 0
    then return weight
    else do
      case weight of
        weight | weight >= 2^9 -> put (weight - 2^9, 2^9 : counters)
               | weight >= 2^8 -> put (weight - 2^8, 2^8 : counters)
               | weight >= 2^7 -> put (weight - 2^7, 2^7 : counters)
               | weight >= 2^6 -> put (weight - 2^6, 2^6 : counters)
               | weight >= 2^5 -> put (weight - 2^5, 2^5 : counters)
               | weight >= 2^4 -> put (weight - 2^4, 2^4 : counters)
               | weight >= 2^3 -> put (weight - 2^3, 2^3 : counters)
               | weight >= 2^2 -> put (weight - 2^2, 2^2 : counters)
               | weight >= 2^1 -> put (weight - 2^1, 2^1 : counters)
               | weight >= 2^0 -> put (weight - 2^0, 2^0 : counters)
      solve
main = do
  contents <- (map (snd . (\\x -> execState solve (x, [])) . (read :: String -> Int))) . lines <$> getContents
  putStr $ unlines $ map (unwords . (map show)) contents"
Haskell,"main = getContents >>= putStr . solve
solve :: String -> String
solve = unlines . map (isIn . toTuples . map read . words) . lines
cross :: (Float, Float) -> (Float, Float) -> Float
cross a b = (fst a) * (snd b) - (snd a) * (fst b)
toTuples :: [Float] -> [(Float, Float)]
toTuples [] = []
toTuples (x1:x2:xs) = (x1,x2) : toTuples xs
sub :: (Float, Float) -> (Float, Float) -> (Float, Float)
sub a b = (fst a - fst b, snd a - snd b)
isIn :: [(Float, Float)] -> String
isIn [a,b,c,p]
  | counterClockWise || clockWise = ""YES""
  | otherwise = ""NO""
    where
      counterClockWise= cross (b `sub` a) (p `sub` b) > 0 && cross (c `sub` b) (p `sub` c) > 0 && cross (a `sub` c) (p `sub` a) > 0
      clockWise = cross (b `sub` a) (p `sub` b) < 0 && cross (c `sub` b) (p `sub` c) < 0 && cross (a `sub` c) (p `sub` a) < 0"
Haskell,"import qualified Data.IntMap.Lazy as M
import Data.IntMap.Lazy ((!))
import Data.Char
import Data.List
type Atlas = M.IntMap Bool
type Coordinate = Int
size = 12
main = interact $ unlines . map (show . num_of_island) . read' . lines
 where
  read' [] = []
  read' xs = read_atlas (concat (take size xs)) : read' (drop (size+1) xs)
num_of_island :: Atlas -> Int
num_of_island a = num_to_fix paint_island a
paint_island :: Atlas -> Atlas
paint_island a
 | or (M.elems a) = foldr (\\i a' -> M.adjust not i a') a (contiguous_from start a)
 | otherwise = a
    where start = head $ M.keys $ M.filter id a
num_to_fix :: Eq a => (a -> a) -> a -> Int
num_to_fix f x = if f x == x then 0 else 1 + num_to_fix f (f x)
read_atlas :: String -> Atlas
read_atlas = M.fromList . zip [0..] . map to_boolean
 where to_boolean d = case d of {'0'->False; '1'->True}
contiguous_from :: Coordinate -> Atlas -> [Coordinate]
contiguous_from i a = M.keys $ M.filterWithKey (\\i' _ -> are_contiguous i i' a) a
are_contiguous :: Coordinate -> Coordinate -> Atlas -> Bool
are_contiguous c1 c2 a = if a!c1 /= a!c2 then False else investigate c1 []
 where
  investigate c trace
   | c == c2 = True
   | a!c /= a!c2 = False
   | otherwise = or $ map (flip investigate (c:trace)) (neighbors c \\\\ trace) 
neighbors :: Coordinate -> [Coordinate]
neighbors c = filter (not . is_outside) [pred c, succ c, c-size, c+size]
 where
  is_outside c' = is_westout c' || is_eastout c' || is_northout c' || is_southout c'
   where
    is_westout c' = div c size == succ (div c' size) && c == succ c'
    is_eastout c' = div c size == pred (div c' size) && c == pred c'
    is_northout c' = c' < 0
    is_southout c' = c' >= size*size
  "
Haskell,"import Control.Applicative
import Control.Monad
main :: IO ()
main = solve <$> replicateM 9 f >>= putStrLn
  where
    f = map g <$> getLine
    g '0' = False
    g '1' = True
solve :: [[Bool]] -> String
solve mp = f (0, 0) [R]
  where
    f (i, j) (R:rs)
      | i > 0 && mp !! (i-1) !! (j+1) = f (i-1, j+1) (U:R:rs)
      | j < 3 && mp !! i !! (j+1) = f (i, j+1) (R:R:rs)
      | i < 8 && mp !! (i+1) !! (j+1) = f (i+1, j+1) (D:R:rs)
      | otherwise = f (i, j) (L:R:rs)
    f (i, j) (D:rs)
      | j < 4 && mp !! (i+1) !! j = f (i+1, j) (R:D:rs)
      | i < 7 && mp !! (i+2) !! j = f (i+2, j) (D:D:rs)
      | j > 0 = f (i+1, j-1) (L:D:rs)
      | otherwise = f (i, j) (U:D:rs)
    f (0, 0) (L:rs) = concatMap show . reverse $ L:rs
    f (i, j) (L:rs)
      | i < 8 && mp !! (i+1) !! j = f (i+1, j) (D:L:rs)
      | j > 0 && mp !! i !! (j-1) = f (i, j-1) (L:L:rs)
      | i > 0 && mp !! (i-1) !! j = f (i-1, j) (U:L:rs)
      | otherwise = f (i, j) (R:L:rs)
    f (1, 0) (U:rs) = concatMap show . reverse $ U:rs
    f (i, j) (U:rs)
      | j > 0 && mp !! (i-1) !! (j-1) = f (i-1, j-1) (L:U:rs)
      | i > 1 && mp !! (i-2) !! j = f (i-2, j) (U:U:rs)
      | j < 4 && mp !! (i-1) !! j = f (i-1, j) (R:U:rs)
      | otherwise = f (i, j) (D:U:rs)
data Dir = R | D | L | U deriving (Show, Eq)"
Haskell,"{-# LANGUAGE BangPatterns #-}
import Control.Monad
import Control.Applicative
addFixed :: [Int] -> [Int] -> [Int]
addFixed = iter 0 where
    iter s [] []
        | s == 0 = []
        | p == 0 = [q]
        | otherwise = [q,p]
        where (p,q) = s `divMod` 10
    iter s xs [] = iter s xs [0]
    iter s [] ys = iter s [0] ys
    iter !s (x:xs) (y:ys) = let
        (surp,n) = (x+y+s) `divMod` 10
        in n: iter surp  xs ys
f :: String -> String -> String
f n m = let
    n' = map (read . return) . reverse $ n
    m' = map (read . return) . reverse $ m
    in concatMap show . reverse $ addFixed n' m'
g :: String -> String -> String
g n m = let
    n' = read n :: Integer
    m' = read m :: Integer
    in show (n'+m')
main = do
    n <- readLn
    replicateM_ n $ do
        x <- reverse . map (read . return) <$> getLine
        y <- reverse . map (read . return) <$> getLine
        let s = concatMap show . reverse $ addFixed x y
        putStrLn $ if length s > 80
                        then ""overflow""
                        else s"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
import GHC.ST
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
linev (x1,y1) (x2,y2) (x,y) = (y2-y1)*x - (x2-x1)*y - x1*y2 + x2*y1
f p1 p2 p3 p = f1 p1 * f1 p > 0 && f2 p2 * f2 p > 0 && f3 p3 * f3 p > 0
  where
    f1 = linev p2 p3
    f2 = linev p3 p1
    f3 = linev p1 p2
main = map (map (apply2 (,)) . splitRec 2 . map readDouble . words) . lines <$> getContents >>= mapM_ (putStrLn . cond ""YES"" ""NO"" . apply4 f)
    "
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
judge c s = any (all ((==c) . (s!!))) $ [[t..t+2] | t <- [0,3,6]] ++ [[t,t+3,t+6] | t <- [0..2]] ++ [[0,4,8], [2,4,6]]
f s = cond ""o"" (cond ""x"" ""d"" $ judge 'x' s) $ judge 'o' s
main = map f . lines <$> getContents >>= mapM_ putStrLn"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array.IO
import Data.IORef
import Control.Monad.ST
import Data.STRef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
f (x,y) 1 = [x,y]
f (x,y) n = f (x+dx,y+dy) (n-1)
  where
    r = sqrt $ x ^ 2 + y ^ 2
    dx = (-y) / r
    dy = x / r
main = map (f (1,0)) . takeWhile (/=(-1)) . map readInt . lines <$> getContents >>= mapM_ (mapM_ print)"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Fixed
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
f :: [(Double,Double)] -> [(Double,Double)]
f ps = firstP : sub firstP 0
  where
    sub p a = let np = nextP p a in if np==firstP then [] else np : sub np (angle $ diff p np)
    firstP = minimumBy (comparing snd <> flip (comparing fst)) ps
    nextP p a = minimumBy (comparing (da a . angle . diff p)) (delete p ps)
    diff (x1,y1) (x,y) = (x-x1,y-y1)
    angle (x,y) = atan2 y x
    da a na = mod' (na - a) (2*pi)
main = do
    n <- getInt
    unless (n==0) $ do
        ps <- map (apply2 (,) . map readDouble . wordsBy (==',')) <$> replicateM n getLine
        print $ n - length (f ps)
        main"
Haskell,"import Data.Text as T
import Data.Text.Encoding as E
import Data.ByteString (ByteString)
dummyInput :: String
dummyInput = ""1819\\n2003\\n876\\n2840\\n""
rdrop :: Int -> [a] -> [a]
rdrop x y = Prelude.reverse (Prelude.drop x (Prelude.reverse y))
deleteReturnCode :: [Char] -> [Char]
deleteReturnCode x = rdrop 1 x
convertList :: Text -> [Int]
convertList x =
  let charcter = T.pack ""\\n""
  in Prelude.map convertInt (Prelude.map T.unpack (T.splitOn charcter x))
convertInt :: String -> Int
convertInt x = read x :: Int
sortHeight :: (Ord a) => [a] -> [a]
sortHeight [] = []
sortHeight [x] = [x]
sortHeight (x:xs) =
  let largeList = [a | a <- xs, a > x];
      smallList = [a | a <- xs, a <= x]
  in sortHeight smallList ++ [x] ++ sortHeight largeList
showTopThree :: (Ord a) => [a] -> [a]
showTopThree [] = []
showTopThree x = (Prelude.take 3 (Prelude.reverse x))
main :: IO ()
main = do
  inputData <- getContents
  mapM_ print (showTopThree (sortHeight (convertList (T.pack (deleteReturnCode inputData)))))"
Haskell,"import Control.Monad.State
import Control.Monad.Reader
import Data.Array.IArray
import Data.Array.IO
data Direction = R | L | U | D  deriving (Eq, Show)
type Field = Array (Int, Int) [Direction]
type IOField = IOArray (Int, Int) [Direction]
type Walk a = StateT Direction (StateT (Int, Int) (ReaderT Field IO)) a
main = do
  field <- getField
  flip runReaderT field $ flip evalStateT (0,0) $ evalStateT walkStep R
modifyArray arr ix f = do
  e <- readArray arr ix
  writeArray arr ix (f e)
getField :: IO Field
getField = do
  field <- newArray ((0,0), (4,4)) []
  e <- getAssocs field
  input <- replicateM 9 getLine
  forM_ [0..3] $ \\i -> do
    let i' = i*2
    horizonFill i (input !! i') field
    verticalFill i (input !! (i'+1)) field
  horizonFill 4 (input !! 8) field
  freeze field
horizonFill :: Int -> String -> IOField -> IO ()
horizonFill i flags field = do
  forM_ [0..3] $ \\j -> do
    if flags !! j == '1'
       then modifyArray field (i,j) (R :) >> modifyArray field (i, j+1) (L:)
       else return ()
verticalFill :: Int -> String -> IOField -> IO ()
verticalFill i flags field = forM_ [0..4] $ \\j -> do
  if flags !! j == '1'
     then modifyArray field (i,j) (D:) >> modifyArray field (i+1 ,j) (U:)
     else return ()
walkStep :: Walk ()
walkStep = do
  direction <- getDirection
  walkTo direction
  goal <- isGoalNow
  if goal then endStep
          else walkStep
getDirection :: Walk Direction
getDirection = do
  pos <- lift $ get
  field <- lift $ ask
  dir <- get
  return $ gd dir pos field
gd :: Direction -> (Int, Int) -> Field -> Direction
gd d (x,y) field = gd' priorityList walls
  where walls = field ! (x,y)
        priorityList = case d of
                            L -> [D, L, U, R]
                            R -> [U, R, D, L]
                            U -> [L, U, R, D]
                            D -> [R, D, L, U]
gd' :: [Direction] -> [Direction] -> Direction
gd' [] nextDs = error ""invalid field""
gd' (d:ds) nextDs
  | d `elem` nextDs = d
  | otherwise = gd' ds nextDs
walkTo :: Direction -> Walk ()
walkTo d = printdir d >> (lift $ modify nextpos) >> put d
  where nextpos
            | d == L = \\(x,y) -> (x,y-1)
            | d == R = \\(x,y) -> (x,y+1)
            | d == U = \\(x,y) -> (x-1,y)
            | d == D = \\(x,y) -> (x+1,y)
printdir :: Direction -> Walk ()
printdir d = lift . lift . lift $ putStr.show $ d
isGoalNow :: Walk Bool
isGoalNow = do
  (x,y) <- lift get
  return $ x == 0 && y == 0
endStep :: Walk ()
endStep = lift.lift.lift $ putStrLn """""
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
import Data.IORef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
f :: (IOUArray (Int,Int) Char) -> (Int,Int) -> IO ()
f arr p@(y,x) = do
    c <- readArray arr p
    when (c=='1') $ do
        writeArray arr p '0'
        forM_ [1..3] $ \\i -> do
            when (y-i>=1) $ f arr (y-i,x)
            when (y+i<=8) $ f arr (y+i,x)
            when (x-i>=1) $ f arr (y,x-i)
            when (x+i<=8) $ f arr (y,x+i)
main = do
    n <- getInt
    forM_ [1..n] $ \\i -> do
        getLine
        field <- replicateM 8 getLine
        [sx, sy] <- replicateM 2 getInt
        arr <- newListArray ((1,1),(8,8)) $ concat field :: IO (IOUArray (Int,Int) Char)
        f arr (sy,sx)
        res <- sequence [sequence [readArray arr (y,x) | x <- [1..8]] | y <- [1..8]]
        putStrLn $ ""Data "" ++ show i ++ "":""
        mapM_ putStrLn res
        return ()"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.Array
main :: IO ()
main = do
  n <- getl toInt
  when (n /= 0) $ do
    m <- getl toInt
    l <- getl toInt
    d <- getl toInt
    xs <- rgetl d id
    putStrLn $ solve n m l d xs
    main
    
solve :: Int -> Int -> Int -> Int -> [String] -> String
solve n m l d xs
  | goal lots d m == l = ""0""
  | null rs = ""1""
  | otherwise = (show .fst . head) rs ++ "" "" ++ (show . snd . head) rs
  where
    rs = [(i,j) | i <- [1..d], j <- [1..n-1], lots ! (i, j-1) == '0', lots ! (i, j) == '0', lots ! (i, j+1) == '0', goal (lots // [((i,j),'1')]) d m == l ]
    lots = array ((1,0),(d,n)) els
    els = [((i,0),'0')|i <- [1..d]] ++ [((i,n),'0')|i <- [1..d]] ++ [((i,j), xs !! (i-1) !! (j-1))|i <- [1..d], j <- [1..n-1]]
goal :: Array (Int,Int) Char -> Int -> Int -> Int
goal arr d s = foldl f s [1..d]
  where
    f c r
      | arr ! (r, c-1) == '1' = c-1
      | arr ! (r, c) == '1' = c+1
      | otherwise = c
          
toInt :: String -> Int
toInt s = read s
getl :: (String -> a) -> IO a
getl f = f <$> getLine
rgetl :: Int -> (String -> a) -> IO [a]
rgetl n f = map f <$> replicateM n getLine"
Haskell,"import Data.List
main = interact $ unlines . map (show . enclose_pins . map read') . parse' . lines
 where
  parse' = splitBy (notElem ',') . takeWhile (/= ""0"")
  read' str = let [x,y] = map read (splitOn ',' str) in (x,y)
enclose_pins pins = length pins - length sides
 where sides = [(p1,p2)| p1<-pins, p2<-pins, p1<p2, are_counterparts p1 p2 (pins\\\\[p1,p2])]
are_counterparts (x1,y1) (x2,y2) xys =
 alleq $ filter (/= EQ) $ map (\\(x,y) -> compare y (x * slope (x1,y1) (x2,y2) + intercept_y)) xys
  where
   alleq xs = and $ zipWith (==) xs (tail xs)
   intercept_y = snd $ intercept (x1,y1) (x2,y2)
  
slope (x1,y1) (x2,y2)
 | x2 == x1  = (y2-y1) / 1e-9
 | otherwise = (y2-y1) / (x2-x1)
intercept (x1,y1) (x2,y2) = (axis_x, axis_y)
 where
  axis_x = x1 - y1 / slope (x1,y1) (x2,y2)
  axis_y = y1 - x1 * slope (x1,y1) (x2,y2)
splitOn c xs
 | null xs = []
 | head xs == c = splitOn c (tail xs)
 | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)
splitBy p xs
 | null xs = []
 | p (head xs) = splitBy p (tail xs)
 | otherwise = (takeWhile (not.p) xs : splitBy p (dropWhile (not.p) xs))"
Haskell,"import Data.List
import Data.List.Split
plus :: Int -> [Int] -> [Int] -> [Int] -> [Int]
plus (-1) _ _ zs = zs
plus n xs ys zs
  | elem n xs = plus (n-1) xs ys (((ys !! n) + 1):zs)
  | otherwise = plus (n-1) xs ys ((ys !! n):zs)
small :: Int -> Int -> [[Int]] -> [[Int]]
small x y xs = (take (y-1) xs) ++ (a:b:c:(drop (y+2) xs))
  where a = plus 13 [x] (xs !! (y-1)) []
        b = plus 13 [x-1,x,x+1] (xs !! y) []
        c = plus 13 [x] (xs !! (y+1)) []
regular :: Int -> Int -> [[Int]] -> [[Int]]
regular x y xs = (take (y-1) xs) ++ (a:b:c:(drop (y+2) xs))
  where a = plus 13 [x-1,x,x+1] (xs !! (y-1)) []
        b = plus 13 [x-1,x,x+1] (xs !! y) []
	c = plus 13 [x-1,x,x+1] (xs !! (y+1)) []
large :: Int -> Int -> [[Int]] -> [[Int]]
large x y xs = (take (y-2) xs) ++ (a:b:c:d:e:(drop (y+3) xs))
  where a = plus 13 [x] (xs !! (y-2)) []
	b = plus 13 [x-1,x,x+1] (xs !! (y-1)) []
	c = plus 13 [x-2,x-1,x,x+1,x+2] (xs !! y) []
	d = plus 13 [x-1,x,x+1] (xs !! (y+1)) []
	e = plus 13 [x] (xs !! (y+2)) []
solve :: [[Int]] -> [[Int]] -> [[Int]]
solve m [] = m
solve m ([x,y,z]:xs)
  | z == 3 = solve (small x y m) xs
  | z == 4 = solve (regular x y m) xs
  | z == 5 = solve (large x y m) xs
mkMap :: [[Int]]
mkMap = replicate 14 $ replicate 14 0
countZero :: [[Int]] ->	Int
countZero [] = 0
countZero (x:xs) = (length $ elemIndices 0 x) + countZero xs
mold :: [[Int]] -> [[Int]]
mold xs = mold' $ take 10 $ drop 2 xs
  where mold' [] = []
        mold' (x:xs) = (take 10 $ drop 2 x) : mold' xs
printAns :: [[Int]] -> IO ()
printAns xs = do
  print $ countZero xs
  print $ maximum $ map maximum xs
main = getContents >>= printAns . mold . solve mkMap . map (map ((+) 2 . read) . splitOn "","") . lines"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.Array
main :: IO ()
main = do
  xs <- getc split
  mapM_ print $ solve xs
solve :: [[String]] -> [Int]
solve = map noi
noi :: [String] -> Int
noi ss = fst $ foldl count (0, iarr) idx
  where
    iarr = listArray ((0,0),(11,11)) $ concat ss
    idx = [(i,j)|i <- [0..11], j <- [0..11]]
count :: (Int, Array (Int,Int) Char) -> (Int,Int) -> (Int, Array (Int,Int) Char)
count (x, arr) (i,j)
  | arr ! (i,j) == '1' = (x+1, clear arr (i,j))
  | otherwise = (x, arr)
clear :: Array (Int,Int) Char -> (Int,Int) -> Array (Int,Int) Char
clear arr (i,j)
  | i < 0 || i > 11 || j < 0 || j > 11 = arr
  | arr ! (i,j) == '0' = arr
  | otherwise = foldl clear (arr // [((i,j),'0')]) [(i+1,j),(i,j+1),(i-1,j),(i,j-1)]
    
split :: [String] -> [[String]]
split ss
  | null bs = [as]
  | otherwise = as : split (tail bs)
  where
    (as, bs) = span (/= """") ss
getc :: ([String] -> a) -> IO a
getc f = f . lines <$> getContents"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Fixed
import Data.Tuple
import Data.Array.Unboxed
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
primes = runSTUArray $ do
    arr <- newArray (1,999999) 1 :: ST s (STUArray s Int Int)
    writeArray arr 1 0
    forM_ [2..1000] $ \\p -> do
      forM_ [2*p,3*p..999999] $ \\n -> writeArray arr n 0
    forM_ [3..999999] $ \\i -> (+) <$> readArray arr (i-1) <*> readArray arr i >>= writeArray arr i
    return arr
main = map readInt . lines <$> getContents >>= mapM_ (print . (primes!))"
Haskell,"import Data.Array (Array, listArray, bounds, accum, elems)
import System.IO (isEOF)
type Point = (Int,Int)
type Paper = Array Point Int
main = main' initPaper
    where
    main' paper = do
        quit <- isEOF
        if quit then do
            print (length $ filter (==0) $ elems paper)
            print (maximum $ elems paper)
        else do
            line <- getLine
            let
                [x,y,inkSize] = map read $ split ',' line
            main' (dropInk paper (x,y) inkSize)
split :: Char -> String -> [String]
split ch s = case rest of
    """" -> [word]
    _:rest' -> word : split ch rest'
    where
    (word,rest) = break (==ch) s
(<+>) :: Point -> (Int,Int) -> Point
(x,y) <+> (dx,dy) = (x+dx,y+dy)
initPaper :: Paper
initPaper = listArray ((0,0),(9,9)) [0,0..]
inBounds :: Paper -> Point -> Bool
inBounds paper (x,y) = x>=minX && x<=maxX && y>=minY && y<=maxY
    where
    ((minX,minY),(maxX,maxY)) = bounds paper
dropInk :: Paper -> Point -> Int -> Paper
dropInk paper point inkSize = accum (+) paper (zip inkPoints [1,1..])
    where
    inkPoints = filter (inBounds paper) $ map (point <+>) inkShifts
    inkShifts = case inkSize of
        1 -> [(0,0),(1,0),(-1,0),(0,1),(0,-1)] 
        2 -> [(0,0),(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]
        3 -> [(0,0),(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1),
                (2,0),(-2,0),(0,2),(0,-2)]"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import qualified Data.ByteString as BS
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import GHC.ST
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
data IOHeap e = IOHeap (IORef Int) (IOArray Int e)
newIOHeap :: (Ord e) => Int -> e -> IO (IOHeap e)
newIOHeap n d = do
    count <- newIORef 0
    heap <- newArray (1,n) d
    return $ IOHeap count heap
swapH :: (Ord e) => IOHeap e -> Int -> Int -> IO ()
swapH h@(IOHeap count heap) i j = do
    t <- readArray heap i
    readArray heap j >>= writeArray heap i
    writeArray heap j t
siftUpH :: (Ord e) => IOHeap e -> Int -> IO ()
siftUpH h@(IOHeap count heap) i = when (i>1) $ do
    let parent = i `div` 2
    v_i <- readArray heap i
    v_p <- readArray heap parent
    when (v_i < v_p) $ do
        swapH h i parent
        siftUpH h parent
siftDownH :: (Ord e) => IOHeap e -> Int -> IO ()
siftDownH h@(IOHeap count heap) i = do
    n <- readIORef count
    let left = i * 2
    when (left <= n) $ do
        v_l <- readArray heap left
        let right = left + 1
        child <- if right <= n then do
                      v_r <- readArray heap right
                      return $ if v_l < v_r then left else right
                    else return left
        v_i <- readArray heap i
        v_c <- readArray heap child
        when (v_i > v_c) $ do
            swapH h i child
            siftDownH h child
pushH :: (Ord e) => IOHeap e -> e -> IO ()
pushH h@(IOHeap count heap) e = do
    n <- readIORef count
    let n' = n + 1
    writeIORef count n'
    writeArray heap n' e
    siftUpH h n'
popH :: (Ord e) => IOHeap e -> IO e
popH h@(IOHeap count heap) = do
    n <- readIORef count
    writeIORef count (n-1)
    res <- readArray heap 1
    readArray heap n >>= writeArray heap 1
    siftDownH h 1
    return res
emptyH :: IOHeap e -> IO Bool
emptyH h@(IOHeap count heap) = (==0) <$> readIORef count
main = do
    heap <- newIOHeap 2000000 0 :: IO (IOHeap Int)
    map negate <$> getInts >>= mapM_ (pushH heap)
    replicateM 5 (popH heap) >>= putStrLn . sjoin . map negate"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Fixed
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
f ps = firstP : sub firstP 0
  where
    sub p a = let np = nextP p a in if np==firstP then [] else np : sub np (angleFrom p np)
    firstP = minimumBy (comparing snd <> flip (comparing fst)) ps
    nextP p a = minimumBy (comparing (flip mod' (2*pi) . subtract a . angleFrom p)) (delete p ps)
    angleFrom (x0,y0) (x,y) = atan2 (y-y0) (x-x0)
main = do
    n <- getInt
    unless (n==0) $ map (apply2 (,) . map readDouble . wordsBy (==',')) <$> replicateM n getLine >>= print . (n-) . length . f >> main"
Haskell,"import Data.Array (Array,listArray,(!),elems,(//),accum)
import Data.Char (digitToInt)
import Data.List (sort,group)
import System.IO (isEOF)
main = do
    quit <- isEOF
    if quit then return () else do
        input >>= return . solve >>= output
        main
input :: IO [Int]
input = do
    line <- getLine
    return (map digitToInt line)
output :: [Int] -> IO ()
output [] = putStrLn ""0""
output ns = putStrLn $ unwords $ map show ns
solve :: [Int] -> [Int]
solve ns = filter test' [1..9]
    where
    test' n = test (n:ns)
test :: [Int] -> Bool
test ns = not $ null $
    return (counts ns) >>= maxUnder 4 >>= matchPair >>= matchThree >>=
    matchThree >>= matchThree >>= matchThree
type Counts = Array Int Int
counts :: [Int] -> Counts
counts ns = listArray (1,9) [0,0..] //
            (map (\\e->(head e, length e)) $ group $ sort ns)
maxUnder :: Int -> Counts -> [Counts]
maxUnder n cs
    | (maximum $ elems cs) <= n = [cs]
    | otherwise = []
matchPair :: Counts -> [Counts]
matchPair cs = concatMap ($ cs) (map match' [1..9])
    where
    match' n cs
        | cs!n >= 2 = [accum (-) cs [(n,2)]]
        | otherwise = []
matchThree :: Counts -> [Counts]
matchThree cs = concatMap ($ cs) [matchTriple, matchSeries]
matchTriple :: Counts -> [Counts]
matchTriple cs = concatMap ($ cs) (map match' [1..9])
    where
    match' n cs
        | cs!n >= 3 = [accum (-) cs [(n,3)]]
        | otherwise = []
matchSeries :: Counts -> [Counts]
matchSeries cs = concatMap ($ cs) (map match' [1..7])
    where
    match' n cs
        | cs!n >= 1 && cs!(n+1) >= 1 && cs!(n+2) >= 1
            = [accum (-) cs [(n,1),(n+1,1),(n+2,1)]]
        | otherwise = []"
Haskell,"import Control.Monad
import Data.Char
import Data.Maybe
main = do
    n <- readLn
    replicateM n $ plus2num
plus2num = do
    [n1,n2] <- replicateM 2 getLine
    putStrLn $ fromMaybe ""overflow"" $ plusMaybe n1 n2
checkOverFlow :: String -> Maybe String
checkOverFlow str = if length str > 80 then Nothing else Just str
plusMaybe :: String -> String -> Maybe String
plusMaybe n1 n2 = do
    a <- checkOverFlow n1
    b <- checkOverFlow n2
    checkOverFlow $ plus a b
plus :: String -> String -> String
plus n1 n2 = reverse $ plus' 0 (reverse n1) (reverse n2)
plus' :: Int -> String -> String -> String
plus' carry [] []     = if carry == 0 then [] else intToDigit carry:[]
plus' carry (y:ys) [] = n : plus' (digitToInt c) [] ys
    where
        num = digitToInt y + carry
        [c,n] = if num < 10 then '0':show num else show num
plus' carry [] (y:ys) = n : plus' (digitToInt c) [] ys
    where
        num = digitToInt y + carry
        [c,n] = if num < 10 then '0':show num else show num
plus' carry (x:xs) (y:ys) = n:plus' (digitToInt c) xs ys
    where
        num = digitToInt x + digitToInt y + carry
        [c,n] = if num < 10 then '0':show num else show num"
Haskell,"data Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show
showTree :: Show a => Tree a -> String
showTree (Leaf x) = show x
showTree (Branch o t1 t2) = ""("" ++ showTree t1 ++ "" "" ++ [o] ++ "" "" ++ showTree t2 ++ "")""
make :: [Tree Int] -> [Tree Int] -> [Tree Int]
make ts1 ts2 = concatMap (\\ [t1,t2] -> [Branch '+' t1 t2 , Branch '-' t1 t2 , Branch '-' t2 t1 , Branch '*' t1 t2]) $ sequence [ts1 , ts2]
makeAllTree :: [Int] -> [Tree Int]
makeAllTree xs = abcd
    where
        abcd = concat $ [make abc d , make abd c , make acd b , make bcd a , make ab cd , make ac bd , make ad bc]
        abc = concat $ [make ab c , make ac b , make bc a]
        abd = concat $ [make ab d , make ad b , make bd a]
        acd = concat $ [make ac d , make ad c , make cd a]
        bcd = concat $ [make bc d , make bd c , make cd b]
        ab = make a b
        ac = make a c
        ad = make a d
        bc = make b c
        bd = make b d
        cd = make c d
        [a,b,c,d] = sequence [map Leaf xs]
calc :: Tree Int -> Int
calc (Leaf x) = x
calc (Branch '+' x y) = calc x + calc y
calc (Branch '-' x y) = calc x - calc y
calc (Branch '*' x y) = calc x * calc y
calc _ = error ""cannot calc""
solve :: [Int] -> IO ()
solve = putStrLn . maybe ""0"" showTree . foldr (\\ x y -> case x of Nothing -> y ; z -> z) Nothing . map (\\ t -> if calc t == 10 then Just t else Nothing) . makeAllTree
main :: IO ()
main = getContents
    >>= return . takeWhile (/= [0,0,0,0]) . map (map read) . map words . lines
    >>= mapM_ solve"
Haskell,"import Control.Applicative
type Dict = [Content]
type Content = (String, Int)
main = do
  word <- words <$> getLine
  let longest = searchMax $ addWordLens word []
      modeWord = searchMax $ addWords word []
  putStr $ fst modeWord
  putStr "" ""
  putStrLn $ fst longest
addWord :: String -> Dict  -> Dict
addWord word dict = case lookup word dict of
                         Nothing -> (word, 1) : dict
                         Just n -> (word, n+1) : dict
addWords :: [String] -> Dict -> Dict
addWords words dict = foldl (flip addWord) dict words
addWordLen :: String -> Dict -> Dict
addWordLen word dict = case lookup word dict of
                            Nothing -> (word, length word) : dict
                            Just n  -> dict
addWordLens :: [String] -> Dict -> Dict
addWordLens words dict = foldl (flip addWordLen) dict words
searchMax :: Dict -> Content
searchMax = foldl maxNum (""a"",minBound)
maxNum :: Content -> Content -> Content
maxNum (a,na) (b,nb)
  | na >= nb = (a,na)
  | na <  nb = (b,nb)"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
import Data.IORef
import Control.Monad.ST
import Data.STRef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
fact :: Int -> Integer
fact n = runST $ do
    ref <- newSTRef 1 :: ST s (STRef s Integer)
    forM_ [1..n] $ modifySTRef ref . (*) . toInteger
    readSTRef ref
main = getInt >>= print . fact"
Haskell,"import Control.Monad
import Data.Array.IArray
import Data.Char
import System.IO
type Figure     = (FigName,FigPattern)
type FigPattern = (Int,Int) -> [(Int,Int)]
type FigName    = Char
a :: Figure
a = ('A', \\(x,y) -> [(i,j) | i <- [x,x+1], j <- [y,y+1]])
b :: Figure
b = ('B', \\(x,y) ->[(i,j) | i <- [x..x+3], j <- [y]])
c :: Figure
c = ('C', \\(x,y) -> [(i,j) | i <- [x], j <- [y..y+3]])
d :: Figure
d = ('D', \\(x,y) -> [(x,y), (x+1,y-1),(x+1,y),(x+2,y-1)])
e :: Figure
e = ('E', \\(x,y) -> [(x,y),(x,y+1),(x+1,y+1),(x+1,y+2)])
f :: Figure
f = ('F', \\(x,y) -> [(x,y),(x+1,y),(x+1,y+1),(x+2,y+1)])
g :: Figure
g = ('G', \\(x,y) -> [(x,y), (x,y+1), (x+1,y-1), (x+1,y)])
main = do
    eof <- isEOF
    if eof then return ()
           else do
               inputField >>= putStrLn.desideFig.searchFigPos
               main
desideFig pos = map fst $ filter (\\(n,p) -> p (head pos) == pos) [a,b,c,d,e,f,g]
inputField :: IO (Array (Int, Int) Int)
inputField = do
    field <- replicateM 8 (fmap (map digitToInt) getLine)
    eof <- isEOF
    unless eof (getLine >> return ())
    return $ getField field
getField = listArray ((0,0),(7,7)).concat
searchFigPos field = [(x,y) | x <- [0..7], y <- [0..7], field ! (x,y) == 1]"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
readInt = read :: String -> Int
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
judge :: String -> Int -> Int -> ((Int, Int) -> [(Int, Int)]) -> [String] -> Maybe String
judge res w h gen field = res <$ (guard . getAny . foldMap Any . map (all hit) . map gen $ points)
  where
    points = [(x, y) | x <- [0..(8-w)], y <- [0..(8-h)]]
    hit (x, y) = field !! y !! x == '1'
ds :: [(Int, Int)] -> (Int, Int) -> [(Int, Int)]
ds ps (a, b) = [(x+a, y+b) | (x, y) <- ps]
functs = [judge ""A"" 2 2 $ ds [(0,0),(0,1),(1,0),(1,1)], 
          judge ""B"" 1 4 $ ds [(0,0),(0,1),(0,2),(0,3)],
          judge ""C"" 4 1 $ ds [(0,0),(1,0),(2,0),(3,0)],
          judge ""D"" 2 3 $ ds [(1,0),(0,1),(1,1),(0,2)],
          judge ""E"" 3 2 $ ds [(0,0),(1,0),(1,1),(2,1)],
          judge ""F"" 2 3 $ ds [(0,0),(0,1),(1,1),(1,2)],
          judge ""G"" 3 2 $ ds [(1,0),(2,0),(0,1),(1,1)]
          ]
main = do
    ls <- splitWhen null . lines <$> getContents
    forM_ ls $ \\field -> do
        putStrLn $ fromJust $ mconcat $ map ($field) functs"
Haskell,"import           System.IO
import           Text.Printf
import           Data.List
import           Control.Monad
sosuExe :: [Int] -> [Int]
sosuExe (x : tail) = x : (sosuExe $ filter (\\n -> mod n x /= 0) tail)
sosus = sosuExe [2 ..]
yakus :: Int -> [Int]
yakus 1 = []
yakus n = x : next
 where
  x = case filter (\\a -> mod n a == 0) $ filter (\\a -> n >= a) sosus of
    []      -> n
    (w : _) -> w
  next = if x == n then [] else yakus $ div n x
rmi :: Eq a => Int -> [a] -> [a]
rmi n xs = let (h, t) = splitAt n xs in h ++ tail t
interL :: Eq a => [a] -> [a] -> [a]
interL [] _        = []
interL _  []       = []
interL ls (r : rs) = case elemIndex r ls of
  Just x  -> ls !! x : interL (rmi x ls) rs
  Nothing -> interL ls rs
diffL :: Eq a => [a] -> [a] -> [a]
diffL [] _        = []
diffL ls []       = ls
diffL ls (r : rs) = case elemIndex r ls of
  Just x  -> diffL (rmi x ls) rs
  Nothing -> ls
main = do
  (l : r : _) <- fmap (map (yakus . read) . words) getLine
  let res = interL l r
  putStrLn $ printf ""%d %d""
                    (product res)
                    (product $ (diffL l res) ++ (diffL r res) ++ res)
  eof <- isEOF
  unless eof $ main"
Haskell,"import Data.Char
import Data.List
data PatTree = P { bodies :: [[Int]],
                   pieces :: [Int],
                   wastePiece :: [Int]} deriving Show
main = do
    pieces <- fmap (map (sort.map digitToInt).lines) getContents
    mapM_ (printResult.solve) pieces
printResult :: [Int] -> IO ()
printResult xs = if null xs then putStrLn ""0""
                            else putStrLn.unwords.map show  $ xs
solve :: [Int] -> [Int]
solve ps = sort.nub.concat.map searchLastPiece.concat.map (foldl (>>=) [toPatTree (sort ps)]) $ patterns
toPatTree :: [Int] -> PatTree
toPatTree ints = P [] ints ps
    where ps = map snd.filter (\\(a,b) -> a == 4) $ zip (map length.group $ ints) (nub ints)
addPattern :: PatTree -> [Int] -> PatTree
addPattern pattree pat = P (pat:bodies pattree) (pieces pattree \\\\ pat) (wastePiece pattree)
getOrder :: PatTree -> [PatTree]
getOrder pats = map (addPattern pats).searchOrder.pieces $ pats 
searchOrder xs = [ [x,y,z] | x <- xs', y <- xs' \\\\ [x], z <- xs' \\\\ [x,y], [x,y,z] == [x..x+2]]
    where xs' = nub xs
getTriple :: PatTree -> [PatTree]
getTriple pats = map (addPattern pats).searchTriple.pieces $ pats 
searchTriple xs = nub $ [[x,y,z] | x <- xs, y <- xs \\\\ [x], z <- xs \\\\ [x,y], x == y && y == z]
getHead :: PatTree -> [PatTree]
getHead pats = map (addPattern pats).searchHead.pieces $ pats 
searchHead xs = nub $ [[x,y] | x <- xs, y <- xs \\\\ [x], x == y]
patterns = [[a,b,c,d] | a <- [getTriple,getOrder], b <- [getTriple,getOrder], c <- [getTriple, getOrder], d <- [getTriple,getOrder]] ++ [[getHead,a,b,c] | a <- [getTriple,getOrder], b <- [getTriple,getOrder],c <- [getTriple, getOrder]]
searchLastPiece :: PatTree -> [Int] 
searchLastPiece pat = case length (pieces pat) of
                        1 -> lastHead pat
                        otherwise -> lastPiece pat
lastHead :: PatTree -> [Int] 
lastHead pat = if any (== (head.pieces $ pat)) (wastePiece pat) then []
                                                                else [head.pieces $ pat]
lastPiece :: PatTree -> [Int]
lastPiece pat = filter (\\x -> 1 <= x && x <= 9).filter (not.flip elem (wastePiece pat)) $ n
    where n  
            | pieces pat == [i,i] = [i]
            | pieces pat == [i,i+1] = [i-1,i+2]
            | pieces pat == [i,i+2] = [i+1]
            | otherwise = []
          i = head.pieces $ pat
          j = i+1"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
import GHC.ST
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
calc :: [Double] -> String
calc [a,b,c,d,e,f] = printf ""%.3f %.3f"" fx fy
  where
    det = a*e - b*d
    det1 = c*e - b*f
    det2 = a*f - c*d
    x = det1 / det
    y = det2 / det
    fx = (/1000) $ fromIntegral $ floor $ 1000*x+0.5 :: Double
    fy = (/1000) $ fromIntegral $ floor $ 1000*y+0.5 :: Double
    
main = map (map readDouble . words) . lines <$> getContents >>= mapM_ (putStrLn . calc)
    "
Haskell,"import Data.List
splitBy :: Char -> String -> [String]
splitBy _ [] = []
splitBy a x =
  let s = takeWhile (/= a) x
      x'= dropWhile (/= a) x
  in
    if x' == []
    then [s]
    else s:(splitBy a $ drop 1 x')
cpl [a,b,c,d,e,f] =
  let x = (b*f - c*e) / (a*e - b*d) 
      y = (a*f - c*d) / (b*d - a*e) 
  in
    if (a*e == b*d) || (b*d == a*e)
    then Nothing
    else Just (x,y)
ln [xa,ya,xb,yb] =
  let a =  ya - yb
      b = -xa + xb
      c = (-ya+yb)*xa + (xa-xb)*ya
  in
    [a,b,c]
  
cp4 [xa,ya,xb,yb,xc,yc,xd,yd] =
  let lab = ln [xa,ya,xb,yb]
      lcd = ln [xc,yc,xd,yd]
  in
    cpl (lab ++ lcd)
ans [xa,ya,xb,yb,xc,yc,xd,yd] =
  let cross = cp4 [xa,ya,xc,yc,xb,yb,xd,yd] 
      [xo,xp] = sort [xa,xc]
      [xq,xr] = sort [xb,xd]
      [yo,yp] = sort [ya,yc]
      [yq,yr] = sort [yb,yd]
  in
    case cross of
      Nothing      -> ""NO""
      Just (xx,yx) -> if (xo <= xx ) && (xx <= xp) && (xq <= xx) && (xx <= xr) &&
                         (yo <= yx ) && (yx <= yp) && (yq <= yx) && (yx <= yr)
                      then ""YES""
                      else ""NO""
main = do
  c <- getContents
  let i = map (map read) $ map (splitBy ',') $ lines c :: [[Float]]
      o = map ans i
  mapM_ putStrLn o"
Haskell,"import Text.Printf
import Debug.Trace
ip::[Double]->[Double]->Double
ip a b = sum $ zipWith (*) a b
norm::[Double]->Double
norm a = (sum $ map (**2.0) a)**0.5
pos::(Double,[Double], [Double])->(Double,[Double], [Double])
pos (theta2, p2, p1) = 
    (theta3', p3', p2')
    where 
        theta3' = theta2+acos((ip p2 p1)/((norm p2)*(norm p1)))
        p3' = [p2!!0+cos(theta3'), p2!!1+sin(theta3')]
        p2' = p2
theta1 = 0.0
theta2 = pi/2.0
p1 = [1.0, 0.0]
p2 = [1.0, 1.0]
pos'::Int -> [Double]
pos' 1 = p1
pos' 2 = p2
pos' n = p3' where (theta3', p3', p2') = last $ take (n-1) $ iterate pos (theta2,p2,p1)
solve::Int-> IO ()
solve n = do
    mapM_ (printf ""%.2f\\n"") $ pos' n
main::IO ()
main=do
    str<-getContents::IO String
    mapM_ solve $ takeWhile (/=(-1)) $ map (\\x->read x::Int) . lines $ str"
Haskell,"import Data.List
import Text.Printf
xyToIndx n x y = x + y * n
setValue n x y v sq = (take i sq) ++ [v] ++ (drop (i+1) sq)
    where i = xyToIndx n x y
isFilled n x y sq = (sq!!(xyToIndx n x y))/=0
findPos :: Int->Int->Int->[Int]->(Int,Int)
findPos n x y sq
    | x<0               = findPos n (n-1) y sq
    | x>=n              = findPos n 0 y sq
    | y>=n              = findPos n x 0 sq
    | isFilled n x y sq = findPos n (x-1) (y+1) sq
    | otherwise         = (x,y)
buildSquare :: Int->Int->Int->Int->[Int]->[Int]
buildSquare n x y v sq
    | v==(n*n)  = sq
    | otherwise = buildSquare n x' y' v' $ setValue n x' y' v' sq
        where (x',y') = findPos n (x+1) (y+1) sq
              v' = v + 1
initSquare :: Int->[Int]
initSquare n = buildSquare n x y 1 sq
    where x = (n-1) `div` 2
          y = (n-1) `div` 2 + 1
          sq = setValue n x y 1 $ take (n*n) $ repeat 0
printSquare :: Int->[Int]->IO ()
printSquare n [] = return ()
printSquare n sq = do
    let sq' = take n sq
    let sq'' = drop n sq
    mapM_ (printf ""%4d"") sq'
    printf ""\\n""
    printSquare n sq''
solve :: Int -> IO ()
solve n = do
    printSquare n (initSquare n)
main = do
    str <- getContents 
    mapM_ solve $ takeWhile (/=0) $map (\\x->read x::Int) $ lines $ str"
Haskell,"import Data.List
splitBy :: Char -> String -> [String]
splitBy _ [] = []
splitBy a x =
  let s = takeWhile (/= a) x
      x'= dropWhile (/= a) x
  in
    if x' == []
    then [s]
    else s:(splitBy a $ drop 1 x')
four_card (c1:c2:c3:c4:c5:_) =
  ( c1==c2 && c2==c3 && c3==c4 ) ||
  ( c2==c3 && c3==c4 && c4==c5 )
full_house (c1:c2:c3:c4:c5:_) =
  ( ( c1==c2 ) && ( c3==c4 && c4==c5 ) ) ||
  ( ( c1==c2 && c2==c3 ) && ( c4==c5 ) )
straight c@(c1:c2:c3:c4:c5:_) =
  let r1 = take 5 [c1..]
      r2 = [1,10,11,12,13]
  in
    r1 == c || r2 == c
three_card c@(c1:c2:c3:c4:c5:_) =
  ( c1==c2 && c2==c3 ) ||
  ( c2==c3 && c3==c4 ) ||
  ( c3==c4 && c4==c5 )
two_pair c@(c1:c2:c3:c4:c5:_) =
  ( ( c1==c2 ) && ( ( c3 == c4 ) || (c4 == c5) ) ) ||
  ( ( c2==c3 ) && ( c4 == c5 ) )
one_pair c@(c1:c2:c3:c4:c5:_) =
  ( c1==c2 ) ||
  ( c2==c3 ) ||
  ( c3==c4 ) ||
  ( c4==c5 )
ans' x
  | four_card  x = ""four card""
  | full_house x = ""full house""
  | straight   x = ""straight""
  | three_card x = ""three card""
  | two_pair   x = ""two pair""
  | one_pair   x = ""one pair""
  | otherwise    = ""null""
ans x = ans' $ sort x
main = do
  c <- getContents
  let i = map (map read) $ map (splitBy ',') $ lines c :: [[Int]]
      o = map ans i
  mapM_ putStrLn o
      "
Haskell,"import Data.Functor
main = do
  n <- getRows <$> getContents
  mapM_ print $ map (\\x -> length $ takeWhile (<= x) primes) n
getRows s = map (read :: (String -> Int)) $ lines s
primes :: Integral int => [int]
primes = wheelSieve 6
wheelSieve :: Integral int
           => Int
           -> [int]
wheelSieve k = reverse ps ++ map head (sieve p (cycle ns))
 where (p:ps,ns) = wheel k
isPrime :: Integral int => int -> Bool
isPrime n | n > 1     = primeFactors n == [n]
          | otherwise = False
primeFactors :: Integral int => int -> [int]
primeFactors n = factors n (wheelSieve 6)
 where
  factors 1 _                  = []
  factors m (p:ps) | m < p*p   = [m]
                   | r == 0    = p : factors q (p:ps)
                   | otherwise = factors m ps
   where (q,r) = quotRem m p
sieve :: (Ord int, Num int) => int -> [int] -> [[int]]
sieve p ns@(m:ms) = spin p ns : sieveComps (p+m) ms (composites p ns)
type Composites int = (Queue int,[[int]])
composites :: (Ord int, Num int) => int -> [int] -> Composites int
composites p ns = (Empty, map comps (spin p ns : sieve p ns))
 where comps xs@(x:_) = map (x*) xs
splitComposites :: Ord int => Composites int -> (int,Composites int)
splitComposites (Empty, xs:xss) = splitComposites (Fork xs [], xss)
splitComposites (queue, xss@((x:xs):yss))
  | x < z     = (x, discard x (enqueue xs queue, yss))
  | otherwise = (z, discard z (enqueue zs queue', xss))
 where (z:zs,queue') = dequeue queue
discard :: Ord int => int -> Composites int -> Composites int
discard n ns | n == m    = discard n ms
             | otherwise = ns
 where (m,ms) = splitComposites ns
sieveComps :: (Ord int, Num int) => int -> [int] -> Composites int -> [[int]]
sieveComps cand ns@(m:ms) xs
  | cand == comp = sieveComps (cand+m) ms ys
  | cand <  comp = spin cand ns : sieveComps (cand+m) ms xs
  | otherwise    = sieveComps cand ns ys
 where (comp,ys) = splitComposites xs
spin :: Num int => int -> [int] -> [int]
spin x (y:ys) = x : spin (x+y) ys
type Wheel int = ([int],[int])
wheel :: Integral int => Int -> Wheel int
wheel n = iterate next ([2],[1]) !! n
next :: Integral int => Wheel int -> Wheel int
next (ps@(p:_),xs) = (py:ps,cancel (product ps) p py ys)
 where (y:ys) = cycle xs
       py = p + y
cancel :: Integral int => int -> int -> int -> [int] -> [int]
cancel 0 _ _ _ = []
cancel m p n (x:ys@(y:zs))
  | nx `mod` p > 0 = x : cancel (m-x) p nx ys
  | otherwise      = cancel m p n (x+y:zs)
 where nx = n + x
data Queue int = Empty | Fork [int] [Queue int]
enqueue :: Ord int => [int] -> Queue int -> Queue int
enqueue ns = merge (Fork ns [])
merge :: Ord int => Queue int -> Queue int -> Queue int
merge Empty y                        = y
merge x     Empty                    = x
merge x     y     | prio x <= prio y = join x y
                  | otherwise        = join y x
 where prio (Fork (n:_) _) = n
       join (Fork ns qs) q = Fork ns (q:qs)
dequeue :: Ord int => Queue int -> ([int], Queue int)
dequeue (Fork ns qs) = (ns,mergeAll qs)
mergeAll :: Ord int => [Queue int] -> Queue int
mergeAll []       = Empty
mergeAll [x]      = x
mergeAll (x:y:qs) = merge (merge x y) (mergeAll qs)"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.Array
import Data.Char (digitToInt)
main :: IO ()
main = do
  xs <- inpi $ map digitToInt
  mapM_ (putStrLn . unwords . map show) $ solve xs
solve :: [[Int]] -> [[Int]]
solve = map puzzle
puzzle :: [Int] -> [Int]
puzzle xs = if null ys then [0] else ys
  where
    iarr = accumArray (+) 0 (1,9) $ (map (\\x -> (head x, length x)) . group . sort) xs
    ys = filter (agari iarr) [1..9]
    
agari :: Array Int Int -> Int -> Bool
agari arr i = if arr ! i == 4 then False else findAg ars1
  where
    ar1 = accum (+) arr [(i,1)]
    ars1 = jantou ar1
    ag = accumArray (+) 0 (1,9) [(n,0) | n <- [1..9]]
    findAg xs | null xs = False
              | ag `elem` xs = True
              | otherwise = findAg ((concat [syuntsu a | a <- xs]) ++ (concat [koutsu a | a <- xs]))
    
jantou :: Array Int Int -> [Array Int Int]
jantou arr = [accum (-) arr [(i,2)] | i <- [1..9], arr ! i >= 2]
syuntsu :: Array Int Int -> [Array Int Int]
syuntsu arr = [accum (-) arr [(i,1),(i+1,1),(i+2,1)] | i <- [1..7], arr ! i >= 1, arr ! (i + 1) >= 1, arr ! (i + 2) >= 1]
koutsu :: Array Int Int -> [Array Int Int]
koutsu arr = [accum (-) arr [(i,3)] | i <- [1..9], arr ! i >= 3]
inpi :: (String -> a) -> IO [a]
inpi f = map f . lines <$> getContents"
Haskell,"import Control.Monad
import Control.Applicative
import Data.List
import Data.List.Split
data Vec = Vec Double Double
crossp :: Vec -> Vec -> Double
crossp (Vec x1 y1) (Vec x2 y2) = x1 * y2 - x2 * y1
eps :: Double
eps = 0.0000000001
main = do
  xs <- input (map read . splitOn "","") :: IO [[Double]]
  mapM_ putStrLn $ solve xs
solve :: [[Double]] -> [String]
solve = map isConvex
isConvex :: [Double] -> String
isConvex [xa, ya, xb, yb, xc, yc, xd, yd] | ca > eps && cb > eps && cc > eps && cd > eps = ""YES""
                                          | ca < (-eps) && cb < (-eps) && cc < (-eps) && cd < (-eps) = ""YES""
                                          | otherwise = ""NO""
  where
    ca = crossp (Vec (xb - xa) (yb - ya)) (Vec (xc - xb) (yc - yb))
    cb = crossp (Vec (xc - xb) (yc - yb)) (Vec (xd - xc) (yd - yc))
    cc = crossp (Vec (xd - xc) (yd - yc)) (Vec (xa - xd) (ya - yd))
    cd = crossp (Vec (xa - xd) (ya - yd)) (Vec (xb - xa) (yb - ya))
input :: (String -> a) -> IO [a]
input f = map f . lines <$> getContents "
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.Array
import Text.Printf
main :: IO ()
main = do
  n <- getl toInt
  solve n 1
solve :: Int -> Int -> IO ()
solve n i = do
  when (i <= n) $ do
    getLine
    ss <- replicateM 8 getLine
    x <- getl toInt
    y <- getl toInt
    printf ""Data %d:\\n"" i
    mapM_ putStrLn $ bomb ss (y, x)
    solve n (i + 1)
bomb :: [String] -> (Int, Int) -> [String]
bomb ss (y, x) = split8 $ elems $ f fld (y, x)
  where
    fld = listArray ((1,1),(8,8)) $ concat ss
    f arr (i,j)
      | arr ! (i,j) == '0' = arr
      | otherwise = foldl f (arr // [((i,j),'0')]) ps
      where
        ps = [(ii,jj)|(ii,jj) <- [(i+1,j),(i+2,j),(i+3,j),(i-1,j),(i-2,j),(i-3,j),(i,j+1),(i,j+2),(i,j+3),(i,j-1),(i,j-2),(i,j-3)], ii >= 1, ii <= 8, jj >= 1, jj <= 8]
    split8 xs
      | null xs = []
      | otherwise  = take 8 xs : split8 (drop 8 xs)
toInt :: String -> Int
toInt s = read s
getl :: (String -> a) -> IO a
getl f = f <$> getLine"
Haskell,"import System.IO (isEOF)
data Orientation = Horizontal | Vertical deriving Eq
data Direction = North | South | East | West
type Wall = (Int,Int,Orientation)
main = input >>= return . solve >>= output
input :: IO [String]
input = do
    quit <- isEOF
    if quit then return [] else do
        line <- getLine
        fmap (line:) input
output :: [Direction] -> IO ()
output = putStrLn . map toLetter
    where
    toLetter North = 'U'
    toLetter South = 'D'
    toLetter East  = 'R'
    toLetter West  = 'L'
solve :: [String] -> [Direction]
solve ls = ws `seq` trace ws (1,0) East [East]
    where
    ws = walls ls
    trace _  (0,0) _ ds = reverse ds
    trace ws pos   d ds = trace ws npos nd (nd:ds)
        where
        nd = nextDirection ws pos d
        npos = nextPosition pos nd
walls :: [String] -> [Wall]
walls = concat . zipWith bindLine [(y,o)|y<-[0..],o<-[Horizontal,Vertical]]
    where
    bindLine (y,o) cs = bindLine' 0 y o cs
    bindLine' x y o """"       =           []
    bindLine' x y o ('1':cs) = (x,y,o) : bindLine' (x+1) y o cs
    bindLine' x y o (_:cs)   =           bindLine' (x+1) y o cs
wallExists :: [Wall] -> (Int,Int) -> Direction -> Bool
wallExists ws (x,y) North = (x,y-1,Vertical) `elem` ws
wallExists ws (x,y) South = (x,y,Vertical) `elem` ws
wallExists ws (x,y) East  = (x,y,Horizontal) `elem` ws
wallExists ws (x,y) West  = (x-1,y,Horizontal) `elem` ws
turnsOrder :: Direction -> [Direction]
turnsOrder North = [West,North,East,South]
turnsOrder South = [East,South,West,North]
turnsOrder East  = [North,East,South,West]
turnsOrder West  = [South,West,North,East]
nextDirection :: [Wall] -> (Int,Int) -> Direction -> Direction
nextDirection ws (x,y) d = head $ filter (wallExists ws (x,y)) (turnsOrder d)
nextPosition :: (Int,Int) -> Direction -> (Int,Int)
nextPosition (x,y) North = (x,y-1)
nextPosition (x,y) South = (x,y+1)
nextPosition (x,y) East  = (x+1,y)
nextPosition (x,y) West  = (x-1,y)"
Haskell,"import Data.List
commaToSpace :: String->String
commaToSpace """" = """"
commaToSpace (x:xs) = if x==',' then ' ':(commaToSpace xs) else x:(commaToSpace xs)
readCard :: String->[Int]
readCard str = map (\\x->read x::Int) $ words $ commaToSpace str
fourcard :: [Int]->Bool
fourcard card = or $ map (\\i->(length $ filter (==i) card)>=4) $ nub card
fullhouse :: [Int]->Bool
fullhouse card = ((c!!0)==(c!!1)&&(c!!1)==(c!!2)&&(c!!3)==(c!!4)) ||
                 ((c!!0)==(c!!1)&&(c!!2)==(c!!3)&&(c!!3)==(c!!4)) 
    where c = sort card
straight :: [Int]->Bool
straight card
    | h==1        = c==[1,2,3,4,5] || c==[1,10,11,12,13]
    | otherwise   = c==[h,h+1,h+2,h+3,h+4]
    where c = sort card
          h = head c
threecard :: [Int]->Bool
threecard card = or $ map (\\i->(length $ filter (==i) card)>=3) $ nub card
twopair :: [Int]->Bool
twopair card = 2==(length $ filter (\\i->(length $ filter (==i) card)==2) $ nub card)
onepair :: [Int]->Bool
onepair card = or $ map (\\i->(length $ filter (==i) card)>=2) $ nub card
solve :: [Int]->IO ()
solve card = do
    if fourcard card then putStrLn ""four card""
    else if fullhouse card then putStrLn ""full house""
    else if straight card then putStrLn ""straight""
    else if threecard card then putStrLn ""three card""
    else if twopair card then putStrLn ""two pair""
    else if onepair card then putStrLn ""one pair""
    else putStrLn ""null""
main = do
    ss <- getContents
    mapM_ solve $ map readCard $ lines ss"
Haskell,"import           Control.Applicative
import           Control.Monad
import           Data.List           hiding (union)
import           Text.Printf
primesTME :: [Int]
primesTME = 2 : ([3,5..] `minus` foldt [[p*p,p*p+2*p..] | p <- primes_])
   where
     primes_ = 3 : ([5,7..] `minus` foldt [[p*p,p*p+2*p..] | p <- primes_])
     foldt ((x:xs):t)    = x : union xs (foldt (pairs t))
     pairs ((x:xs):ys:t) = (x : union xs ys) : pairs t               
primesTMWE :: [Int]
primesTMWE = 2:3:5:7: gaps 11 wheel (fold3t $ roll 11 wheel primes_)
  where
   primes_ = 11: gaps 13 (tail wheel) (fold3t $ roll 11 wheel primes_)     
   fold3t ((x:xs): ~(ys:zs:t)) = x : union xs (union ys zs)
                                      `union` fold3t (pairs t)              
   pairs ((x:xs):ys:t)         = (x : union xs ys) : pairs t
   wheel = 2:4:2:4:6:2:6:4:2:4:6:6:2:6:4:2:6:4:6:8:4:2:4:2:
           4:8:6:4:6:2:4:6:2:6:6:4:2:4:6:2:6:4:2:4:2:10:2:10:wheel
   gaps k ws@(w:t) cs@ ~(c:u) | k==c  = gaps (k+w) t u              
                              | True  = k : gaps (k+w) t cs
   roll k ws@(w:t) ps@ ~(p:u) | k==p  = scanl (\\c d->c+p*d) (p*p) ws
                                          : roll (k+w) t u
                              | True  = roll (k+w) t ps
minus :: [Int] -> [Int] -> [Int]
minus xs@(x:xt) ys@(y:yt) = case compare x y of
  LT -> x : minus xt ys
  EQ ->     minus xt yt
  GT ->     minus xs yt
minus a         b         = a
union :: [Int] -> [Int] -> [Int]
union xs@(x:xt) ys@(y:yt) = case compare x y of
  LT -> x : union xt ys
  EQ -> x : union xt yt
  GT -> y : union xs yt
union a         []        = a
union []        b         = b
main :: IO ()
main = mapM_ (print . process . read) . lines =<< getContents
  where
    process n = length $ takeWhile (<=n) primesTMWE"
Haskell,"import Control.Monad
inGrid :: (Int,Int)->Bool
inGrid (x,y)
    | (0<=y&&y<9)&&(even y)&&(0<=x&&x<4) = True
    | (0<=y&&y<9)&&(odd y) &&(0<=x&&x<5) = True
    | otherwise                          = False
isWall grid (x,y)
    | (inGrid (x,y))&&(((grid!!y)!!x)=='1') = True
    | otherwise                             = False
solve :: [[Char]]->(Int,Int)->[Char]->[Char]
solve grid (i,j) (x:xs)
    | ((i,j)==(0,0)&&(x=='L'))||
       (i,j)==(0,1)&&(x=='U')            = (x:xs)
    
    | (x=='R')&&(isWall grid (i+1,j-1))  = solve grid (i+1,j-1) ('U':x:xs)
    | (x=='R')&&(isWall grid (i+1,j))    = solve grid (i+1,j)   ('R':x:xs)
    | (x=='R')&&(isWall grid (i+1,j+1))  = solve grid (i+1,j+1) ('D':x:xs)
    | (x=='R')                           = solve grid (i,j)     ('L':x:xs)
    
    | (x=='L')&&(isWall grid (i,j+1))    = solve grid (i,j+1)   ('D':x:xs)
    | (x=='L')&&(isWall grid (i-1,j))    = solve grid (i-1,j)   ('L':x:xs)
    | (x=='L')&&(isWall grid (i,j-1))    = solve grid (i,j-1)   ('U':x:xs)
    | (x=='L')                           = solve grid (i,j)     ('R':x:xs)
    
    | (x=='D')&&(isWall grid (i,j+1))    = solve grid (i,j+1)   ('R':x:xs)
    | (x=='D')&&(isWall grid (i,j+2))    = solve grid (i,j+2)   ('D':x:xs)
    | (x=='D')&&(isWall grid (i-1,j+1))  = solve grid (i-1,j+1) ('L':x:xs)
    | (x=='D')                           = solve grid (i,j)     ('U':x:xs)
    
    | (x=='U')&&(isWall grid (i-1,j-1))  = solve grid (i-1,j-1)  ('L':x:xs)
    | (x=='U')&&(isWall grid (i,j-2))    = solve grid (i,j-2)   ('U':x:xs)
    | (x=='U')&&(isWall grid (i,j-1))    = solve grid (i,j-1)   ('R':x:xs)
    | (x=='U')                           = solve grid (i,j)     ('D':x:xs)
main = do
    grid <- replicateM 9 getLine
    putStrLn $ reverse $ solve grid (0,0) ['R']"
Haskell,"import Control.Monad.State
import Data.List.Split
type Dist = Double
type Angle = Int
main = do
    moveList <- getList []
    let (x,y) = evalState (moves moveList) ((0,0),90)
    print $ truncate x
    print $ truncate y
getList lst = do
    line <- getLine
    let [d,a] = splitOn "","" line
        d' = read d :: Dist
        a' = read a :: Angle
    if d == ""0"" && a == ""0"" then return lst
                            else getList (lst ++ [(d',a')])
moves :: [(Dist,Angle)] -> State ((Double,Double),Angle) (Double,Double)
moves []         = move 0 0
moves ((d,a):ms) = move d a >>= \\x -> moves ms
move :: Dist -> Angle -> State ((Double,Double),Angle) (Double,Double)
move d nextA = do
    (point,ang) <- get
    let newpoint = pursue d ang point
    put (newpoint,(ang - nextA) `rem` 360)
    return newpoint
pursue :: Dist -> Angle -> (Double,Double) -> (Double,Double)
pursue d ang (x,y) = (x',y')
    where
        x' = x + d * cos (fromIntegral ang*pi/180)
        y' = y + d * sin (fromIntegral ang*pi/180)"
Haskell,"import Text.Printf
import Control.Monad
import Data.Char
import Data.List
import Debug.Trace
isXXX :: [Int]->(Int,Int,Int)->Bool
isXXX dat (a,b,c) = (dat!!a)==(dat!!b) && (dat!!a)==(dat!!c)
isXYZ :: [Int]->(Int,Int,Int)->Bool
isXYZ dat (a,b,c) = ((dat!!a)+1)==(dat!!b) && ((dat!!a)+2)==(dat!!c)
check'' :: [Int]->Bool
check'' []  = True
check'' dat = 
    or $ map hasXXXorXYZ $ comb
    where 
        hasXXXorXYZ (a,b,c)
            | (isXXX dat (a,b,c))||(isXYZ dat (a,b,c))  = check'' (dat' a b c)
            | otherwise                     = False
        comb = filter (\\(a,b,c)->(a<b)&&(b<c)) [(a,b,c)|a<-nums,b<-nums,c<-nums]
        nums = [0..((length dat)-1)]
        dat' a b c = concat $ map (\\i->if i/=a && i/=b && i/=c then [dat!!i] else []) [0..(length dat)-1]
check' :: [Int]->Bool
check' dat = 
    or $ map hasXX [0..((length dat)-1-1)] 
    where
        hasXX n
            | dat!!n==dat!!(n+1)  = check'' ((take n dat)++(drop (n+2) dat))
            | otherwise           = False
            
check :: [Int]->Int->Bool
check dat i =
    if maxnums>4 then False else check' dat'
    where 
        dat' = sort (dat++[i])
        nums = map (\\i->length i) $ map (\\i->filter (==i) dat') [1..9]
        maxnums = last $ sort $ nums
solve :: [Int]->IO ()
solve dat = do
    let output = map (check dat) [1..9]
    let output' = concat $ map (\\i->if output!!(i-1) then [i] else []) [1..9]
    let output'' = if null output' then [0] else output'
    let str = foldr (++) """" $ (map (\\x->(show x)++"" "") (init output'')) ++ [show $ last output'']
    putStrLn(str)
main :: IO ()
main = do
    s<-getContents :: IO String 
    mapM_ solve $ map (\\x->map (\\y->digitToInt(y)) x) $ lines $ s"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
magicsq n = runST $ do
    arr <- newArray ((0,0),(n-1,n-1)) 0 :: ST s (STUArray s (Int,Int) Int)
    forM_ (zip [1..] (take n (iterate next' start) >>= take n . iterate next)) $ \\(i, p) -> do
        writeArray arr p i
    sequence [concat <$> sequence [show' <$> readArray arr (x,y) | x <- [0..n-1]] | y <- [0..n-1]]
  where
    start = (div n 2, div n 2 + 1)
    next (x,y) = (mod (x+1) n, mod (y+1) n)
    next' (x,y) = (mod (x-1) n, mod (y+1) n)
    
show' n = replicate (4-length s) ' ' ++ s
  where
    s = show n
main = takeWhile (/=0) . map readInt . lines <$> getContents >>= mapM_ (mapM_ putStrLn . magicsq)"
Haskell,"import Control.Applicative
import Control.Monad
import Text.Printf
type Point = (Double, Double)
main :: IO ()
main = do
  n <- readLn
  ls <- replicateM n $ map read . words <$> getLine
  forM_ ls $ \\[x1,y1,x2,y2,x3,y3] -> do
    let a = (x1,y1)
        b = (x2,y2)
        c = (x3,y3)
        sin2A = sinT2 a b c
        sin2B = sinT2 b c a
        sin2C = sinT2 c a b
        sinA = sinT a b c
        r = sqrt (distSq b c) / (2*sinA)
        (px, py) = (a`ptProd`sin2A `ptAdd` b`ptProd`sin2B `ptAdd` c`ptProd`sin2C) `ptProd` (recip (sin2A+sin2B+sin2C))
    printf ""%.3f %.3f %.3f\\n"" px py r
distSq :: Point -> Point -> Double
distSq (x1,y1) (x2,y2) = (x2-x1)**2 + (y2-y1)**2
sinT :: Point -> Point -> Point -> Double
sinT p1 p2 p3 = sqrt (1-cosT**2)
  where
    e1 = distSq p2 p3
    e2 = distSq p3 p1
    e3 = distSq p1 p2
    cosT = (e2+e3-e1)/(2*sqrt e2*sqrt e3)
sinT2 :: Point -> Point -> Point -> Double
sinT2 p1 p2 p3 = 2*sqrt (1-cosT**2)*cosT
  where
    e1 = distSq p2 p3
    e2 = distSq p3 p1
    e3 = distSq p1 p2
    cosT = (e2+e3-e1)/(2*sqrt e2*sqrt e3)
infixl 6 `ptAdd`
ptAdd :: Point -> Point -> Point
ptAdd (x1,y1) (x2,y2) = (x1+x2, y1+y2)
infixl 7 `ptProd`
ptProd :: Point -> Double -> Point
ptProd (x,y) k = (k*x, k*y)"
Haskell,"import Control.Applicative
import Control.Monad
import qualified Data.Array.Unboxed as A
import Data.Array.Unboxed ((!), (//))
import Data.List (foldl', unfoldr)
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy.Char8 as BLC
type Field = A.Array Loc Bool
type Loc = (Int, Int)
size :: Int
size = 8
bombArea :: Loc -> [Loc]
bombArea (x,y) = [
        (xi, y) | xi <- [max 0 (x-3) .. min (x+3) (size-1)], xi /= x
        ] ++ [(x, yi) | yi <- [max 0 (y-3) .. min (y+3) (size-1)]]
bomb :: Field -> Loc -> Field
bomb f l = let
    chain = filter (f !) . bombArea $ l
    burnt = f // zip chain (repeat False)
    in
        foldl' bomb burnt chain
readField :: [String] -> Field
readField = A.listArray ((0,0), (size-1,size-1))
    . map (toEnum . read . return) . concat
    
showField :: Field -> BLC.ByteString
showField = BLC.unlines . map BLC.concat
    . (takeWhile (not . null) . unfoldr (Just. splitAt size))
    . map (BLC.pack . show . (fromEnum :: Bool -> Int)) . A.elems
main = do
    n <- readLn
    answers <- replicateM n (do {_ <- getLine; solve})
    forM_ (zip answers [1..]) $ \\(a,i) -> do
        putStrLn $ ""Data "" ++ show i ++ "":""
        BLC.putStr a
solve :: IO BLC.ByteString
solve = do
    field <- readField <$> replicateM size getLine
    y <- readLn
    x <- readLn
    return . showField . bomb field $ (x-1,y-1)"
Haskell,"primes :: Integral a => [a]
primes = map fromIntegral primes'
    where
        primes' = [2, 3, 5] ++ sieve2 5 7 (drop 2 primes')
        sieve2 m s (p : ps) = [n | n <- ns, gcd m n == 1] ++ sieve2 (m * p) (p * p) ps
            where ns = [x + y | x <- [s, s + 6 .. p * p - 2], y <- [0, 4]]
isPrime :: Integral a => a -> Bool
isPrime n = n > 1 && foldr (\\p r -> p * p > n || ((mod n p) /= 0 && r)) True primes
smallerPrime :: Integral a => a -> a
smallerPrime n = maximum $ takeWhile (< n) primes
largerPrime :: Integral a => a -> a
largerPrime n
    | odd n  = head [p | k <- [2, 4 ..], let p = n + k, isPrime p]
    | even n = head [p | k <- [1, 3 ..], let p = n + k, isPrime p]
main :: IO ()
main = putStr . unlines . map unwords . map (map show) .
    map (\\n -> [smallerPrime n, largerPrime n]) . map read . lines =<< getContents"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
magicsq n = runST $ do
    arr <- newArray ((0,0),(n-1,n-1)) 0 :: ST s (STUArray s (Int,Int) Int)
    forM_ (zip [1..] (take n (iterate next' start) >>= take n . iterate next)) $ \\(i, p) -> do
        writeArray arr p i
    sequence [concat <$> sequence [show' <$> readArray arr (x,y) | x <- [0..n-1]] | y <- [0..n-1]]
  where
    start = (div n 2, div n 2 + 1)
    next (x,y) = (mod (x+1) n, mod (y+1) n)
    next' (x,y) = (mod (x-1) n, mod (y+1) n)
    
show' n = replicate (4-length s) ' ' ++ s
  where
    s = show n
main = takeWhile (/=0) . map readInt . lines <$> getContents >>= mapM_ (mapM_ putStrLn . magicsq)"
Haskell,"import Control.Monad
import Data.List
import Data.Char
import Debug.Trace
abc :: [Char]
abc = map chr $ map (+(ord 'a')) [0..25]
coprime :: Int->Bool
coprime alpha = ((alpha`mod`2)/=0) && ((alpha`mod`13)/=0) && ((alpha`mod`26)/=0)
oneToOne :: Int->Int->Bool
oneToOne alpha beta = 26==(length $ nub $ map (affine alpha beta) abc)
correctAffine :: Int->Int->Bool
correctAffine alpha beta = (coprime alpha) && (oneToOne alpha beta)
affine :: Int->Int->Char->Char
affine alpha beta c = chr $ (alpha*((ord c)-(ord 'a'))+beta)`mod`26 + (ord 'a')
affineR :: Int->Int->Char->Char
affineR alpha beta c = head $ filter (\\x->(affine alpha beta x)==c) abc
affineWord :: Int->Int->String->String
affineWord alpha beta word = map (affine alpha beta) word
affineWordR :: Int->Int->String->String
affineWordR alpha beta word = map (affineR alpha beta) word
wordsToStr :: [String]->String
wordsToStr [] = []
wordsToStr (x:xs) = if null xs then x else x++"" ""++(wordsToStr xs)
solve' :: [String]->[(Int,Int)]->String
solve' lwords ((a,b):xs)
    | (correctAffine a b)&&
      ((elem this lwords)||(elem that lwords)) = wordsToStr $ map (affineWordR a b) lwords
    | otherwise                                = solve' lwords xs
        where this = affineWord a b ""this""
              that = affineWord a b ""that""
solve str = do
    let lwords = words str
    putStrLn (solve' lwords $ foldr (++) [] $ [[(a,x)|a<-[1..(x-1)]]++[(x,b)|b<-[1..(x-1)]]++[(x,x)]|x<-[1..]])
main = do
    n <- readLn :: IO Int
    ss <- replicateM n getLine
    mapM_ solve ss"
Haskell,"module Main (main) where
import Data.List.Split
import Control.Monad
import Control.Applicative
import Text.Printf
main :: IO ()
main = do
  n <- readLn
  replicateM_ n $ do
    ps <- getPoints
    let (x,y,z) = solve ps
    printf ""%.3f %.3f %.3f\\n"" x y z
type Point = (Double,Double)
getPoints :: IO [Point]
getPoints = map mkPair . chunksOf 2 . map read . words <$> getLine
  where
    mkPair (x:y:_) = (x,y)
{-
(x - px)^2 + (y-py)^2 = (x-qx)^2 + (y - qy)^2
2(qx - px)x + 2(qy - py) = qx^2 + qy^2 - px^2 - py^2
2(rx - px)x + 2(ry - py) = rx^2 + ry^2 - px^2 - py^2
-}
subst (p,q) (r,s) = (p - r,q - s)
solve :: [(Double, Double)] -> (Double, Double, Double)
solve (p@(px,py):(qx,qy):(rx,ry):_) = (x,y,sqrt $ ax*ax + ay*ay)
  where
    (ax,ay) = subst p o
    o@(x,y) = solveEq a b c d e f
    a = 2 * (qx - px)
    b = 2 * (qy - py)
    c = qx*qx + qy*qy - px*px - py*py
    d = 2 * (rx - px)
    e = 2 * (ry - py)
    f = rx*rx + ry * ry - px*px - py*py
solveEq :: Double -> Double -> Double -> Double -> Double -> Double -> (Double, Double)
solveEq a b c d e f = (x,y)
  where
    x = (e * c - b * f) / (a * e - d * b)
    y = (a * f - d * c) / (a * e - d * b)"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
main :: IO ()
main = do
  xs <- inpi $ splt toDbl
  mapM_ putStrLn $ solve xs
solve :: [[Double]] -> [String]
solve xs = map pint xs
pint :: [Double] -> String
pint [x1, y1, x2, y2, x3, y3, xp, yp]
  | cr1 > 0 && cr2 > 0 && cr3 > 0 = ""YES""
  | cr1 < 0 && cr2 < 0 && cr3 < 0 = ""YES""
  | otherwise = ""NO""
  where
    p1 = Point x1 y1
    p2 = Point x2 y2
    p3 = Point x3 y3
    pp = Point xp yp
    v1 = toVector p1 p2
    v2 = toVector p2 p3
    v3 = toVector p3 p1
    vp1 = toVector p1 pp
    vp2 = toVector p2 pp
    vp3 = toVector p3 pp
    cr1 = cross v1 vp1
    cr2 = cross v2 vp2
    cr3 = cross v3 vp3
    
toDbl :: String -> Double
toDbl s = read s
splt :: (String -> a) -> String -> [a]
splt f = map f . words
inpi :: (String -> a) -> IO [a]
inpi f = map f . lines <$> getContents
data Point = Point {xop :: Double, yop :: Double} deriving Show
data Vector = Vector {xov :: Double, yov :: Double} deriving Show
cross :: Vector -> Vector -> Double
cross v1 v2 = xov v1 * yov v2 - yov v1 * xov v2
toVector :: Point -> Point -> Vector
toVector p1 p2 = Vector (xop p2 - xop p1) (yop p2 - yop p1)"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Fixed
import Data.Tuple
import Data.Array.Unboxed
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
f x h = xx ^ 2 + 2 * xx * sqrt (hh^2 + (xx/2)^2) 
  where
    xx = fromIntegral x
    hh = fromIntegral h
main = do
    x <- getInt
    unless (x==0) $ f x <$> getInt >>= (printf ""%.15f\\n"" :: Double -> IO ()) >> main"
Haskell,"import Data.Ord (comparing)
import Data.List (foldl',sortBy)
import Data.List.Split (splitOn)
import qualified Data.Map.Strict as Map
import System.IO (isEOF)
type Composition = [(Int,Int)]
main = do
    quit <- isEOF
    if quit then return () else do
        input >>= return . solve >>= output
        main
input :: IO [Int]
input = (map read . splitOn "","") `fmap` getLine
output :: String -> IO ()
output = putStrLn
solve :: [Int] -> String
solve ns = comp `seq` (snd $ head $ filter (\\(pred,_) -> pred comp) preds)
    where
    comp = composition ns
    preds = [
        (isFourCard, ""four card""),
        (isFullHouse, ""full house""),
        (isStraight, ""straight""),
        (isThreeCard, ""three card""),
        (isTwoPair, ""two pair""),
        (isOnePair, ""one pair""),
        (const True, ""null"")]
composition :: [Int] -> Composition
composition ns = sortBy (flip (comparing snd)) $ filter (\\(_,c) -> c > 0) $
                 Map.assocs $ foldl' countUp Map.empty ns
    where
    countUp map n = Map.insertWith (+) n 1 map
isFourCard :: Composition -> Bool
isFourCard [(_,4),(_,1)] = True
isFourCard _ = False
isFullHouse :: Composition -> Bool
isFullHouse [(_,3),(_,2)] = True
isFullHouse _ = False
isStraight :: Composition -> Bool
isStraight [(1,1),(10,1),(11,1),(12,1),(13,1)] = True
isStraight [(a,1),(b,1),(c,1),(d,1),(e,1)]
    | b-a==1 && c-b==1 && d-c==1 && e-d==1 = True
isStraight _ = False
isThreeCard :: Composition -> Bool
isThreeCard [(_,3),(_,1),(_,1)] = True
isThreeCard _ = False
isTwoPair :: Composition -> Bool
isTwoPair [(_,2),(_,2),(_,1)] = True
isTwoPair _ = False
isOnePair :: Composition -> Bool
isOnePair [(_,2),(_,1),(_,1),(_,1)] = True
isOnePair _ = False"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import qualified Data.ByteString as BS
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import GHC.ST
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
data IOHeap e = IOHeap (IORef Int) (IOArray Int e)
newIOHeap :: (Ord e) => Int -> e -> IO (IOHeap e)
newIOHeap n d = do
    count <- newIORef 0
    heap <- newArray (1,n) d
    return $ IOHeap count heap
swapH :: (Ord e) => IOHeap e -> Int -> Int -> IO ()
swapH h@(IOHeap count heap) i j = do
    t <- readArray heap i
    readArray heap j >>= writeArray heap i
    writeArray heap j t
siftUpH :: (Ord e) => IOHeap e -> Int -> IO ()
siftUpH h@(IOHeap count heap) i = when (i>1) $ do
    let parent = i `div` 2
    v_i <- readArray heap i
    v_p <- readArray heap parent
    when (v_i < v_p) $ do
        swapH h i parent
        siftUpH h parent
siftDownH :: (Ord e) => IOHeap e -> Int -> IO ()
siftDownH h@(IOHeap count heap) i = do
    n <- readIORef count
    let left = i * 2
    when (left <= n) $ do
        v_l <- readArray heap left
        let right = left + 1
        child <- if right <= n then do
                      v_r <- readArray heap right
                      return $ if v_l < v_r then left else right
                    else return left
        v_i <- readArray heap i
        v_c <- readArray heap child
        when (v_i > v_c) $ do
            swapH h i child
            siftDownH h child
pushH :: (Ord e) => IOHeap e -> e -> IO ()
pushH h@(IOHeap count heap) e = do
    n <- readIORef count
    let n' = n + 1
    writeIORef count n'
    writeArray heap n' e
    siftUpH h n'
popH :: (Ord e) => IOHeap e -> IO e
popH h@(IOHeap count heap) = do
    n <- readIORef count
    writeIORef count (n-1)
    res <- readArray heap 1
    readArray heap n >>= writeArray heap 1
    siftDownH h 1
    return res
main = do
    heap <- newIOHeap 2000000 0 :: IO (IOHeap Int)
    map negate <$> getInts >>= mapM_ (pushH heap)
    replicateM 5 (popH heap) >>= putStrLn . sjoin . map negate"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Fixed
import Data.Tuple
import Data.Array.Unboxed
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
f (xa1,ya1) (xa2,ya2) (xb1,yb1) (xb2,yb2) = xi && yi
  where
    [x1,x2,x3,x4] = sort [xa1,xa2,xb1,xb2]
    [y1,y2,y3,y4] = sort [ya1,ya2,yb1,yb2]
    xi = if x1==xa1 then x2==xb1 else x2==xa1
    yi = if y1==ya1 then y2==yb1 else y2==ya1
main = map (map (apply2 (,)) . splitRec 2 . map readDouble . words) . lines <$> getContents >>= mapM_ (putStrLn . cond ""YES"" ""NO"" . apply4 f)"
Haskell,"import Control.Applicative
dayCount [] = return ()
dayCount (x:xs) = do
  let day = (head xs) + case x of 0 -> 0
                                  1 -> 0
                                  2 -> 31
                                  3 -> 60
                                  4 -> 91
                                  5 -> 121
                                  6 -> 152
                                  7 -> 182
                                  8 -> 213
                                  9 -> 244
                                  10 -> 274
                                  11 -> 305
                                  12 -> 335
  if day == 0
    then return ()
    else case mod day 7 of 0 -> putStrLn ""Wednesday""
                           1 -> putStrLn ""Thursday""
                           2 -> putStrLn ""Friday""
                           3 -> putStrLn ""Saturday""
                           4 -> putStrLn ""Sunday""
                           5 -> putStrLn ""Monday""
                           6 -> putStrLn ""Tuesday""
main = do
  input <- fmap (fmap (read :: String -> Int) . words) . lines <$> getContents
  mapM_ dayCount input"
Haskell,"import Control.Applicative
import Control.Monad
import Control.Monad.ST
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import qualified Data.Foldable as Foldable
import qualified Data.Set as Set
import Data.List.Split
import Data.Bits
import Data.Char
import Data.Ix
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array
import Data.Array.MArray
import Data.Array.IO
import Data.Array.ST
import Data.IORef
import Data.STRef
import Text.Printf
import GHC.ST
 
readInt = read :: String -> Int
readInteger = read :: String -> Integer
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
getInteger = readLn :: IO Integer
getIntegers = map readInteger . words <$> getLine
getDouble = readLn :: IO Double
getDoubles = map readDouble . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
tjoin :: (Show a, Show b) => (a, b) -> String
tjoin (x, y) = show x ++ (' ' : show y)
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
apply2 :: (a -> a -> b) -> [a] -> b
apply2 f [x,y] = f x y
apply3 :: (a -> a -> a -> b) -> [a] -> b
apply3 f [x,y,z] = f x y z
apply4 :: (a -> a -> a -> a -> b) -> [a] -> b
apply4 f [x,y,z,w] = f x y z w
fnTuple :: (a -> b, a -> c) -> a -> (b, c)
fnTuple (f,g) a = (f a, g a)
replace :: (Eq a) => a -> a -> [a] -> [a]
replace x y = map (\\z -> if z==x then y else z)
binMap :: (a -> a -> b) -> [a] -> [b]
binMap f (x:xs@(y:_)) = f x y : binMap f xs
binMap _ _ = []
splitRec :: Int -> [a] -> [[a]]
splitRec _ [] = []
splitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys
infixl 7 `divCeil`
divCeil :: Integral a => a -> a -> a
x `divCeil` y = (x+y-1) `div` y
coverC :: Ord a => (a, a) -> a -> Bool
coverC (l,r) x = l<=x && x<=r
coverH :: Ord a => (a, a) -> a -> Bool
coverH (l,r) x = l<=x && x<r
ibsearch :: (Int -> Bool) -> (Int,Int) -> Int
ibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))
whenM :: Monad m => m Bool -> m () -> m ()
whenM c a = c >>= flip when a
unconsU :: [a] -> (a, [a])
unconsU (x:xs) = (x, xs)
round3 :: Double -> Double
round3 = (/1000) . fromIntegral . floor . (+0.5) . (*1000)
ccenter (x1,y1) (x2,y2) (x3,y3) = [xc,yc,r]
  where
    ta = 2 * (x2 - x1)
    tb = 2 * (y2 - y1)
    tc = 2 * (x3 - x1)
    td = 2 * (y3 - y1)
    tx = (x2 + x1) * (x2 - x1) + (y2 + y1) * (y2 - y1)
    ty = (x3 + x1) * (x3 - x1) + (y3 + y1) * (y3 - y1)
    det = ta*td - tb*tc
    dx = tx*td - tb*ty
    dy = ta*ty - tx*tc
    xc = dx / det
    yc = dy / det
    r = sqrt $ (x1 - xc) ^ 2 + (y1 - yc) ^ 2
main = getInt >>= flip replicateM getDoubles >>= mapM_ ((\\[x,y,r] -> printf ""%.3f %.3f %.3f\\n"" x y r) . map round3 . apply3 ccenter . map (apply2 (,)) . splitRec 2)
    "
Haskell,"import Data.Char
import Data.Maybe
import Control.Applicative
orda :: Int
orda = ord 'a'
numOfAlp :: Int
numOfAlp = 26
charDiff :: Char -> Char -> Int
charDiff c0 c1 = let d = ord c0 - ord c1 in if d < 0 then d+numOfAlp else d
shiftChar :: Int -> Char -> Char
shiftChar n = chr . (+ orda) . (`mod` numOfAlp) . (+n) . subtract orda . ord
estimateShift :: String -> Int
estimateShift str =
        let _words = map (filter isAlpha) .  words $ str
            theCands = filter ((==3) . length) _words
            thisCands = filter ((==4) . length) _words
            theEst = estWith ""the"" theCands
            thisEst = estWith ""this""  thisCands
            thatEst = estWith ""that"" thisCands
            in
                head $ catMaybes [theEst,thisEst,thatEst]
estWith :: String -> [String] -> Maybe Int
estWith word source = let
    shape = wordShape word
    in
        case filter ((== shape) . wordShape) source of
            [] -> Nothing
            (x:_) -> Just (ord (head x) - ord (head word))
decode :: Int -> String -> String
decode n = map (\\c -> if isAlpha c then f c else c) where f = shiftChar n
wordShape :: String -> [Int]
wordShape [] = []
wordShape [_] = []
wordShape (x:xs) = map (charDiff x) xs
main = do
    str <- lines <$> getContents
    mapM_ (\\l -> do
                let n = estimateShift l
                putStrLn . decode (-n) $ l
                ) str"
Haskell,"{-# LANGUAGE OverloadedStrings #-}
import           Control.Arrow  ((&&&))
import           Data.Either    (rights)
import           Data.List      (group, sort)
import qualified Data.Text      as T
import qualified Data.Text.IO   as T
import qualified Data.Text.Read as T
frequency :: Ord a => [a] -> [(Int, a)]
frequency = map (length &&& head) . group . sort
judge :: [Int] -> T.Text
judge = judge' . sort . frequency
    where
        judge' [(1, _), (4, _)] = ""four card""
        judge' [(2, _), (3, _)] = ""full house""
        judge' [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)] = ""straight""
        judge' [(1, 1), (1, 10), (1, 11), (1, 12), (1, 13)] = ""straight""
        judge' [(1, c1), (1, c2), (1, c3), (1, c4), (1, c5)]
            | [c1, c2, c3, c4, c5] == [c1 .. c5] = ""straight""
            | otherwise                          = ""null""
        judge' [(1, _), (1, _), (3, _)] = ""three card""
        judge' [(1, _), (2, _), (2, _)] = ""two pair""
        judge' [(1, _), (1, _), (1, _), (2, _)] = ""one pair""
        judge' _ = ""null""
main :: IO ()
main = T.interact $ T.unlines . map judge . map (map fst) .
    map rights . map (map T.decimal) . map (T.splitOn "","") . T.lines"
Haskell,"main :: IO()
main = getContents >>= mapM_ (print . solve . read) . lines
solve :: Int -> Int
solve n | n < 100     = length $ takeWhile (<= n) primes
        | n < 1000    = (25 +)     . f $ [101, 103..n]
        | n < 10000   = (168 +)    . f $ [1001, 1003..n]
        | n < 100000  = (1229 +)   . f $ [10001,10003..n]
        | n < 200000  = (9592 +)   . f $ [100001, 100003..n]
        | n < 300000  = (17984 +)  . f $ [200001, 200003..n]
        | n < 400000  = (25997 +)  . f $ [300001, 300003..n]
        | n < 500000  = (33860 +)  . f $ [400001, 400003..n]
        | n < 600000  = (41538 +)  . f $ [500001, 500003..n]
        | n < 700000  = (49098 +)  . f $ [600001, 600003..n]
        | n < 800000  = (56543 +)  . f $ [700001, 700003..n]
        | n < 900000  = (63951 +)  . f $ [800001, 800003..n]
        | n >= 999983 && n < 1000000 = 78498
        | n < 1000000 = (71724 +)  . f $ [900001, 900003..n]
        | otherwise   = (78498 +)  . f $ [1000001, 1000003..n]
    where f = length . (filter isPrime)
primes :: [Int]
primes = (2 :) . (3 :) . (5 :) . (7 :) $ filter isPrime [11, 13..] 
isPrime :: Int -> Bool
isPrime 2 = True
isPrime n
    | n < 2            = False
    | (n `mod` 2) == 0 = False
    | otherwise        = testDiv 3 n
    where testDiv :: Int -> Int -> Bool
          testDiv i n
              | i * i > n      = True
              | n `mod` i == 0 = False
              | otherwise      = testDiv (i + 2) n"
Haskell,"import Control.Monad
import Control.Applicative
import Data.List
import Data.Char
import Data.Maybe
main = interact $ unlines . map (show_rp . listToMaybe . expressions . filter isDigit) . init . lines
expressions ns = filter (\\rp -> eval_rp rp == 10) $ concat $ (map exps op_combs) <*> num_combs
 where
  exps [op1,op2,op3] [n1,n2,n3,n4] =
   [[n1,n2,n3,n4,op1,op2,op3],
    [n1,n2,n3,op1,op2,n4,op3],
    [n1,n2,n3,op1,n4,op2,op3],
    [n1,n2,op1,n3,n4,op2,op3],
    [n1,n2,op1,n3,op2,n4,op3]]  
  op_combs = replicateM 3 ""+-*""
  num_combs = permutations ns
eval_rp = eval_rp' []
 where
  eval_rp' acc [] = head acc
  eval_rp' acc (x:xs)
   | elem x ['1'..'9'] = eval_rp' (read [x] : acc) xs
   | x == '+' = eval_rp' (head (tail acc) + (head acc) : (tail (tail acc))) xs
   | x == '-' = eval_rp' (head (tail acc) - (head acc) : (tail (tail acc))) xs
   | x == '*' = eval_rp' (head (tail acc) * (head acc) : (tail (tail acc))) xs
show_rp = show_rp' []
 where
  show_rp' _ Nothing = ""0""
  show_rp' acc (Just []) = head acc
  show_rp' acc (Just (c:cs))
   | elem c ['1'..'9'] = show_rp' ([c] : acc) (Just cs)
   | otherwise = show_rp' ((""("" ++ head (tail acc) ++ [c] ++ head acc ++ "")"") : (tail (tail acc))) (Just cs)
 "
Haskell,"import Data.List.Split (splitOn)
import System.IO (isEOF)
newtype Point = Point (Double,Double)
newtype Vector = Vector (Double,Double)
data Direction = Leftward | Rightward deriving Eq
main = do
    quit <- isEOF
    if quit then return () else do
        input >>= return . test >>= output
        main
input :: IO [Point]
input = do
    line <- getLine
    let
        [x1,y1,x2,y2,x3,y3,x4,y4] = map read $ splitOn "","" line
    return [Point (x1,y1), Point (x2,y2), Point (x3,y3), Point (x4,y4)]
output :: Bool -> IO ()
output b = putStrLn (if b then ""YES"" else ""NO"")
test :: [Point] -> Bool
test ps = ds `seq` (all (==Leftward) ds || all (==Rightward) ds)
    where
    ds = take (length ps) ds'
    ds' = directions vs'
    vs' = vectors ps'
    ps' = cycle ps
vectors :: [Point] -> [Vector]
vectors (p0:p1:ps) = vector p0 p1 : vectors (p1:ps)
vector :: Point -> Point -> Vector
vector (Point (ox,oy)) (Point (px,py)) = Vector (px-ox,py-oy)
directions :: [Vector] -> [Direction]
directions (v0:v1:vs) = direction v0 v1 : directions (v1:vs)
direction :: Vector -> Vector -> Direction
direction (Vector (a,b)) (Vector (c,d))
    | a*d - b*c > 0.0 = Leftward
    | a*d - b*c < 0.0 = Rightward"
Haskell,"import System.IO                                                                                                                                       
import Control.Monad                                                                                                                                   
main = do                                                                                                                                              
     end <- isEOF                                                                                                                                      
     when (not end) $ do                                                                                                                               
          rs <- getLine                                                                                                                                
          print $ length . show . sum . map (read::String->Int) $ words rs
          main"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
f cs@[c1,c2,c3] = cond ""YES"" ""NO"" $ (>=4) $ length $ filter (<=20) $ map (+my) remain
  where
    remain = [x | x <- [1..10], x `notElem` cs]
    my = c1+c2
main = do
    input <- lines <$> getContents
    let (list, (_:remain)) = break (==""0,0"") input
    let rank = zip [1..] $ map (map head) $ groupBy (on (==) (!!1)) $ sortBy (on (flip compare) (!!1)) $ map (map readInt . wordsBy (==',')) list 
    forM_ (map readInt remain) $ \\i -> print $ fst $ fromJust $ find (elem i . snd) rank"
Haskell,"import Control.Applicative
import Control.Monad
import qualified Data.Array.Unboxed as A
import qualified Data.Array.ST as AS
import Data.List
data Drop = Small | Middle | Large deriving (Enum)
spread :: Drop -> (Int,Int) -> [(Int,Int)]
spread Small = neighbours 1
spread Middle = \\(x,y) -> [(x+i,y+j) | i <- [-1..1], j <- [-1..1]]
spread Large = neighbours 2
neighbours :: Int -> (Int,Int) -> [(Int,Int)]
neighbours n (x,y) =
        [(x+i,y+j) | i <- [-n..n], let jw = n - abs i, j <- [-jw..jw]]
dropInk :: [((Int,Int), Drop)] -> A.UArray (Int,Int) Int
dropInk ds = AS.runSTUArray $ do
    paper <- AS.newArray ((0,0), (9,9)) 0
    forM_ ds $ \\ (loc, d) ->
        forM_ (spread d loc) $ \\ stain ->
            unless (outside stain) $
                AS.readArray paper stain >>= AS.writeArray paper stain . succ
    return paper
outside :: (Int,Int) -> Bool
outside (x,y) = not $ x `elem` [0..9] && y `elem` [0..9]
parseLine :: String -> ((Int,Int), Drop)
parseLine s = let (x:y:d:_) = map read . splitWith ',' $ s
                in ((x,y), toEnum (d-1))
splitWith :: Eq a => a -> [a] -> [[a]]
splitWith c = unfoldr f where
    f [] = Nothing
    f xs = let (pre,post) = break (== c) xs in
        Just (pre, drop 1 post)
main = do
    paper <- A.elems .  dropInk . map parseLine . lines <$> getContents
    print . length . filter (== 0) $ paper
    print . maximum $ paper"
Haskell,"import Control.Monad (replicateM,forM_)
import Control.Monad.ST (ST)
import Data.List.Split (splitOn)
import Data.Array (Array,assocs)
import qualified Data.Array.ST as STArr
 
type Weight = Int
type Price = Int
 
main = main' 1
    where
    main' cn = do
        mw <- read `fmap` getLine
        if mw == 0 then return () else do
            n <- read `fmap` getLine
            wps <- (map ((\\[p,w]->(w,p)) . map read . splitOn "",""))
                `fmap` replicateM n getLine
 
            let
               (aw,ap) = solve mw wps
 
            putStrLn (""Case "" ++ (show cn) ++ "":"")
            print ap
            print aw
             
            main' (cn+1)
 
solve :: Weight -> [(Weight,Price)] -> (Weight,Price)
solve mw wps = head $ filter (\\(w,p) -> p == mp) wmps
    where
    wmps = assocs (maxPrices mw wps)
    mp = maximum $ map snd wmps
maxPrices :: Weight -> [(Weight,Price)] -> Array Weight Price
maxPrices mw wps = STArr.runSTArray $ do
    mpArr <- STArr.newArray (0,mw) 0
    forM_ wps (update mpArr)
    return mpArr
    where
    update mpArr (w,p) = do
        (_, mw) <- STArr.getBounds mpArr
        forM_ [mw-w,mw-w-1..0] update'
        where
        update' w0 = do
            p0 <- STArr.readArray mpArr w0
            p' <- STArr.readArray mpArr (w0+w)
            STArr.writeArray mpArr (w0+w) (max p' (p0+p))"
Haskell,"import Control.Monad (replicateM,unless)
import Data.List (lookup)
import Data.Maybe (fromJust)
import System.IO (isEOF)
type Surface = [String]
type Coord = (Int, Int)
figures :: [([Coord], Char)]
figures = [
    ([(0,0),(1,0),(0,1),(1,1)], 'A'),
    ([(0,0),(0,1),(0,2),(0,3)], 'B'),
    ([(0,0),(1,0),(2,0),(3,0)], 'C'),
    ([(1,0),(0,1),(1,1),(0,2)], 'D'),
    ([(0,0),(1,0),(1,1),(2,1)], 'E'),
    ([(0,0),(0,1),(1,1),(1,2)], 'F'),
    ([(1,0),(2,0),(0,1),(1,1)], 'G')
    ]
main = do
    quit <- isEOF
    if quit then return () else do
        input >>= return . solve >>= output
        main
input :: IO Surface
input = do
    lines <- replicateM 8 getLine
    
    eof <- isEOF
    unless eof (getLine >> return ())
    return lines
output :: Char -> IO ()
output c = putStrLn [c]
solve :: Surface -> Char
solve s = fromJust $ lookup (adjust $ coords s) figures
coords :: Surface -> [Coord]
coords ls = concat $ zipWith lineCoords [0..] ls
    where
    lineCoords y l = lineCoords' y 0 l
    lineCoords' y x """" = []
    lineCoords' y x ('1':cs) = (x,y):lineCoords' y (x+1) cs
    lineCoords' y x (_:cs) = lineCoords' y (x+1) cs
adjust :: [Coord] -> [Coord]
adjust cs = minX `seq` minY `seq` map (`sub` (minX,minY)) cs
    where
    minX = minimum $ map fst cs
    minY = minimum $ map snd cs
    (ax,ay) `sub` (bx,by) = (ax-bx,ay-by)"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
import Data.IORef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
fill :: (IORef Int) -> (IOUArray (Int, Int) Char) -> (Int, Int) -> IO ()
fill ref arr p = do
    c <- readArray arr p
    when (c=='1') $ do
        modifyIORef ref (+1)
        fill' arr p
fill' :: (IOUArray (Int, Int) Char) -> (Int, Int) -> IO ()
fill' arr p@(x,y) = do
    c <- readArray arr p
    when (c=='1') $ do
        writeArray arr p '0'
        mapM_ (fill' arr) $ [(x+dx, y) | dx <- [1,-1]] ++ [(x,y+dy) | dy <- [1,-1]]
main = do
    d <- map (((replicate 14 '0':) . (++[replicate 14 '0'])) . map (('0':) . (++""0""))) . splitWhen (=="""") . lines <$> getContents
    forM_ d $ \\f -> do 
        ref <- newIORef 0
        arr <- newListArray ((0,0),(13,13)) $ concat f
        mapM_ (fill ref arr) [(x,y) | x <- [1..12], y <- [1..12]]
        readIORef ref >>= print"
Haskell,"import Control.Applicative
import Data.List
    (elemIndex, intercalate, nub, sort)
    
import Data.Maybe
    (fromJust)
    
type Data = (Int, Int)
type Problem = ([Data], [Int])
type Result = [Int]
pull :: Int -> [Data] -> [Int] -> Maybe Int
pull q ds ss
    = do
        s <- lookup q ds
        i <- elemIndex s ss
        Just $ i + 1
        
solve :: Problem -> Result
solve (ds, qs)
    = [fromJust $ pull q ds ss | q <- qs] where
        ss = reverse $ sort $ nub $ snd $ unzip ds
        
split :: [String] -> String -> String -> [String]
split list token """"
    = list ++ [token]
    
split list token (x:xs)
    = if x == ','
        then split (list ++ [token]) """" xs
        else split list (token ++ [x]) xs
        
dinput :: [Data] -> IO [Data]
dinput list
    = do
        [p, s] <- map read <$> split [] """" <$> getLine
        if p /= 0 || s /= 0
            then dinput $ list ++ [(p, s)]
            else return list
            
qinput :: IO [Int]
qinput
    = map read <$> lines <$> getContents
    
main :: IO ()
main
    = do
        ds <- dinput []
        qs <- qinput
        putStrLn $ intercalate ""\\n"" $ map show $ solve (ds, qs)"
Haskell,"import Data.List (permutations)
data ExprTree = Node Char ExprTree ExprTree
              | Leaf Int
main = do
    ns <- (map read . words) `fmap` getLine
    if all (==0) ns then return () else do
        putStrLn (solve ns)
        main
solve :: [Int] -> String
solve ns = toString' $ maybeHead $ filter equals10 $
            concatMap exprTrees $ permutations ns
    where
    toString' Nothing = ""0""
    toString' (Just t) = toString t
    maybeHead [] = Nothing
    maybeHead (x:xs) = Just x
    equals10 t = evaluate t == 10
exprTrees :: [Int] -> [ExprTree]
exprTrees [n] = [Leaf n]
exprTrees ns = concatMap exprTrees' [1..(length ns - 1)]
    where exprTrees' p = [Node op left right|
                            let (nsLeft,nsRight) = splitAt p ns,
                            op <- ['+','-','*'],
                            left <- exprTrees nsLeft,
                            right <- exprTrees nsRight]
evaluate :: ExprTree -> Int
evaluate (Leaf value) = value
evaluate (Node '+' left right) = (evaluate left) + (evaluate right)
evaluate (Node '-' left right) = (evaluate left) - (evaluate right)
evaluate (Node '*' left right) = (evaluate left) * (evaluate right)
toString :: ExprTree -> String
toString (Leaf value) = show value
toString (Node op left right) =
    ""("" ++ (toString left) ++ [' ',op,' '] ++ (toString right) ++ "")"""
Haskell,"import Control.Monad
import Text.Printf
solveCenter1 :: (Double, Double, Double, Double, Double, Double) -> (Double, Double)
solveCenter1 (_, b, c, d, e, f) = (x, y)
    where y = c / b
          x = (f - e * y) / d
solveCenter2 :: (Double, Double, Double, Double, Double, Double) -> (Double, Double)
solveCenter2 (a, b, c, d, e, f) = (x, y)
    where y = (a * f - c * d) / (a * e - b * d)
          x = (c - b * y) / a
solveCenter :: (Double, Double, Double, Double, Double, Double) -> (Double, Double)
solveCenter (a, b, c, d, e, f)
    | a == 0    = solveCenter1 (a, b, c, d, e, f)
    | otherwise = solveCenter2 (a, b, c, d, e, f)
solve :: [Double]-> (Double, Double, Double)
solve xs = (x, y, r)
    where x1     = xs !! 0
          y1     = xs !! 1
          x2     = xs !! 2
          y2     = xs !! 3
          x3     = xs !! 4
          y3     = xs !! 5
          a      = 2 * (x1 - x2)
          b      = 2 * (y1 - y2)
          c      = x1 ^ 2 - x2 ^ 2 + y1 ^ 2 - y2 ^ 2
          d      = 2 * (x1 - x3)
          e      = 2 * (y1 - y3)
          f      = x1 ^ 2 - x3 ^ 2 + y1 ^ 2 - y3 ^ 2
          (x, y) = solveCenter (a, b, c, d, e, f)
          r      = sqrt ((x1 - x) ^ 2 + (y1 - y) ^ 2)
format :: (Double, Double, Double) -> String
format (x, y, r) = printf ""%.3f %.3f %.3f"" x y r
main :: IO ()
main = do
    n     <- readLn
    lines <- replicateM n getLine
    mapM_ (putStrLn . format . solve . map read . words) lines"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Text.Printf
main :: IO ()
main = do
  xs <- map (map toDbl . words) . lines <$> getContents
  mapM_ (\\(x, y) -> printf ""%.3f %.3f\\n"" x y) $ solve xs
solve :: [[Double]] -> [(Double, Double)]
solve xs = map smeqn xs
toDbl :: String -> Double
toDbl s = read s
smeqn :: [Double] -> (Double, Double)
smeqn xs = (round3 x, round3 y)
  where
    a : b : c : d : e : f : _ = xs
    ma = toMat a b d e
    mb = toMat c 0 f 0
    (Mat x _ y _) = mulMat (revMat ma) mb
round3 :: Double -> Double
round3 = (/ 1000) . fromIntegral . round . (* 1000)
data Mat = Mat Double Double Double Double deriving Show
mulMat :: Mat -> Mat -> Mat
mulMat (Mat a b c d) (Mat e f g h) = Mat (a * e + b * g) (a * f + b * h) (c * e + d * g) (c * f + d * h)
revMat :: Mat -> Mat
revMat (Mat a b c d) = Mat (d / det) (b * (-1) / det) (c * (-1) / det) (a / det)
  where det = a * d - b * c
toMat :: Double -> Double -> Double -> Double -> Mat
toMat a b c d = Mat a b c d
inp :: (String -> a) -> IO a
inp f = f <$> getLine
inps :: Int -> (String -> a) -> IO [a]
inps n f = map f <$> replicateM n getLine"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.List.Split (splitOn)
main :: IO ()
main = do
  n <- getl toInt
  when (n /= 0) $ do
    xs <- rgetl n $ (\\[x,y] -> Point x y) . map toDbl . splitOn "",""
    print $ solve xs
    main
solve :: [Point] -> Int
solve ps = length ps - length ups - length lps + 2
  where
    sps = sort ps
    ups = hch sps
    lps = (hch . reverse) sps
isConvex :: Point -> Point -> Point -> Bool
isConvex p0 p1 p2 = cross v0 v1 < 0.0
  where
    v0 = toVect p0 p1
    v1 = toVect p0 p2
ch :: [Point] -> [Point]
ch ps
  | length ps < 3 = ps
  | isConvex p0 p1 p2 = ps
  | otherwise = ch (p2:p0:rs)
  where
    (p2:p1:p0:rs) = ps
    
hch :: [Point] -> [Point]
hch ps = foldl f [] ps
  where
    f xs p = ch (p:xs)
    
toInt :: String -> Int
toInt s = read s
toDbl :: String -> Double
toDbl s = read s
getl :: (String -> a) -> IO a
getl f = f <$> getLine
rgetl :: Int -> (String -> a) -> IO [a]
rgetl n f = map f <$> replicateM n getLine
eps :: Double
eps = 1e-9
 
data Point = Point {xop :: Double, yop :: Double} deriving Show
data Vect = Vect {xov :: Double, yov :: Double} deriving Show
cross :: Vect -> Vect -> Double
cross v1 v2 = xov v1 * yov v2 - yov v1 * xov v2
 
toVect :: Point -> Point -> Vect
toVect p1 p2 = Vect (xop p2 - xop p1) (yop p2 - yop p1)
instance Eq Point where
  x == y = abs (xop x - xop y) < eps && abs (xop x - xop y) < eps
instance Ord Point where
  compare x y 
    | abs (xop x - xop y) < eps && abs (yop x - yop y) < eps = EQ
    | xop x < xop y = LT
    | xop x > xop y = GT
    | abs (xop x - xop y) < eps && yop x < yop y = LT
    | abs (xop x - xop y) < eps && yop x > yop y = GT"
Haskell,"import           Data.List
import           Control.Applicative
import           Control.Monad
import           Control.Monad.State
replaceComma :: String -> String
replaceComma []         = []
replaceComma (',' : xs) = ' ' : replaceComma xs
replaceComma (x   : xs) = x : replaceComma xs
readTpl :: IO (Int, Int)
readTpl = do
  (n1 : n2 : _) <- map read . words . replaceComma <$> getLine
  return (n1 - 1, n2 - 1)
elementAt :: Eq a => Int -> [a] -> a
elementAt 0 (a : as) = a
elementAt n (a : as) = elementAt (n - 1) as
changeAt :: Eq a => Int -> a -> [a] -> [a]
changeAt 0 a (_ : ts) = a : ts
changeAt n a (t : ts) = t : changeAt (n - 1) a ts
change :: (Int, Int) -> [Int] -> [Int]
change (a, b) xs = changeAt b a1 $ changeAt a b1 xs
 where
  a1 = elementAt a xs
  b1 = elementAt b xs
changeIO :: StateT [Int] IO ()
changeIO = do
  tpl <- lift readTpl
  modify (change tpl)
main = do
  w       <- readLn
  n       <- readLn
  (_, ns) <- runStateT (replicateM n changeIO) [1 .. w]
  mapM_ print ns"
Haskell,"import Control.Monad
import Control.Applicative
import Data.List
import Data.Char
main = do
  n <- inp toInt
  xs <- inps (2*n) id
  mapM_ putStrLn $ solve xs
solve :: [String] -> [String]
solve [] = []
solve (x:y:ys) = add x y : solve ys
add :: String -> String -> String
add x y = if length rs > 80 then ""overflow"" else rs
  where rx = map digitToInt $ reverse x
        ry = map digitToInt $ reverse y
        add' :: String -> Int -> [Int] -> [Int] -> String
        add' acc c [] [] = if c == 0 then acc else '1':acc
        add' acc c (x:xs) [] = let (cy,cr) = f (x + c) in add' (cr:acc) cy xs []
        add' acc c [] (y:ys) = let (cy,cr) = f (y + c) in add' (cr:acc) cy [] ys
        add' acc c (x:xs) (y:ys) = let (cy,cr) = f (x + y + c) in add' (cr:acc) cy xs ys
        f :: Int -> (Int, Char)
        f z = if z < 10 then (0,intToDigit z) else (1,intToDigit (z - 10) )
        rs = add' [] 0 rx ry
toInt :: String -> Int
toInt s = read s
inp :: (String -> a) -> IO a
inp f = f <$> getLine
inps :: Int -> (String -> a) -> IO [a]
inps n f = map f <$> replicateM n getLine"
PHP,"<?php
$file_handle = fopen('php:
function warshall_floyd($d) {
	global $m;
	for ($i = 0; $i <= $m; ++$i) {
	    for ($j = 0; $j <= $m; ++$j) {
	        for ($k = 0; $k <= $m; ++$k) {
	            
	            $via = $d[$j][$i] + $d[$i][$k];
	            if ($via < $d[$j][$k]) {
	                $d[$j][$k] = $via;
	            }
	        }
	    }
	}
	return $d;
}
while(1){
	
	$n = trim(fgets($file_handle));     
	
	
	if ($n == 0) break;
	
	
	$d = array();
	$num_city = 0;
	
	for ($i=1; $i<=$n; ++$i){
		$info = trim(fgets($file_handle));
		$explode = explode(' ', $info);
		$a = $explode[0]; $b = $explode[1]; $c = $explode[2];
		$d[$a][$b] = $d[$b][$a] = $c;
		
		$num_city = max($num_city, $a, $b);
	}
	$m = $num_city;
	
	
	for ($i=0; $i<=$m; ++$i){
		for ($j=0; $j<=$m; ++$j){
			
			if ( isset($d[$i][$j]) ) continue;
			if ($i === $j){
				$d[$i][$i] = 0;
			} else {
				$d[$i][$j] = INF;
			}
		}
	}
	
	$res = warshall_floyd($d);
	
	$sum_dist = array();	
	$min_dist = INF;		
	$min_city = '';			
	for ($i=0; $i<=$m; ++$i){
		$sum_dist[$i] = 0;	
	}
	for ($i=$m; $i>=0; --$i){	
		for ($j=$m; $j>=0; --$j){
			$sum_dist[$i] += $res[$i][$j];
		}
		
		if ($min_dist >= $sum_dist[$i]){
			$min_dist = $sum_dist[$i];
			$min_city = $i;
		}
	}
	
	echo $min_city.' '.$min_dist;
	echo PHP_EOL;
}
fclose($file_handle);"
PHP,"<?php
ini_set('display_errors', 1);
$ud = array();
$side = array();
$direction = array('R', 'L', 'D', 'U');
$cood = array(array(0, 1), array(0, -1), array(1, 0), array(-1, 0));
$ud[] = str_split(rtrim(fgets(STDIN)));
for ($i = 0; $i < 4; $i++) {
    $side[] = str_split(rtrim(fgets(STDIN)));
    $ud[] = str_split(rtrim(fgets(STDIN)));
}
$field = array_fill(0, 5, array_fill(0, 5, array_fill(0, 4, 0)));
for ($i = 0; $i < 5; $i++) {
    for ($j = 0; $j < 5; $j++) {
        if (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {
            $field[$i][$j][0] = 3;
        } elseif (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {
            $field[$i][$j][0] = 0;
        } elseif (isset($side[$i][$j]) && $side[$i][$j] === '1') {
                $field[$i][$j][0] = 2;
        } else {
            $field[$i][$j][0] = 1;
        }
        if (isset($side[$i][$j]) && $side[$i][$j] === '1') {
            $field[$i][$j][1] = 2;
        } elseif (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {
            $field[$i][$j][1] = 1;
        } elseif (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {
                $field[$i][$j][1] = 3;
        } else {
            $field[$i][$j][1] = 0;
        }
        if (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {
            $field[$i][$j][2] = 0;
        } elseif (isset($side[$i][$j]) && $side[$i][$j] === '1') {
            $field[$i][$j][2] = 2;
        } elseif (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {
            $field[$i][$j][2] = 1;
        } else {
            $field[$i][$j][2] = 3;
        }
        if (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {
            $field[$i][$j][3] = 1;
        } elseif (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {
            $field[$i][$j][3] = 3;
        } elseif (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {
            $field[$i][$j][3] = 0;
        } else {
            $field[$i][$j][3] = 2;
        }
    }
}
$p = array(0, 0);
$d = 0;
$trace = array();
while (true) {
    $trace[] = $direction[$d];
    $p[0] += $cood[$d][0];
    $p[1] += $cood[$d][1];
    $d = $field[$p[0]][$p[1]][$d];
    if ($p[0] === 0 && $p[1] === 0) {
        break;
    }
}
echo implode('', $trace);
echo PHP_EOL;"
PHP,"<?php
$up=1;
$south=2;
$east=3;
$west=4;
$north=5;
$down=6;
$ans=1;
$tmp;
$count=0;
while($count<5){
    
    $stdin=trim(fgets(STDIN));
    
    if($stdin==0){
        break;
    }
    if($stdin<=10000){
        
        for($i=0;$i<$stdin;$i++){
            $diceRoll=trim(fgets(STDIN));
            
            switch($diceRoll){
                case:
                    $tmp=$up;
                    $up=$south;
                    $south=$down;
                    $down=$north;
                    $north=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$north;
                    $north=$down;
                    $down=$south;
                    $south=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$east;
                    $east=$down;
                    $down=$west;
                    $west=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$west;
                    $west=$down;
                    $down=$east;
                    $east=$tmp;
                    break;
                case:
                    $tmp=$south;
                    $south=$east;
                    $east=$north;
                    $north=$west;
                    $west=$tmp;
                    break;
                case:
                    $tmp=$south;
                    $south=$west;
                    $west=$north;
                    $north=$east;
                    $east=$tmp;
                    break;
                default:
            }
            
            $ans+=$up;
        }
        
        echo $ans.;
        
        $up=1;
        $south=2;
        $east=3;
        $west=4;
        $north=5;
        $down=6;
        $ans=1;
        
        $count++;
    }
}"
PHP,"<?php
    $tmp_line = array();
    while($line = trim(fgets(STDIN))){
        $tmp_line[] = $line;
    }
    foreach($tmp_line as $val){
        $math = explode(,$val);
        $koyaku;
        $kobaisu;
        if($math[0]>$math[1]){
            $tmp = $math[0] - $math[1];
            $tmp2 = $math[1];
            while($tmp != $tmp2){
                if($tmp > $tmp2){
                    $tmp = $tmp - $tmp2;
                }else{
                    $tmp2 = $tmp2 - $tmp;
                }
            }
            $koyaku = $tmp;
        }else if($math[0]<$math[1]){
            $tmp = $math[1] - $math[0];
            $tmp2 = $math[0];
            while($tmp != $tmp2){
                if($tmp > $tmp2){
                    $tmp = $tmp - $tmp2;
                }else{
                    $tmp2 = $tmp2 - $tmp;
                }
            }
            $koyaku = $tmp;
        }else{
            $koyaku = $math[0];
        }
        $kobaisu = ($math[0] * $math[1]) / $koyaku;
        echo $koyaku..$kobaisu.;
    }"
PHP,"<?php
 
$file_handle = fopen('php:
 
function dfs($cur) {
    
    global $dist;
    global $leaf;
    global $flag;
     
    
     
    $childnode = childnode($cur['node']);
    if (empty( $childnode )) return;
    foreach ($childnode as $island_num => $distance) {
    	if ( $flag[$island_num] === 1 ) continue;
        $grandchildnode = childnode($island_num);
        if (!empty($grandchildnode)) {
            $new['node'] = $island_num;
            $new['dist'] = $cur['dist'] + $dist[$cur['node']][$new['node']];
            $flag[$island_num] = 1;
            dfs($new);
        } else {
            $leaf[$cur['node']] = $cur['dist'];     
            $dist[$cur['node']][$island_num] = 0;   
            $dist[$island_num][$cur['node']] = 0;   
        }
    }
}
 
function childnode($island){
    global $dist;
    global $flag;
   
   $childnode = array();
   if (!empty($dist[$island])){
       foreach ($dist[$island] as $key => $val){
           if ($flag[$key] !== 1) {
               $childnode[$key] = $val;
           }
       }
   }
   return $childnode;
}
 
function max_dist($leaf){
    $max = 0;
    foreach ($leaf as $key => $val){
        if ($max < $leaf[$key]){
            $max = $leaf[$key];
        }
    }
    return $max;
}
 
function calc(){
    global $dist;
    global $leaf;
    global $max_dist;
    
    $sum = 0;
    foreach($dist as $key => $val){
        foreach($dist[$key] as $d2){
            $sum += $d2;
        }
    }
    
     
    
    $sum -= $max_dist;
    return $sum;
}
 
while (1){
    
    $dist = array();
    $leaf = array();    
    $flag = array();	
 
    
    $stdin = fscanf($file_handle, '%d');    
    $n = $stdin[0];
    
    if ($n == 0){
        break;
    }
     
    for ($i=0; $i < $n-1; $i++){
        $info = fscanf($file_handle, '%d %d %d');
        $parent = $info[0]; $child = $info[1]; $distance = $info[2];
        $dist[$parent][$child] = $distance;
        $dist[$child][$parent] = $distance;
    }
    
    for ($i=1; $i<=$n; $i++){
    	$flag[$i] = 0;	
    }
    
 
    
    $stack['node'] = 1;     
    $stack['parent'] = NULL;
    $stack['dist'] = 0;
    $flag[1] = 1;	
    dfs($stack);
    $max_dist = max_dist($leaf);
    $sum = calc();
    
    
    echo $sum;
    echo PHP_EOL;
}
 
fclose($file_handle);"
PHP,"<?php
$map = array(
	'a' => 0,
	'b' => 1,
	'c' => 2,
	'd' => 3,
	'e' => 4,
	'f' => 5,
	'g' => 6,
	'h' => 7,
	'i' => 8,
	'j' => 9,
	'k' =>10,
	'l' =>11,
	'm' =>12,
	'n' =>13,
	'o' =>14,
	'p' =>15,
	'q' =>16,
	'r' =>17,
	's' =>18,
	't' =>19,
	'u' =>20,
	'v' =>21,
	'w' =>22,
	'x' =>23,
	'y' =>24,
	'z' =>25,
);
$rev_map = array_flip($map);
$n = trim(fgets(STDIN));
for ($i = 0; $i < $n; $i++) {
	$line = trim(fgets(STDIN));
	echo solve($line) . ;
}
function solve($line) {
	$words = explode(' ', $line);
	foreach ($words as $w) {
		if (strlen($w) != 4) {
			continue;
		}
		for ($a = 1; $a < 26; $a++) {
			for ($b = 0; $b < 26; $b++) {
				if (encrypt($a, $b, 'that') == $w || encrypt($a, $b, 'this') == $w) {
					return decrypt($a, $b, $line);
				}
			}
		}
	}
}
function decrypt($a, $b, $line) {
	$decrypt_map = generate_decrypt_map($a, $b);
	$dec = '';
	for ($i = 0; $i < strlen($line); $i++) {
		$char = $line[$i];
		if (preg_match('/[a-z]/', $char)) {
			$dec .= $decrypt_map[$char];
		} else {
			$dec .= $char;
		}
	}
	return $dec;
}
function generate_decrypt_map($a, $b) {
	global $map;
	$result = array();
	foreach ($map as $k => $c) {
		$result[$k] = encrypt_char($a, $b, $k);
	}
	return array_flip($result);
}
function encrypt($a, $b, $w) {
	$result = '';
	for($i = 0; $i < strlen($w); $i++) {
		$result .= encrypt_char($a, $b, $w[$i]);
	}
	return $result;
}
function encrypt_char($a, $b, $char) {
	global $map, $rev_map;
	$g = $map[$char];
	$enc = ($a * $g + $b) % 26;
	return $rev_map[$enc];
}"
PHP,"<?php
  const DIRS = array('R','D','L','U');
  $p = array(1,0,0);
  $path = 'R';
  $step =  array(array(1,0), array(0,1), array(-1,0), array(0,-1));
  function frontIsClear($p, $l) {
      list($x,$y,$d) = $p;
      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1))
             || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))
             || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1))
             || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));
  }
  function canMove($p,$l) {
      list($x,$y,$d) = $p;
      switch($p[2]) {
      case 0:
          return $x!=4 && $l[2*$y][$x];
      case 1:
          return $y!=4 && $l[2*$y+1][$x];
      case 2:
          return $x!=0 && $l[2*$y][$x-1];
      case 3:
          return $y!=0 && $l[2*$y-1][$x];
      }
  }
  function move(&$p,$step) {
      $p[0] = $p[0] + $step[$p[2]][0];
      $p[1] = $p[1] + $step[$p[2]][1];
  }
  for($i=0;$i<9;$i++)
      $l[] = trim(fgets(STDIN));
  while(true) {
       if(!frontIsClear($p,$l)){
          $p[2] = ($p[2]+3) % 4;
       } else {
           while(!canMove($p,$l)) {
              $p[2] = ($p[2]+1) % 4;
           }
       }
       if($p == array(0,0,0))
           break;
       move($p,$step);
       $path .= DIRS[$p[2]];
  }
  echo $path.PHP_EOL;"
PHP,"<?php
/*while($line = fgets(STDIN)){
	$n = intval($line);
	
	
	$cnt = 0;
	for($a = 0; $a <= $n && $a <= 1000; $a++){
		$da = $n - $a;
		
		
		for($b = 0; $b <= $da && $b <= 1000; $b++){
			$db = $da - $b;
			for($c = 0; $c <= $db && $c <= 1000; $c++){
				$d = $db - $c;
				if($d <= 1000){
					$cnt++;
				}
			}
		}
	}
	
	echo $cnt.;
}*/
$x = array_fill(0, 1001, 1);
$y = array_fill(0, 2001, 0);
for($i = 0; $i <= 1000; $i++){
	for($j = 0; $j <= 1000; $j++){
		$y[$i + $j] += $x[$i];
	}
}
$x = $y;	
$y = array_fill(0, 3001, 0);
for($i = 0; $i <= 1000; $i++){
	for($j = 0; $j <= 2000; $j++){
		$y[$i + $j] += $x[$j];
	}
}
$x = $y;	
$y = array_fill(0, 4001, 0);
for($i = 0; $i <= 1000; $i++){
	for($j = 0; $j <= 3000; $j++){
		$y[$i + $j] += $x[$j];
	}
}
while($line = fgets(STDIN)){
	$n = intval($line);
	echo $y[$n].;
}"
PHP,"<?php
$templete = array(
    '(%d %s %d %s %d) %s %d',
    '((%d %s %d) %s %d) %s %d',
    '(%d %s (%d %s %d)) %s %d',
    '(%d %s %d) %s %d %s %d',
    '(%d %s %d) %s (%d %s %d)',
    '%d %s (%d %s %d %s %d)',
    '%d %s ((%d %s %d) %s %d)',
    '%d %s (%d %s %d) %s %d',
    '%d %s %d %s (%d %s %d)',
    '%d %s %d %s %d %s %d',
);
$operators = array(
    '+ + +',
    '+ + -',
    '+ + *',
    '+ - +',
    '+ - -',
    '+ - *',
    '+ * +',
    '+ * -',
    '+ * *',
    '- + +',
    '- + -',
    '- + *',
    '- - +',
    '- - -',
    '- - *',
    '- * +',
    '- * -',
    '- * *',
    '* + +',
    '* + -',
    '* + *',
    '* - +',
    '* - -',
    '* - *',
    '* * +',
    '* * -',
    '* * *',
);
while($line = trim(fgets(STDIN))){
    if($line == '0 0 0 0'){
        break;
    }
    $data_ary = explode(,$line);
    foreach($templete as $temp){
        $flg = false;
        if(getAnswer($data_ary,$operators,$temp)){
            $flg = true;
            break;
        }
    }
    if(!$flg){
        echo ;
    }
}
function getAnswer($data_ary,$opes,$temp){
    for($a = 0;$a < 4;$a++){
        for($b = 0;$b < 4;$b++){
            for($c = 0;$c < 4;$c++){
                for($d = 0;$d < 4 ;$d++){
                    if($a != $b && $b != $c && $c != $d && $a != $c && $a != $d && $b != $d){
                        foreach($opes as $ope){
                            $op = explode(,$ope);
                            $math = sprintf($temp,$data_ary[$d],$op[0],$data_ary[$c],$op[1],$data_ary[$b],$op[2],$data_ary[$a]);
                            eval('$ans = '.$math.';');
                            if($ans == 10){
                                echo .$math.;
                                return true;
                            }
                        }
                    }
                }            
            }
        }
    }
    return false;
}"
PHP,"<?php
while (($line = trim(fgets(STDIN))) !== '0') {
    $n = (int)$line;
    
    $arr = array_fill(0, $n, array_fill(0, $n, 0));
    $x = (int)($n / 2);
    $y = $x + 1;
    
    $arr[$y][$x] = 1;
    $m = pow($n, 2);
    $cnt = 2;
    $right = true;
    
    while ($cnt <= $m) {
        
        if ($right) {
            $x = $x + 1 < $n ? $x + 1 : 0;
            $y = $y + 1 < $n ? $y + 1 : 0;
            
            if ($arr[$y][$x]) {
                
                $right = false;
            } else {
                $arr[$y][$x] = $cnt;
                
                $right = true;
                $cnt++;
            }
        
        } else {
            $x = $x - 1 < 0 ? $n - 1 : $x - 1;
            $y = $y + 1 < $n ? $y + 1 : 0;
            
            if ($arr[$y][$x]) {
                continue;
            }
            $arr[$y][$x] = $cnt;
            
            $right = true;
            $cnt++;
        }
    }
    for ($y = 0; $y < $n; $y++) {
        for ($x = 0; $x < $n; $x++) {
            printf('%4s', $arr[$y][$x]);
        }
        echo PHP_EOL;
    }
}"
PHP,"<?php
$string_tmp = array();
$ans_set = array();
while ($line = fgets(STDIN)) {
   $tmp[] = trim($line);
}
$max_lenge = 8;
foreach($tmp as $val){
    
    $max_lenge--;
    
    
    if(preg_match('/1/',$val)){
        $string_tmp[] = $val;
    }
     
    if($max_lenge < 0){
        $ans_set[] = judge($string_tmp);
        
        $string_tmp = array();
        $max_lenge = 8;
    }
}
$ans_set[] = judge($string_tmp);
foreach($ans_set as $val){
    echo $val.;
}
function judge($string_tmp){
    $ans;
    $tmp_length = count($string_tmp);
        if($tmp_length == 4){
            $ans = ;
        }elseif($tmp_length == 1){
            $ans = ;
        }elseif($tmp_length == 2){
            $ans = judge_line2($string_tmp);
        }elseif($tmp_length == 3){
            $ans = judge_line3($string_tmp);
        }
    return $ans;
}
function judge_line2($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos == $pos2){
        return ;
    }elseif ($pos < $pos2) {
        return ;
    }else{
        return ;
    }
}
function judge_line3($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos > $pos2){
        return ;
    }else{
        return ;
    }
}"
PHP,"<?php
fscanf(STDIN, '%d', $n);
$coprime = array();
for ($i = 1; $i < 26; $i++) {
    if (gcd($i, 26) === 1) {
        $coprime[] = $i;
    }
}
for ($i = 0; $i < $n; $i++) {
    $s = explode(' ', rtrim(fgets(STDIN)));
    $f = false;
    foreach ($coprime as $a) {
        for ($b = 0; $b < 26; $b++) {
            $tmp = $s;
            foreach ($s as $k => $w) {
                $s[$k] = dec($w, $a, $b);
                if ($s[$k] === 'that' || $s[$k] === 'this') {
                    $f = true;
                }
            }
            if ($f) {
                break 2;
            }
            $s = $tmp;
        }
    }
    echo implode(' ', $s) . PHP_EOL;
}
function gcd($a, $b) {
    if ($a === $b) {
        return $a;
    }
    return $a > $b ? gcd($a - $b, $b) : gcd($a, $b - $a);
}
function dec($w, $a, $b) {
    $w = str_split($w);
    for ($i = 0; $i < count($w); $i++) {
        $asc = ord($w[$i]) - ord('a');
        $w[$i] = chr(ord('a') + ($a * $asc + $b) % 26);
    }
    return implode('', $w);
}"
PHP,"<?php
$count = 2;	
$value = array();	
while(1){
	$res =fscanf(STDIN, '%d %d %d %d %d %d', $a,$b,$c,$d,$e,$f);
	if ($res==0) break;
	
	$value[0][0]=$a;  $value[0][1]=$b;  $value[0][2]=$c;
	$value[1][0]=$d;  $value[1][1]=$e;  $value[1][2]=$f;
	
	
        if ($a===0 || $e===0) {
		$value[0][0]=$d;  $value[0][1]=$e;  $value[0][2]=$f;
		$value[1][0]=$a;  $value[1][1]=$b;  $value[1][2]=$c;
	}
	
	for($i=0; $i<$count; ++$i){
		
		$a = $value[$i][$i];
		
		
		for($j=$i; $j<=$count; ++$j){
			$value[$i][$j] = $value[$i][$j]/$a;
		}
		
		
		for($j=0; $j<$count; ++$j){
			
			if ($j===$i) continue;
			
			$tmp = $value[$j][$i];
			
			for($k=0; $k<=$count; ++$k){
				
				$value[$j][$k] = $value[$j][$k] - $tmp*$value[$i][$k];
			}
		}
	}
	
	
	$x = $value[0][2];  $y = $value[1][2];
	$x = round($x, 3);  $y = round($y, 3);
	$x = sprintf('%.3f', $x);  $y = sprintf('%.3f', $y);
	echo $x.' '.$y.PHP_EOL;
}"
PHP,"<?php
$vectors = [[1, 0], [0, -1], [-1, 0], [0, 1]];
function solve() {
    $mp = [];
    for ($i = 0; $i < 12; $i++) {
        $mp[$i] = trim(fgets(STDIN));
        
        
    }
    $visited = array_fill(0, 12, array_fill(0, 12, false));
    $cnt = 0;
    for ($y = 0; $y < 12; $y++) {
        for ($x = 0; $x < 12; $x++) {
            if (!$visited[$y][$x] and $mp[$y][$x] === ) {
                $cnt++;
                $visited[$y][$x] = true;
                search($x, $y, $mp, $visited);
            }
        }
    }
    return [$cnt, fgets(STDIN)];
}
function search($x, $y, &$mp, &$visited) {
    global $vectors;
    foreach ($vectors as $vector) {
        list($dx, $dy) = $vector;
        $nx = $x + $dx;
        $ny = $y + $dy;
        if ((0 <= $nx and $nx < 12 and 0 <= $ny and $ny < 12) and ($mp[$ny][$nx] ===  and !$visited[$ny][$nx])) {
            $visited[$ny][$nx] = true;
            search($nx, $ny, $mp, $visited);
        }
    }
}
while (true) {
    list($cnt, $ok) = solve();
    echo $cnt . ;
    if (!$ok) {
        break;
    }
}"
PHP,"<?php
while (($line = trim(fgets(STDIN))) !== '') {
    $card = array_fill(1, 13, 0);
    foreach (explode(',', $line) as $c) {
        $card[(int)$c]++;
    }
    
    $card = array_filter($card, function ($n) {
        return $n;
    });
    $pair = max($card);
    
    $cnt = count($card);
    
    if ($pair === 4) {
        echo ;
    
    } elseif ($pair === 3 && $cnt === 2) {
        echo ;
    
    } elseif ($cnt === 5) {
        
        $min = min(array_keys($card));
        $check = 0;
        for ($i = $min + 1; $i < $min + 5; $i++) {
            isset($card[$i]) && $check++;
        }
        
        if ($check !== 4 && $min === 1) {
            $check = 0;
            for ($i = 10; $i <= 13; $i++) {
                isset($card[$i]) && $check++;
            }
        }
        
        echo $check === 4 ?  : ;
    
    } elseif ($pair === 3) {
        echo ;
    
    } elseif ($pair === 2) {
        
        echo $cnt === 3 ?  : ;
    
    } else {
        echo ;
    }
}"
PHP,"<?php
fscanf(STDIN, , $N);
for ($i = 0; $i < $N; $i++) {
    fscanf(STDIN, , $a);
    fscanf(STDIN, , $b);
    $x = new BigInt();
    if (!$x->setNum($a)) {
        echo 'overflow' . PHP_EOL;
        continue;
    }
    $y = new BigInt();
    if (!$y->setNum($b)) {
        echo 'overflow' . PHP_EOL;
        continue;
    }
    $total = $x->add($y);
    if ($total === NULL) {
        echo 'overflow' . PHP_EOL;
        continue;
    }
    echo $total;
    echo PHP_EOL;
}
class BigInt
{
    const PLACE = 18;
    public $num = array();
    public $maxLen;
    private $zero;
    public function __construct($maxLen = 80) {
        $this->maxLen = $maxLen;
        $n = ceil($maxLen / self::PLACE);
        for ($i = 0; $i < $n; $i++) {
            $this->num[] = '';
        }
        $this->zero = implode(array_fill(0, self::PLACE, '0'));
    }
    public function setNum($num) {
        if (strlen($num) > $this->maxLen) {
            return FALSE;
        }
        $n = ceil($this->maxLen / self::PLACE);
        for ($i = 0; $i < $n; $i++) {
            if (strlen($num) <= self::PLACE) {
                $this->num[$i] = implode(array_fill(0, self::PLACE - strlen($num), '0')) . $num;
                break;
            }
            $this->num[$i] = substr($num, - self::PLACE);
            $num = substr($num, 0, strlen($num) - self::PLACE);
        }
        return TRUE;
    }
    public function add(BigInt $a) {
        $num = $this->num;
        $n = ceil($this->maxLen / self::PLACE);
        $up = 0;
        for ($i = 0; $i < $n; $i++) {
            $num[$i] = (int) $num[$i] + (int) $a->num[$i] + $up;
            if ($num[$i] > 0) {
                $num[$i] = (string) $num[$i];
            } else {
                $num[$i] = $this->zero;
            }
            if (strlen($num[$i]) > self::PLACE) {
                $num[$i] = substr($num[$i], - self::PLACE);
                $up = 1;
            } elseif (strlen($num[$i]) < self::PLACE) {
                $num[$i] = implode(array_fill(0, self::PLACE - strlen($num[$i]), '0')) . $num[$i];
                $up = 0;
            }
        }
        $total = '';
        for ($i = $n - 1; $i >= 0; $i--) {
            $total .= $num[$i];
        }
        $total = preg_replace('/^0*/', '', $total);
        if ($total === '') {
            $total = '0';
        }
        if (strlen($total) > $this->maxLen) {
            return NULL;
        }
        return $total;
    }
}"
PHP,"<?php
$up=1;
$south=2;
$east=3;
$west=4;
$north=5;
$down=6;
$ans=1;
$tmp;
$count=0;
while($count<5){
    
    $stdin=trim(fgets(STDIN));
    
    if($stdin==0){
        break;
    }
    if($stdin<=10000){
        
        for($j=0;$j<$stdin;$j++){
            $diceRoll=trim(fgets(STDIN));
            
            switch($diceRoll){
                case:
                    $tmp=$up;
                    $up=$south;
                    $south=$down;
                    $down=$north;
                    $north=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$north;
                    $north=$down;
                    $down=$south;
                    $south=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$east;
                    $east=$down;
                    $down=$west;
                    $west=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$west;
                    $west=$down;
                    $down=$east;
                    $east=$tmp;
                    break;
                case:
                    $tmp=$south;
                    $south=$east;
                    $east=$north;
                    $north=$west;
                    $west=$tmp;
                    break;
                case:
                    $tmp=$south;
                    $south=$west;
                    $west=$north;
                    $north=$east;
                    $east=$tmp;
                    break;
                default:
            }
            
            $ans+=$up;
        }
        
        echo $ans.;
        
        $up=1;
        $south=2;
        $east=3;
        $west=4;
        $north=5;
        $down=6;
        $ans=1;
        
        $count++;
    }
}"
PHP,"<?php
$file_handle = fopen('php:
function wfs() {
	global $cnt;
	global $sec;
	global $ary_start;
	global $goal_flag;
	global $queue;
	$queue[0] = $ary_start;			
	$queue_size = count($queue[0]);	
	$queue[0]['sec'] = 0;			
	while (!empty($queue)) {		
	   $cur = array_shift($queue);	
	   
	   
	   $cnt = 0;	
	   for($i=0; $i<$queue_size; $i++){
	       if ($cur[$i] !== $cur[0]){ break; }
	       $cnt++;
	   }
	   if ($cnt === $queue_size) {
	       $goal_flag = 1;
	       $sec = $cur['sec'];	
	       break;	
	   }
	   
	   
	    for($i=0; $i<$queue_size-1; $i++){
	    	if ($cur[$i] !== $cur[$i+1]){	
    			$new = $cur;
    			$new['sec'] = $cur['sec'] + 1;		
	    		
	    		if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){	
	    			$new[$i] = 'r';  $new[$i+1] = 'r';
	    		} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){
	    			$new[$i] = 'g';  $new[$i+1] = 'g';
	    		} else {
	    			$new[$i] = 'b';  $new[$i+1] = 'b';
	    		}
	    		$str = toString($new);
	    		if (empty($visited[$str])){	
		    		array_push($queue, $new);
				    $visited[$str] = 1;		
				}
	    	}
	    }
	    
	    
	    
	}
}
function toString($ary){
	$str = '';
	foreach ($ary as $key => $val){
		if (is_numeric($key)) {		
			$str = $str.$val;
		}
	}
	return $str;
}
while (1){
	
	$cnt = 0;	
	$sec = 0;
	$goal_flag = 0;
	$queue = array();
	
	$stdin = trim(fgets($file_handle));
	
	if ($stdin == '0'){		
		break;
	}
	$ary_start = str_split($stdin);
	
	
	wfs();
	
	if ($goal_flag === 1){
		echo $sec;
	} else {
		echo 'NA';
	}
	echo PHP_EOL;
}
fclose($file_handle);"
PHP,"<?php
$tokens = array();
$cnt = 0;
$variables = array();
main();
function main() {
	global $tokens, $cnt;
	$n = trim(fgets(STDIN));
	for ($i = 0; $i < $n; $i++) {
		try {
			$cnt = 0;
			
			$input = trim(fgets(STDIN));
			$tokens = tokenize($input);
			
			if (is_assignment()) {
				assign();
			} else {
				$tree = expression();
				echo $tree->evaluate() . ;
			}
		} catch (SyntaxErrorException $e) {
			echo $e->getMessage() . ;
			$tokens = array();
			$cnt = 0;
		} catch (UndefinedVariableException $e) {
			echo $e->getMessage() . ;
			$tokens = array();
			$cnt = 0;
		}
	}
}
function tokenize($line) {
	$line = str_replace(' ', '', $line);
	preg_match_all(, $line, $tokens);
	if (!is_array($tokens)) {
		return array();
	}
	return $tokens[0];
}
function is_assignment() {
	global $tokens;
	
	if (count($tokens) < 3) {
		return false;
	}
	$t0 = $tokens[0];
	$t1 = $tokens[1];
	if (is_string($t0) && $t1 === '=') {
		return true;
	} else {
		return false;
	}
}
function assign() {
	global $variables, $tokens, $cnt;
	$var = $tokens[0];
	$cnt += 2; 
	$exp = expression();
	$variables[$var] = is_object($exp) ? $exp->evaluate() : null;
}
function expression() {
	global $tokens, $cnt;
	if (empty($tokens)) {
		die();
	}
	$node = term();
	while (true) {
		if ($cnt >= count($tokens)) {
			break;
		}
		$next = $tokens[$cnt];
		if ($next === '+'|| $next === '-') {
			$cnt++;
			$node = new Node($next, $node, term());
		} else {
			break;
		}
	}
	return $node;
}
function term() {
	global $tokens, $cnt;
	$node = factor();
	while (true) {
		if ($cnt >= count($tokens)) {
			break;
		}
		$next = $tokens[$cnt];
		if ($next === '*' || $next === '/') {
			$cnt++;
			$node = new Node($next, $node, factor());
		} else {
			break;
		}
	}
	return $node;
}
function factor() {
	global $variables, $tokens, $cnt;
	$next = $tokens[$cnt];
	
	if ($next === '(') {
		$cnt++; 
		$node = expression();
		if ($tokens[$cnt++] !== ')') { 
			throw new SyntaxErrorException();
		}
		return $node;
	}
	
	
	elseif (is_numeric($next)) {
		$cnt++;
		return new Node(intval($next));
	}
	
	elseif (is_string($next)) {
		if (isset($variables[$next])) {
			$cnt++;
			return new Node($variables[$next]);
		}
		throw new UndefinedVariableException( . $next);
	} else {
		throw new SyntaxErrorException();
	}
}
class Node {
	public $value;
	public $left;
	public $right;
	public function __construct($value = null, $left = null, $right = null) {
		$this->value = $value;
		$this->left = $left;
		$this->right = $right;
	}
	public function evaluate() {
		if (is_numeric($this->value) || $this->value === null) {
			return intval($this->value);
		}
		if ($this->left && $this->right) {
			$left = $this->left->evaluate();
			$right = $this->right->evaluate();
			$op = $this->value;
			switch ($op) {
				case '+':
					return $left + $right;
				case '-':
					return $left - $right;
				case '*':
					return $left * $right;
				case '/':
					return intval($left / $right);
				default:
					throw new SyntaxErrorException();
			}
		}
		throw new SyntaxErrorException();
	}
	public function show($depth = 0) {
		$return = ;
		$left  = is_a($this->left,  ) ?  . $this->left->show($depth + 1)  : $this->left;
		$right = is_a($this->right, ) ?  . $this->right->show($depth + 1) : $this->right;
		$return .= $this->space($depth) . ;
		$return .= $this->space($depth) . ;
		$return .= $this->space($depth) . ;
		return $return;
	}
	private function space($depth) {
		$space = ;
		for ($i = 0; $i < $depth * 4; $i++) {
			$space .= ;
		}
		return $space;
	}
}
class SyntaxErrorException extends Exception {}
class UndefinedVariableException extends RuntimeException {}"
PHP,"<?php
class PriorityQueue extends SplPriorityQueue{
  public function compare($priority1, $priority2){
    if ($priority1 === $priority2) return 0;
    return $priority1 < $priority2 ? 1 : -1;
  }
}
$fp = fopen(,);
while(true){
  fscanf( $fp, , $n, $m);
  if($n == 0 && $m == 0) break;
  for($i = 0 ; $i <= $n ; $i++ ){
    for($j = 0 ; $j < 2 ; $j++ ){
      $used[$i][$j] = false;
      $min_cost[$i][$j] = 10000000;
    }
  }
  $info = array();
  for($i = 0 ; $i < $m ; $i++){
    fscanf( $fp, , $a, $b, $c);
    $info[$a][] = array($b,$c);
    $info[$b][] = array($a,$c);
  }
  $que = new PriorityQueue();
  $que -> setExtractFlags(PriorityQueue::EXTR_BOTH);
  $que -> insert(array(1,0),0);
  while(!$que -> isEmpty()){
    $que -> top();
    $pair = $que -> extract();
    $cost = $pair['priority'];
    $now = $pair['data'][0];
    $ticket = $pair['data'][1];
    if($now == $n){
      print($cost.);
      break;
    }
    if($used[$now][$ticket]) continue;
    $used[$now][$ticket] = true;
    for($i = 0 ; $i < count($info[$now]) ; $i++){
      $e = $info[$now][$i];
      if($cost + $e[1] < $min_cost[$e[0]][$ticket]){
        $min_cost[$e[0]][$ticket] = $cost + $e[1];
        $que -> insert(array($e[0],$ticket),$cost + $e[1]);
      }
      if($ticket == 0){
        for($j = 0 ; $j < count($info[$e[0]]) ; $j++ ){
          $ee = $info[$e[0]][$j];
          if($cost < $min_cost[$ee[0]][1]){
            $min_cost[$ee[0]][1] = $cost;
            $que -> insert(array($ee[0],1),$cost);
          }
        }
      }
    }
  }
}
?>"
PHP,"<?php
$file_handle = fopen('php:
function wfs() {
	global $cnt;	
	global $sec;
	global $ary_start;
	global $goal_flag;
	$queue[0] = $ary_start;			
	$queue_size = count($queue[0]);	
	$queue[0]['sec'] = 0;			
	while (!empty($queue)) {		
	   $cur = array_shift($queue);	
	   
	   
	   $cnt = 0;	
	   for($i=0; $i<$queue_size; $i++){
	       if ($cur[$i] !== $cur[0]){ break; }
	       $cnt++;
	   }
	   if ($cnt === $queue_size) {
	       $goal_flag = 1;
	       $sec = $cur['sec'];	
	       break;	
	   }
	   
	   
	    for($i=0; $i<$queue_size-1; $i++){
	    	if ($cur[$i] !== $cur[$i+1]){	
    			$new = $cur;
    			$new['sec'] = $cur['sec'] + 1;		
	    		
	    		if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){	
	    			$new[$i] = 'r';  $new[$i+1] = 'r';
	    		} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){
	    			$new[$i] = 'g';  $new[$i+1] = 'g';
	    		} else {
	    			$new[$i] = 'b';  $new[$i+1] = 'b';
	    		}
	    		$str = toString($new);
	    		if (empty($visited[$str])){	
		    		array_push($queue, $new);
				    $visited[$str] = 1;		
				}
	    	}
	    }
	    
	    
	    
	}
}
function toString($ary){
	$str = '';
	foreach ($ary as $key => $val){
		if (is_numeric($key)) {		
			$str = $str.$val;
		}
	}
	return $str;
}
while (1){
	
	$sec = 0;
	$goal_flag = 0;
	
	$stdin = trim(fgets($file_handle));
	
	if ($stdin == '0'){		
		break;
	}
	$ary_start = str_split($stdin);
	
	
	wfs();
	
	if ($goal_flag === 1){
		echo $sec;
	} else {
		echo 'NA';
	}
	echo PHP_EOL;
}
fclose($file_handle);"
PHP,"<?php
define(, 8);
define(, 3);	
$datasetnum = fgets(STDIN);	
for($i = 1; $i <= $datasetnum; $i++){
	$line = fgets(STDIN);	
	
	$arr = array();
	for($j = 0; $j < BOX_SIZE; $j++){
		$arr[$j] = trim(fgets(STDIN));
	}
	$x = intval(fgets(STDIN));
	$y = intval(fgets(STDIN));
	explosion($arr, $x - 1, $y - 1);
	
	echo ;
	for($j = 0; $j < 8; $j++){
		echo $arr[$j].;
	}
}
/**
 * ???????¨????
 */
function explosion(&$arr, $x, $y){
	if($x < 0 || BOX_SIZE <= $x || $y < 0 || BOX_SIZE <= $y){
		
		return;
	}
	if($arr[$y][$x] == ){
		
		return;
	}
	
	$arr[$y][$x] = ;
	
	
	for($i = 1; $i <= BOMB_POWER; $i++){
		explosion($arr, $x, $y - $i);
	}
	
	
	for($i = 1; $i <= BOMB_POWER; $i++){
		explosion($arr, $x + $i, $y);
	}
	
	
	for($i = 1; $i <= BOMB_POWER; $i++){
		explosion($arr, $x, $y + $i);
	}
	
	
	for($i = 1; $i <= BOMB_POWER; $i++){
		explosion($arr, $x - $i, $y);
	}
}"
PHP,"<?php
while (!feof(STDIN)) {
  $stdin = trim(fgets(STDIN));
  $values  = explode(',', $stdin);
  if (count($values) != 5) {
  } else {
    $temp = array();
    foreach ($values as $value) {
      if (!isset($temp[$value])) {
        $temp[$value] = 1;
      } else {
        $temp[$value]++;
      }
    }
    ksort($temp);
    $ret = 'null';
    foreach ($temp as $t) {
      if ($t == 4) {
        $ret = 'four card';
      } elseif ($t == 3) {
        if ($ret == 'one pair') {
          $ret = 'full house';
        } else {
          $ret = 'three card';
        }
      } elseif ($t == 2) {
        if ($ret == 'one pair') {
          $ret = 'two pair';
        } elseif ($ret == 'three card') {
          $ret = 'full house';
        } else {
          $ret = 'one pair';
        }
      }
    }
    $temp = array_keys($temp);
    if (count($temp) == 5 && $temp[4] - $temp[0] == 4) {
      $ret = 'straight';
    }
    
    $temp2 = array();
    foreach ($temp as $t) {
      if ($t == 1) {
        $temp2[] = 14;
      } else {
        $temp2[] = $t;
      }
    }
    sort($temp2);
    if (count($temp2) == 5 && $temp2[4] - $temp2[0] == 4) {
      $ret = 'straight';
    }
    echo $ret . ;
  }
}"
PHP,"<?php
$count = 2;	
$value = array();	
while(1){
	$res =fscanf(STDIN, '%d %d %d %d %d %d', $a,$b,$c,$d,$e,$f);
	if ($res==0) break;
	
	$value[0][0]=$a;  $value[0][1]=$b;  $value[0][2]=$c;
	$value[1][0]=$d;  $value[1][1]=$e;  $value[1][2]=$f;
	
	for($i=0; $i<$count; ++$i){
		
		$a = $value[$i][$i];
		
		
		for($j=$i; $j<=$count; ++$j){
			$value[$i][$j] = $value[$i][$j]/$a;
		}
		
		
		for($j=0; $j<$count; ++$j){
			
			if ($j===$i) continue;
			
			$tmp = $value[$j][$i];
			
			for($k=0; $k<=$count; ++$k){
				
				$value[$j][$k] = $value[$j][$k] - $tmp*$value[$i][$k];
			}
		}
	}
	
	
	$x = $value[0][2];  $y = $value[1][2];
	$x = round($x, 3);  $y = round($y, 3);
	$x = sprintf('%.3f', $x);  $y = sprintf('%.3f', $y);
	echo $x.' '.$y.PHP_EOL;
}"
PHP,"<?php
$table = null;
$num = null;
$i = null;
$j = null;
$size = null;
function main() {
	global $num;
	while($n = trim(fgets(STDIN))) {
		init($n);
		while ($num <= $n * $n) {
			trynext();
		}
		printTable();
	}
}
function init($n) {
	global $table, $num, $i, $j, $size;
	initTable($table, $n);
	$size = $n;
	$num = 1;
	$i = (int)($n/2) + 1;
	$j = (int)($n/2);
}
function initTable(&$table, $n) {
	$row = array_fill(0, $n, 0);
	for ($i = 0; $i < $n; $i++) {
		$table[$i] = $row;
	}
}
function trynext() {
	global $table, $num, $i, $j, $size;
	
	if ($j >= $size) {
		$j = 0;
	}
	if ($j < 0) {
		$j = $size - 1;
	}
	if ($i >= $size) {
		$i = 0;
	}
	if ($table[$i][$j] > 0) {
		$i++;
		$j--;
		trynext();
	} else {
		
		$table[$i][$j] = $num;
		
		$i++;
		$j++;
		$num++;
		return;
	}
}
function printTable() {
	global $table, $size;
	for ($i = 0; $i < $size; $i++) {
		$row = ;
		for ($j = 0; $j < $size; $j++) {
			$row .= sprintf(, $table[$i][$j]);
		}
		echo rtrim($row) . ;
	}
}
main();"
PHP,"<?php
$changeList;
$ans = ;
while(true){
    $stdin=trim(fgets(STDIN));
    
    if($stdin == 0){
        break;
    }
    for($i = 0;$i<$stdin;$i++){
        
        $changeIn=trim(fgets(STDIN));
        $changes = explode(, $changeIn);
        
        $changeList[$i][0] = $changes[0];
        $changeList[$i][1] = $changes[1];
    }
    
    $m=trim(fgets(STDIN));
    
    if($m <= 10**5){
        for($i = 0;$i<$m;$i++){
            
            $in=trim(fgets(STDIN));
            for($j = 0;$j<$stdin;$j++){
                
                if($in == $changeList[$j][0]){
                    $in=$changeList[$j][1];
                    break;
                }
            }
            $ans .= $in;
        }
    }
        
        echo $ans.;
        
        $ans = ;
}"
PHP,"<?php
while (($line = trim(fgets(STDIN))) !== '0 0') {
    sscanf($line, '%d %d', $H, $W);
    $map = new SplFixedArray($H);
    $visited = array();
    for ($i = 0; $i < $H; $i++) {
        $map[$i] = new SplFixedArray($W);
        $line = trim(fgets(STDIN));
        foreach (str_split($line) as $j => $ch) {
            $map[$i][$j] = $ch;
        }
    }
    $p = '0 0';
    $result = 'LOOP';
    while (!in_array($p, $visited)) {
        sscanf($p, '%d %d', $x, $y);
        $visited[] = $p;
        switch ($map[$y][$x]) {
            case '>':
                $p = sprintf('%d %d', $x + 1, $y);
                break;
            case '<':
                $p = sprintf('%d %d', $x - 1, $y);
                break;
            case '^':
                $p = sprintf('%d %d', $x, $y - 1);
                break;
            case 'v':
                $p = sprintf('%d %d', $x, $y + 1);
                break;
            default:
                $result = $p;
                break 2;
        }
    }
    echo $result, PHP_EOL;
}"
PHP,"<?php
$file_handle = fopen('php:
function wfs() {
	global $sec;
	global $ary_start;
	global $goal_flag;
	$queue[0] = $ary_start;			
	$queue_size = count($queue[0]);	
	$queue[0]['sec'] = 0;			
	while (!empty($queue)) {		
	   $cur = array_shift($queue);	
	   
	   
	   $cnt = 0;	
	   for($i=0; $i<$queue_size; $i++){
	       if ($cur[$i] !== $cur[0]){ break; }
	       $cnt++;
	   }
	   if ($cnt === $queue_size) {
	       $goal_flag = 1;
	       $sec = $cur['sec'];	
	       break;	
	   }
	   
	   
	    for($i=0; $i<$queue_size-1; $i++){
	    	if ($cur[$i] !== $cur[$i+1]){	
    			$new = $cur;
    			$new['sec'] = $cur['sec'] + 1;
	    		
	    		if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){
	    			$new[$i] = 'r';  $new[$i+1] = 'r';
	    		} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){
	    			$new[$i] = 'g';  $new[$i+1] = 'g';
	    		} else {
	    			$new[$i] = 'b';  $new[$i+1] = 'b';
	    		}
	    		$str = toString($new);
	    		if (empty($visited[$str])){
		    		array_push($queue, $new);
				    $visited[$str] = 1;
				}
	    	}
	    }
	}
}
function toString($ary){
	$str = '';
	foreach ($ary as $key => $val){
		if (is_numeric($key)) {		
			$str = $str.$val;
		}
	}
	return $str;
}
while (1){
	
	$sec = 0;
	$goal_flag = 0;
	
	$stdin = trim(fgets($file_handle));
	
	if ($stdin == '0'){
		break;
	}
	$ary_start = str_split($stdin);
	
	
	wfs();
	
	if ($goal_flag === 1){
		echo $sec;
	} else {
		echo 'NA';
	}
	echo PHP_EOL;
}
fclose($file_handle);"
PHP,"<?php
fscanf(STDIN, '%d', $n);
for ($count = 0; $count < $n; $count++) {
    fscanf(STDIN, '%f %f %f %f %f %f', $x1, $y1, $x2, $y2, $x3, $y3);
    $a = sqrt(($x1 - $x2) * ($x1 - $x2) + ($y1 - $y2) * ($y1 - $y2));
    $b = sqrt(($x3 - $x2) * ($x3 - $x2) + ($y3 - $y2) * ($y3 - $y2));
    $c = sqrt(($x1 - $x3) * ($x1 - $x3) + ($y1 - $y3) * ($y1 - $y3));
    $R = $a * $b * $c / sqrt(($a + $b + $c) * (- $a + $b + $c) * ($a - $b + $c) * ($a + $b - $c));
    $s = array();
    $s[] = $x2 - $x1;
    $s[] = $y2 - $y1;
    $s[] = ($x2 * $x2 - $x1 * $x1 + $y2 * $y2 - $y1 * $y1) / 2;
    $t = array();
    $t[] = $x3 - $x1;
    $t[] = $y3 - $y1;
    $t[] = ($x3 * $x3 - $x1 * $x1 + $y3 * $y3 - $y1 * $y1) / 2;
    if ($s[0] === 0.0) {
        $tmp = $s;
        $s = $t;
        $t = $tmp;
    }
    $div = $s[0];
    for ($i = 0; $i < 3; $i++) {
        $s[$i] /= $div;
    }
    $times = $t[0];
    for ($i = 0; $i < 3; $i++) {
        $t[$i] -= $s[$i] * $times;
    }
    $div = $t[1];
    for ($i = 0; $i < 3; $i++) {
        $t[$i] /= $div;
    }
    $times = $s[1];
    for ($i = 0; $i < 3; $i++) {
        $s[$i] -= $t[$i] * $times;
    }
    echo sprintf('%.3f %.3f %.3f', round($s[2], 3), round($t[2], 3), round($R, 3));
    echo PHP_EOL;
}"
PHP,"<?php
while (true) {
    fscanf(STDIN, '%s', $nums);
    if (feof(STDIN)) {
        break;
    }
    $nums = str_split($nums);
    for ($i = 0; $i < 13; $i++) {
        $nums[$i] = (int) $nums[$i];
    }
    $result = array();
    for ($i = 1; $i <= 9; $i++) {
        $a = $nums;
        $a[] = $i;
        sort($a);
        $hash = array();
        foreach ($a as $v) {
            if (!isset($hash[$v])) {
                $hash[$v] = 0;
            }
            $hash[$v]++;
        }
        if ($hash[$i] > 4) {
            continue;
        }
        $stack = array(array($hash, false));
        while (count($stack)) {
            $node = array_pop($stack);
            $h = update($node[0]);
            $f = $node[1];
            if (count($h) === 0) {
                $result[] = $i;
                break;
            }
            $keys = array_keys($h);
            if (!$f && $h[$keys[0]] >= 2) {
                $t = $h;
                $t[$keys[0]] -= 2;
                $stack[] = array($t, true);
            }
            if ($h[$keys[0]] >= 3) {
                $t = $h;
                $t[$keys[0]] -= 3;
                $stack[] = array($t, $f);
            }
            if (isset($keys[2]) && $keys[2] - $keys[0] === 2) {
                for ($j = 0; $j < 3; $j++) {
                    $h[$keys[$j]]--;
                }
                $stack[] = array($h, $f);
            }
        }
    }
    echo count($result) > 0 ? implode(' ', $result) : 0;
    echo PHP_EOL;
}
function update($nums) {
    foreach ($nums as $k => $v) {
        if ($v === 0) {
            unset($nums[$k]);
        }
    }
    return $nums;
}"
PHP,"<?php
    while(true){
        if (!choiceBankFromDataSet()) {
            break;
        }
    }
    exit;
    function choiceBankFromDataSet()
    {
        $s = trim(fgets(STDIN));
        $s = str_replace(array(,,), '', $s);
        
        $bankNum = (int)$s;
    
        if ($bankNum == 0) {
            return false;
        }
    
        $s = trim(fgets(STDIN));
        $s = str_replace(array(,,), '', $s);
        $year = (int)$s;
    
        $bankInfo;
        $benefitTemp = 0;
        $benefitMax  = 0;
        $bestBankId;
        
        for ( $i = 0; $i < $bankNum; $i++) {
            $s = trim(fgets(STDIN));
            $s = str_replace(array(,,), '', $s);
            $a = explode(, $s);
            $bankInfo = array('bank_id' => intval($a[0]), 'interest_rate' => intval($a[1]), 'interest_kind' => intval($a[2]));
            $benefitTemp = calcBenefit($year, $bankInfo);
            if ($benefitMax < $benefitTemp) {
                $benefitMax = $benefitTemp;
                $bestBankId = $bankInfo['bank_id'];
            }
        }
        
        echo($bestBankId . PHP_EOL);
        return true;
    }
    
    function calcBenefit($year, $bankInfo){
        $doller = 10000000;
        
        if ($bankInfo['interest_kind'] == 1) {
            $benefit = $doller * (1 + $year * $bankInfo['interest_rate'] / 100);
        } else {
            $benefit = $doller * pow((1 + $bankInfo['interest_rate'] / 100), $year);
        }
        return $benefit;
    }
?>"
PHP,"<?php
fscanf ( STDIN, '%d', $rowcnt );
for($row = 0; $row < $rowcnt; $row ++) {
	$dataset = explode ( ' ', rtrim ( fgets ( STDIN ) ) );
	$result = pushBall ( $dataset );
	if ($result) {
		echo ;
	} else {
		echo ;
	}
	echo PHP_EOL;
}
function pushBall($dataset) {
	$b = new Tube ();
	$c = new Tube ();
	foreach ( $dataset as $n ) {
		if ($b->isPushable ( $n ) && $c->isPushable ( $n )) {
			if ($b->peek () < $c->peek ()) {
				$c->push ( $n );
			} else {
				$b->push ( $n );
			}
		} else if ($b->isPushable ( $n )) {
			$b->push ( $n );
		} else if ($c->isPushable ( $n )) {
			$c->push ( $n );
		} else {
			return false;
		}
	}
	return true;
}
class Tube {
	private $tube = [ ];
	public function __construct() {
		$this->tube [] = 0;
	}
	public function isPushable($n) {
		if ($this->peek () < $n) {
			return true;
		} else {
			return false;
		}
	}
	public function push($n) {
		$this->tube [] = $n;
	}
	public function peek() {
		$idxLast = count ( $this->tube ) - 1;
		return $this->tube [$idxLast];
	}
}"
PHP,"<?php
 
$file_handle = fopen('php:
 
 
function wfs() {
    global $cnt;
    global $sec;
    global $ary_start;
    global $goal_flag;
 
    $queue[0] = $ary_start;         
    $queue_size = count($queue[0]); 
    $queue[0]['sec'] = 0;           
    while (!empty($queue)) {        
       $cur = array_shift($queue);  
        
       
       $cnt = 0;    
       for($i=0; $i<$queue_size; $i++){
           if ($cur[$i] !== $cur[0]){ break; }
           $cnt++;
       }
       if ($cnt === $queue_size) {
           $goal_flag = 1;
           $sec = $cur['sec'];  
           break;   
       }
        
       
        for($i=0; $i<$queue_size-1; $i++){
            if ($cur[$i] !== $cur[$i+1]){
                $new = $cur;
                $new['sec'] = $cur['sec'] + 1;
                if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){    
                    $new[$i] = 'r';  $new[$i+1] = 'r';
                } else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){
                    $new[$i] = 'g';  $new[$i+1] = 'g';
                } else {
                    $new[$i] = 'b';  $new[$i+1] = 'b';
                }
                $str = toString($new);
                if (empty($visited[$str])){
                    array_push($queue, $new);
                    $visited[$str] = 1;
                }
            }
        }
    }
}
 
function toString($ary){
    $str = '';
    foreach ($ary as $key => $val){
        if (is_numeric($key)) { 
            $str = $str.$val;
        }
    }
    return $str;
}
 
 
while (1){
    
    $cnt = 0;   
    $sec = 0;
    $goal_flag = 0;
 
    
    $stdin = trim(fgets($file_handle));
    
    if ($stdin == '0'){
        break;
    }
    $ary_start = str_split($stdin);
     
 
    
    wfs();
 
    
    if ($goal_flag === 1){
        echo $sec;
    } else {
        echo 'NA';
    }
    echo PHP_EOL;
}
 
fclose($file_handle);"
PHP,"<?php
/*
  AOJ 0598
  Title:JOI Emblem
  @kankichi573
*/
$result=array();
$hata=array();
$template=array();
fscanf(STDIN,,$m,$n);
for($i=0;$i<$m;$i++)
  fscanf(STDIN,,$hata[$i]);
for($i=0;$i<2;$i++)
  fscanf(STDIN,,$template[$i]);
$cnt4=0;
for($i=0;$i<$m-1;$i++)
  for($j=0;$j<$n-1;$j++)
    {
      $cnt=0;
      for($k=0;$k<2;$k++)
	for($l=0;$l<2;$l++)
	  $cnt+=(substr($hata[$i+$k],$j+$l,1)==substr($template[$k],$l,1))?1:0;
      
      if($cnt==4)
	$cnt4++;
      if($cnt==3)
	{
	for($k=0;$k<2;$k++)
	  for($l=0;$l<2;$l++)
	    if(substr($hata[$i+$k],$j+$l,1)!=substr($template[$k],$l,1))
	      {
		if(isset($result[$i+$k][$j+$l][substr($template[$k],$l,1)]))
		  $result[$i+$k][$j+$l][substr($template[$k],$l,1)]++;
		else
		  $result[$i+$k][$j+$l][substr($template[$k],$l,1)]=1;
	      }
	}
    }
$max=0;
foreach ($result as $key1 => $val1)
{
  foreach ($val1   as $key2 => $val2)
    {
      foreach($val2 as $key3 => $val3)
	{
	  $max = max($max,$val3);
	}
    }
}
printf(,$cnt4+$max);
return(0);
?>"
PHP,"<?php
        for($loop_cnt = 0; $loop_cnt < 5; $loop_cnt++)
        {
                $data_set = array();
                $data = array();
                
                $input_n = trim(fgets(STDIN));
                if( 0 == $input_n)
                {
                        break;
                }
                
                for($loop_n = 0; $loop_n < $input_n; $loop_n++)
                {
                        $input_conv = explode(  , trim(fgets(STDIN)) );
                        $data_set = $data_set + array( $input_conv[0] => $input_conv[1]) ;
                }
                
                $input_m = trim(fgets(STDIN));
                
                for($loop_m = 0; $loop_m < $input_m; $loop_m++)
                {
                        $input_data = trim(fgets(STDIN));
                        $data[$loop_m] = $input_data;
                }
                
                $work = [];
                for($loop_m = 0; $loop_m < $input_m; $loop_m++)
                {
                        if( isset( $data_set[$data[$loop_m]] ) )
                        {
                                $work[] = $data_set[ $data[$loop_m] ];
                        }
                        else
                        {
                                $work[] = $data[$loop_m];
                        }
                }
                echo implode('' , $work);
                echo ;
        };
?>"
PHP,"<?php
$file_handle = fopen('php:
function warshall_floyd($cost) {
	global $n;
	for ($i = 1; $i <= $n; ++$i) {
	    for ($j = 1; $j <= $n; ++$j) {
	        for ($k = 1; $k <= $n; ++$k) {
	            
	            $via_c = $cost[$j][$i] + $cost[$i][$k];
	            if ($via_c < $cost[$j][$k]) {
	                $cost[$j][$k] = $via_c;
	            }
	        }
	    }
	}
	return $cost;
}
$n = trim(fgets($file_handle));
for ($i=1; $i<=$n; ++$i){
	for ($j=1; $j<=$n; ++$j){
		if ($i === $j){
			$cost[$i][$i] = 0;
		} else {
			$cost[$i][$j] = INF;
		}
	}
}
$m = trim(fgets($file_handle));
for ($i=1; $i<=$m; ++$i){
	$info = trim(fgets($file_handle));
	$explode = explode(',', $info);
	$a1 = $explode[0]; $b1 = $explode[1]; $c1 = $explode[2]; $d1 = $explode[3];
	$cost[$a1][$b1] = $c1; $cost[$b1][$a1] = $d1;
}
$info2 = trim(fgets($file_handle));
$explode = explode(',', $info2);
$start = $explode[0]; $goal = $explode[1]; $y1 = $explode[2]; $y2 = $explode[3];
$res = warshall_floyd($cost);
$income = $y1;
$expense = $res[$start][$goal] + $res[$goal][$start] + $y2;
$output = $income - $expense;
echo $output;
echo PHP_EOL;
fclose($file_handle);"
PHP,"<?php
        for($loop_cnt = 0; $loop_cnt < 5; $loop_cnt++)
        {
                $data_set = array();
                $data = array();
                
                $input_n = trim(fgets(STDIN));
                if( 0 == $input_n)
                {
                        break;
                }
                
                for($loop_n = 0; $loop_n < $input_n; $loop_n++)
                {
                        $input_conv = explode(  , trim(fgets(STDIN)) );
                        $data_set[$input_conv[0]] = $input_conv[1] ;
                }
                
                $input_m = trim(fgets(STDIN));
                
                for($loop_m = 0; $loop_m < $input_m; $loop_m++)
                {
                        $input_data =trim(fgets(STDIN));
                        $data[$loop_m] = $input_data;
                }
                
                $work = [];
                for($loop_m = 0; $loop_m < $input_m; $loop_m++)
                {
                        if( isset( $data_set[$data[$loop_m]] ) )
                        {
                                $work[] = $data_set[ $data[$loop_m] ];
                        }
                        else
                        {
                                $work[] = $data[$loop_m];
                        }
                }
                echo implode('',$work);
                echo ;
        };"
PHP,"<?php
$f = fopen( 'php:
function whatTriangle($three_seg) {
    sort($three_seg);
    if ($three_seg[0]+$three_seg[1] <= $three_seg[2]) {
        return false;
    } elseif (pow($three_seg[0], 2)+pow($three_seg[1], 2) === pow($three_seg[2], 2)) {
        return 'RT';
    } elseif (pow($three_seg[0], 2)+pow($three_seg[1], 2) > pow($three_seg[2], 2)) {
        return 'AT';
    } elseif (pow($three_seg[0], 2)+pow($three_seg[1], 2) < pow($three_seg[2], 2)) {
        return 'OT';
    }
}
$result_array = [0, 0, 0, 0];
while( $line = fgets( $f ) ) {
    $three_seg = array_map('intval', explode(' ', $line));
    $test = whatTriangle($three_seg);
    switch ($test) {
        case 'RT':
            $result_array[0]++;
            $result_array[1]++;
            break;
        case 'AT':
            $result_array[0]++;
            $result_array[2]++;
            break;
        case 'OT':
            $result_array[0]++;
            $result_array[3]++;
            break;
        case false:
            break 2;
    }
}
$result = implode(' ', $result_array);
echo $result;
fclose( $f );
?>"
PHP,"<?php
while (true) {
    $map = array();
    for ($i = 0; $i < 8; $i++) {
        $line = trim(fgets(STDIN));
        if ($line === '') {
            break 2;
        }
        $map[$i] = str_split($line);
    }
    foreach ($map as $y => $arr) {
        foreach ($arr as $x => $n) {
            if ($n !== '1') {
                continue;
            }
            echo search($map, $x, $y), PHP_EOL;
            break 2;
        }
    }
    
    fgets(STDIN);
}
function search($map, $x, $y)
{
    $right = isset($map[$y][$x + 1]) && $map[$y][$x + 1] === '1';
    $bottomRight = isset($map[$y + 1][$x + 1]) && $map[$y + 1][$x + 1] === '1';
    $bottom = isset($map[$y + 1][$x]) && $map[$y + 1][$x] === '1';
    $bottomLeft = isset($map[$y + 1][$x - 1]) && $map[$y + 1][$x - 1] === '1';
    
    if ($right && $bottomRight && $bottom) {
        return 'A';
    
    } elseif ($right && $bottomRight) {
        return 'E';
    
    } elseif ($right && $bottom) {
        return 'G';
    
    } elseif ($bottomRight && $bottom) {
        return 'F';
    
    } elseif ($right) {
        return 'C';
    
    } elseif ($bottomLeft) {
        return 'D';
    
    } else {
        return 'B';
    }
}"
PHP,"<?php
main();
function main() {
	while(($n = trim(fgets(STDIN))) != -1) {
		$hunter = new TreasureHunter(1, 0);
		$hunter->findTreasure($n);
	}
}
class TreasureHunter {
	/**
	 *
	 * @var Point $p
	 */
	public $p;
	public function __construct($x, $y) {
		$this->p = new Point($x, $y);
	}
	public function step() {
		$this->p->toWill();
		$this->p->rotateR();
		$this->p->move();
		
	}
	public function findTreasure($n) {
		for ($i = 0; $i < $n - 1; $i++) {
			$this->step();
		}
		$this->sayPosition();
	}
	public function sayPosition() {
		echo $this->p->x . ;
		echo $this->p->y . ;
	}
}
class Point {
	public $x;
	public $y;
	public $vx;
	public $vy;
	public function __construct($x, $y) {
		$this->x = $x;
		$this->y = $y;
	}
	public function rotateR() {
		$vx = $this->vx;
		$vy = $this->vy;
		$this->vx = $vy;
		$this->vy = -$vx;
	}
	public function toWill() {
		$this->vx = -$this->x;
		$this->vy = -$this->y;
		$this->normalize();
	}
	public function move() {
		$this->x += $this->vx;
		$this->y += $this->vy;
	}
	private function normalize() {
		$v = $this->v();
		if ($v == 0) {
			$this->vx = 1;
			$this->vy = 0;
			return;
		}
		$this->vx /= $v;
		$this->vy /= $v;
	}
	private function v() {
		return sqrt($this->vx * $this->vx + $this->vy * $this->vy);
	}
	public function __toString() {
		return ;
	}
}"
PHP,"<?php
fscanf(STDIN, , $target_count);
$heights = array_map(, explode(, trim(fgets(STDIN))));
$target_tmp = [0];
$prev = 0;
for ($i = 0; $i < count($heights); ++$i) {
    if ($heights[$i] != $prev) $target_tmp[] = $heights[$i];
    $prev = $heights[$i];
}
array_push($target_tmp, 0);
$heights = [];
$target = [0];
$prev = 0;
for ($i = 1; $i < count($target_tmp)-1; ++$i) {
    if (($prev < $target_tmp[$i] && $target_tmp[$i] > $target_tmp[$i+1]) || ($prev > $target_tmp[$i] && $target_tmp[$i] < $target_tmp[$i+1])) $target[] = $target_tmp[$i];
    
    $prev = $target_tmp[$i];
}
$target_tmp = [];
$mountain = [];
$valley = [];
for ($i = 0; $i < count($target); ++$i){
	if ($i%2 == 1) {
		$mountain[] = $target[$i];
	} else {
		$valley[] = $target[$i];
	}
}
sort ($target);
sort ($mountain);
sort ($valley);
array_push($target, 0);
array_push($mountain, 0);
array_push($valley, 0);
$ans = 0;
$max = 0;
if(count($target) == 1){
    echo $max, ;
	return ;
}
$m = 0;
$b = 0;
for ($i = 0; $i < count($target)-1; ++$i) {
    if ($mountain[$m] == $target[$i]) {
        ++$m;
        --$ans;
    } 
    if ($valley[$b] == $target[$i]) {
        ++$b;
        ++$ans;
    }
    
    if ($target[$i] < $target[$i+1]) {
        if ($ans > $max) $max = $ans;
    }
}
echo $max, ;"
PHP,"<?php
  const DIRS = ;
  $p = array(1,0,0);
  $path = array('R');
  $stepx =  array(1,0,-1,0);
  $stepy = array(0,1,0,-1);
  function frontIsClear($x,$y,$d,$l) {
      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1)) || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))
          || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1)) || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));
  }
  function canMove($x,$y,$d,$l) {
      return ($d==0 && $x!=4 && $l[2*$y][$x]) || ($d==1 && $y!=4 && $l[2*$y+1][$x])
          || ($d==2 && $x!=0 && $l[2*$y][$x-1]) || ($d==3 && $y!=0 && $l[2*$y-1][$x]);
  }
  function move(&$p,$stepx,$stepy) {
      if($p[2] == 0 || $p[2] == 2)
          $p[0] = $p[0] + $stepx[$p[2]];
      else
          $p[1] = $p[1] + $stepy[$p[2]];
  }
  for($i=0;$i<9;$i++)
      $l[] = trim(fgets(STDIN));
  while(true) {
       if(!frontIsClear($p[0],$p[1],$p[2],$l)){
          $p[2] = ($p[2]+3) % 4;
       } else {
           while(!canMove($p[0],$p[1],$p[2],$l))
              $p[2] = ($p[2]+1) % 4;
       }
       if($p == array(0,0,0))
           break;
       move($p,$stepx,$stepy);
       $path[] = DIRS[$p[2]];
  }
  echo implode('',$path).PHP_EOL;"
PHP,"<?php
define( 'NONE', -1 );
class AOJ1031 {
    var $L;
    var $LC;
    var $n;
    var $X;
    var $Y;
    public function init() {
        $L = &$this->L;
        $LC = &$this->LC;
        
        $L = file( '/dev/stdin' );
        $LC = count( $L );
    }
    public function input( &$offset ) {
        $L = &$this->L;
        $LC = &$this->LC;
        $n = &$this->n;
        $markup = &$this->markup;
        $X = &$this->X;
        $Y = &$this->Y;
        $n = $L[$offset];
        if ( $n == 0 ) return false;
        
        $markup = $L[$offset+1];
        $offset += 2;
        $X = array();
        $Y = array();
        for ( $i = 0; $i < $n; ++ $i, ++ $offset ) {
            $line = $L[$offset];
            $terms = split(' ', $line);
            $X[$i] = intval( $terms[0] );
            $Y[$i] = intval( $terms[1] );
        }
        return true;
    }
    public function hit_test( $x, $y, $x1, $y1, $x2, $y2 ) {
        return $x1 <= $x && $x <= $x2 && $y1 <= $y && $y <= $y2;
    }
    public function get_positions( $line, &$x1, &$y1, &$x2, &$y2 ) {
        $terms = split( ',', $line );
        $x1 = $terms[0];
        $y1 = $terms[1];
        $x2 = $terms[2];
        $y2 = $terms[3];
    }
    public function check_clicked( $root, $x, $y, &$name, &$childs ) {
        $this->get_positions( $root, $x1, $y1, $x2, $y2 );
        if ( $this->hit_test( $x, $y, $x1, $y1, $x2, $y2 ) ) {
            foreach ( $root as $child ) {
                $this->get_positions( $child, $x1, $y1, $x2, $y2 );
                if ( $this->check_clicked( $child, $x, $y, $name, $childs ) ) {
                    return true;
                }
            }
            $name = $root->getName();
            $childs = $root->count();
            return true;
        }
        $name = 'OUT OF MAIN PANEL';
        $childs = 1;
        return false;
    }
    public function solve() {
        $n = &$this->n;
        $markup = &$this->markup;
        $X = &$this->X;
        $Y = &$this->Y;
        $object = new SimpleXMLElement( $markup );
        for ( $i = 0; $i < $n; ++ $i ) {
            $name = ;
            $childs = -1;
            $this->check_clicked( $object, $X[$i], $Y[$i], $name, $childs );
            echo ;
        }
    }
    public function run() {
        $L = &$this->L;
        $LC = &$this->LC;
        $this->init();
        for ( $i = 0; $i < $LC; ++ $i ) {
            while ( $this->input($i) ) {
                $this->solve();
            }
        }
    }
}
$instance = new AOJ1031;
$instance->run();"
PHP,"<?php
  const DIRS = ;
  $p = array(1,0,0);
  $path = array('R');
  $stepx =  array(1,0,-1,0);
  $stepy = array(0,1,0,-1);
  function frontIsClear($x,$y,$d,$l) {
      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1)) || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))
          || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1)) || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));
  }
  function canMove($x,$y,$d,$l) {
      return ($d==0 && $x!=4 && $l[2*$y][$x]) || ($d==1 && $y!=4 && $l[2*$y+1][$x])
          || ($d==2 && $x!=0 && $l[2*$y][$x-1]) || ($d==3 && $y!=0 && $l[2*$y-1][$x]);
  }
  function move(&$p,$stepx,$stepy) {
      if($p[2] == 0 || $p[2] == 2)
          $p[0] = $p[0] + $stepx[$p[2]];
      else
          $p[1] = $p[1] + $stepy[$p[2]];
  }
  for($i=0;$i<9;$i++)
      $l[] = trim(fgets(STDIN));
  while(true) {
       if(!frontIsClear($p[0],$p[1],$p[2],$l)){
          $p[2] = ($p[2]+3) % 4;
       } else {
           while(!canMove($p[0],$p[1],$p[2],$l))
              $p[2] = ($p[2]+1) % 4;
       }
       if($p == array(0,0,0))
           break;
       move($p,$stepx,$stepy);
       $path[] = DIRS[$p[2]];
  }
  echo implode('',$path).PHP_EOL;"
PHP,"<?php
fscanf(STDIN, , $w);
$g = new G();
$a = array();
for ($i = 0; $i < $w; $i++) {
    $a[$i + 1] = 0;
    $g->lines[$i + 1] = new Line($i + 1);
}
fscanf(STDIN, , $n);
$bars = array();
for ($i = 0; $i < $n; $i++) {
    fscanf(STDIN, , $bar);
    $bar = explode(',', $bar);
    $line = $g->getLine((int) $bar[0]);
    $line->edges[$i] = $bar[1];
    $line = $g->getLine((int) $bar[1]);
    $line->edges[$i] = $bar[0];
}
for ($i = 1; $i <= $w; $i++) {
    $l = $i;
    $t = 0;
    while (TRUE) {
        $line = $g->getLine($l);
        $next = $line->nextLine($t);
        if ($next === NULL) {
            $a[$l] = $i;
            break;
        }
        $t = $next[0] + 1;
        $l = $next[1];
    }
}
foreach ($a as $v) {
    echo (string) $v;
    echo PHP_EOL;
}
class Line
{
    public $index;
    public $edges = array();
    public function __construct($index) {
        $this->index = $index;
    }
    public function nextLine($t) {
        foreach ($this->edges as $key => $value) {
            if ($key >= $t) {
                return array($key, $value);
            }
        }
        return NULL;
    }
}
class G
{
    public $lines = array();
    public function getLine($index) {
        return $this->lines[$index];
    }
}"
PHP,"<?php
$a=array(0,1,2,3,4,5,6,7);
$tesuu=array(0);
function swap($a,$pos,$offset)
{
	$wk=$a[$pos];
	$a[$pos]=$a[$pos+$offset];
	$a[$pos+$offset]=$wk;
	return($a);
}
function prepare($a,$te,$pos) 
 { 
   global $tesuu;
   
   if($te>40)
     return;
   
   if(($pos % 4) < 3) 
     {	 
       $b=$a;
       $b=swap($b,$pos,1);
       $mystring=implode($b);	
       if(empty($tesuu[$mystring]) || 
	  $tesuu[$mystring] > $te)
	    {
	      $tesuu[$mystring] = $te+1;	
	      prepare($b,$te+1,$pos+1);
	    }
     }
   
   if(($pos % 4) > 0)
     {	
       $b=$a;
       $b=swap($b,$pos,-1);
       $mystring=implode($b);	
       if(empty($tesuu[$mystring]) || 
	  $tesuu[$mystring] > $te)
	 {
	   $tesuu[$mystring] = $te+1;
	   prepare($b,$te+1,$pos-1);
	 }
     }		
   if($pos > 3)
     {	
       $b=$a;
       $b=swap($b,$pos,-4);
       $mystring=implode($b);	
       if(empty($tesuu[$mystring]) || 
	       $tesuu[$mystring] > $te)
	 {
	   $tesuu[$mystring] = $te+1;
	   prepare($b,$te+1,$pos-4);
	 }
     }		
   if($pos < 4)
     {	
       $b=$a;
       $b=swap($b,$pos,4);
       $mystring=implode($b);	
       if(empty($tesuu[$mystring]) || 
	  $tesuu[$mystring] > $te)
	 {
	   $tesuu[$mystring] = $te+1;
	   prepare($b,$te+1,$pos+4);
	 }
     }
 }
$tesuu[implode($a)]=1;
prepare($a,1,0);
while($input=fscanf(STDIN,))
  {
    
    fprintf(STDOUT,,$tesuu[implode($input)]-1);
  }
  return(0);
?>"
PHP,"<?php
define('DEBUG', 0);
$dx = [0, 1, 0, -1];
$dy = [1, 0, -1, 0];
$cells = array(
  'A'=>[0,0],
  'B'=>[1,0],
  'C'=>[2,0],
  'D'=>[0,1],
  'E'=>[1,1],
  'F'=>[2,1],
  'G'=>[0,2],
  'H'=>[1,2],
  'I'=>[2,2]);
$memo = array();
function f($cx, $cy, $n, $t, $b) { 
if (DEBUG) echo ;
  global $cells, $dx, $dy, $memo;
  
  if (array_key_exists(, $memo)) {
if (DEBUG) echo $memo[].;
    return $memo[];
  }
  if ($n == 0) {
    
    if ($cx == $cells[$t][0] && $cy == $cells[$t][1]) {
      
if (DEBUG) echo ;
      return 1;
    } else {
if (DEBUG) echo ;
      return 0;
    }
  }
  
  $ret = 0;
  for($i=0; $i<4; ++$i) {
    $x = $cx + $dx[$i];
    $y = $cy + $dy[$i];
    if ($x < 0 || 2 < $x || $y < 0 || 2 < $y
       || ($x == $cells[$b][0] && $y == $cells[$b][1])) {
      
      $x = $cx;
      $y = $cy;
    }
if (DEBUG) echo ;
    $ret += f($x, $y, $n-1, $t, $b);
  }
  
  $memo[] = $ret;
if (DEBUG) echo ;
  return $ret;
}
while ($n = chop(fgets(STDIN))) {
  list($s, $t, $b) = explode(' ', chop(fgets(STDIN)));
  $memo = array();
  $num = f($cells[$s][0], $cells[$s][1], $n, $t, $b);
  echo sprintf('%.8f', $num / pow(4, $n)) . ;
  unset($memo);
}"
PHP,"<?php
while ($line = trim(fgets(STDIN))) {
	$hand = explode(',', $line);
	sort($hand);
	$group = array();
	foreach ($hand as $n) {
		$group[$n] = isset($group[$n]) ? $group[$n] + 1 : 1;
	}
	sort($group);
	$max = max($group);
	if (isFourCard($max)) {
		echo ;
		continue;
	}
	if (isFullHouse($group)) {
		echo ;
		continue;
	}
	if (isStraight($hand)) {
		echo ;
		continue;
	}
	if (isThreeCard($max)) {
		echo ;
		continue;
	}
	if (isTwoPair($group)) {
		echo ;
		continue;
	}
	if (isOnePair($group)) {
		echo ;
		continue;
	}
	echo ;
}
function isFourCard($max) {
	return $max == 4;
}
function isThreeCard($max) {
	return $max == 3;
}
function isFullHouse($group) {
	$c = count($group);
	return ($group[$c - 1] == 3) && ($group[$c - 2] == 2);
}
function isTwoPair($group) {
	$c = count($group);
	return ($group[$c - 1] == 2) && ($group[$c - 2] == 2);
}
function isOnePair($group) {
	$c = count($group);
	return ($group[$c - 1] == 2) && ($group[$c - 2] < 2);
}
function isStraight($hand) {
	$min = $hand[0];
	if ($min == 1 && !in_array(2, $hand)) {
		for ($i = 10; $i <= 13; $i++) {
			if (!in_array($i, $hand)) {
				return false;
			}
		}
		return true;
	}
	for ($i = $min + 1; $i < $min + 5; $i++) {
		if (!in_array($i, $hand)) {
			return false;
		}
	}
	return true;
}"
PHP,"<?php
$set = intval(fgets(STDIN));
$ining = 1;
$out = 0;
$total = 0;
$first = false;
$second = false;
$third = false;
while($line = trim(fgets(STDIN))){
	if($line == ){
		$out++;
	}else if($line == ){
		
		if($third){
			
			$total++;
			$third = false;
		}
		
		if($second){
			
			$third = $second;
			$second = false;
		}
		
		
		if($first){
			
			$second = $first;
			$first = false;
		}
		
		$first = true;
	}else if($line == ){
		
		if($third){
			$total++;
		}
		
		
		if($second){
			$total++;
		}
		
		
		if($first){
			$total++;
		}
		
		$total++;
		
		
		$first = false;
		$second = false;
		$third = false;
	}
	
	if($out >= 3){
		
		echo $total.;
		$ining++;
		$out = 0;
		$total = 0;
		$first = false;
		$second = false;
		$third = false;
	}
	if($ining > $set){
		
		exit();
	}
}"
PHP,"<?php
$string_tmp = array();
$ans_set = array();
while ($line = fgets(STDIN)) {
   $tmp[] = trim($line);
}
$max_lenge = 8;
foreach($tmp as $val){
    
    $max_lenge--;
    
    if(preg_match('/1/',$val)){
        $string_tmp[] = $val;
    }
     
    if($max_lenge < 0){
        $ans_set[] = judge($string_tmp);
        
        $string_tmp = array();
        $max_lenge = 8;
    }
}
$ans_set[] = judge($string_tmp);
foreach($ans_set as $val){
    echo $val.;
}
function judge($string_tmp){
    $ans;
    $tmp_length = count($string_tmp);
        if($tmp_length == 4){
            $ans = ;
        }elseif($tmp_length == 1){
            $ans = ;
        }elseif($tmp_length == 2){
            $ans = judge_line2($string_tmp);
        }elseif($tmp_length == 3){
            $ans = judge_line3($string_tmp);
        }
    return $ans;
}
function judge_line2($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos == $pos2){
        return ;
    }elseif ($pos < $pos2) {
        return ;
    }else{
        return ;
    }
}
function judge_line3($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos > $pos2){
        return ;
    }else{
        return ;
    }
}"
PHP,"<?php
 
$max = 1000000;
 
for ($i = 0; $i < $max; $i++) {
    $array[$i] = 1;
}
$array[1] = 0;
 
for ($i=2; $i<$max; $i++) {
  if ( $array[$i]===0 )
    
    continue;
  else
    
    for ($j=$i*$i; $j<$max; $j+=$i) {
      $array[$j] = 0;
    }
}
 
for ($i=2; $i<$max; $i++){
  $array[$i] += $array[$i-1];   
}
 
while(1){
  $res = fscanf(STDIN, '%d', $n);
  if ($res==0) break;
 
  $cnt = $array[$n];
 
  
  echo $cnt.PHP_EOL;
}"
PHP,"<?php
while (TRUE) {
    $c = fscanf(STDIN, '%d,%d,%d,%d,%d');
    if (feof(STDIN)) {
        break;
    }
    sort($c);
    $hash = array();
    $max = 0;
    foreach ($c as $v) {
        if (!isset($hash[$v])) {
            $hash[$v] = 0;
        }
        $hash[$v]++;
        $max = $hash[$v] > $max ? $hash[$v] : $max;
    }
    arsort($hash);
    $combo = 'null';
    if ($max >= 2) {
        $combo = 'one pair';
    }
    if ($max >= 2 && count($hash) <= 3) {
        $combo = 'two pair';
    }
    if ($max >= 3) {
        $combo = 'three card';
    }
    if (count($hash) === 5 && isStraight($c)) {
        $combo = 'straight';
    }
    if ($max >= 3 && count($hash) <= 2) {
        $combo = 'full house';
    }
    if ($max >= 4) {
        $combo = 'four card';
    }
    echo $combo . PHP_EOL;
}
function isStraight($cards) {
    if (max($cards) - min($cards) === 4) {
        return true;
    }
    if ($cards[0] === 1 && $cards[1] === 10 && $cards[4] === 13) {
        return true;
    }
    return false;
}"
PHP,"<?php
$DEBUG_LEVEL = 0;
main();
function main() {
	$numSets = trim(fgets(STDIN));
	$count = 0;
	while ($count < $numSets) {
		$data = getPoints();
		$adjusted = adjustAlignment($data);
		$result = calc($adjusted);
		printf(, round($result[0], 3), round($result[1], 3), round($result[2], 3));
		$count++;
	}
}
function getPoints() {
	$input = trim(fgets(STDIN));
	list($x1, $y1, $x2, $y2, $x3, $y3) = explode(' ', $input);
	$a = new Point($x1, $y1);
	$b = new Point($x2, $y2);
	$c = new Point($x3, $y3);
	return array($a, $b, $c);
}
function adjustAlignment($points) {
	$minKey = 0;
	$min = $points[$minKey];
	foreach ($points as $k => $p) {
		if ($min->x > $p->x) {
			$min = $p;
			$minKey = $k;
		}
	}
	unset($points[$minKey]);
	$bottom = reset($points);
	$bottomKey = key($points);
	foreach ($points as $k => $p) {
		if ($bottom->y > $p->y) {
			$bottom = $p;
			$bottomKey = $k;
		}
	}
	unset($points[$bottomKey]);
	$top = reset($points);
	$return = array($min, $bottom, $top);
	debug($return);
	return $return;
}
function calc($points) {
	$min = $points[0];
	$a = new Point(0, 0);
	$b = $points[1]->shift(-1 * $min->x, -1 * $min->y);
	$c = $points[2]->shift(-1 * $min->x, -1 * $min->y);
	debug($a . $b . $c );
	$theta = abs($b->x) > 0.00001 ? atan($b->y / $b->x) : -3.1415926535 / 2;
	debug();
	$b->rotate(-$theta);
	$c->rotate(-$theta);
	debug($a . $b . $c );
	$scale = abs(1/$b->x);
	$b->scale($scale);
	$c->scale($scale);
	$x0 = $c->x;
	$y0 = $c->y;
	$gx = 1/2;
	$gy = (- $x0 + $x0*$x0 + $y0*$y0)/(2*$y0);
	$g = new Point($gx, $gy);
	$r = sqrt($g->y * $g->y + 0.5 * 0.5);
	$r *= 1/$scale;
	$g->scale(1/$scale);
	$g->rotate($theta);
	$g->shift($min->x, $min->y);
	return array($g->x, $g->y, $r);
}
class Point {
	public $x;
	public $y;
	function __construct($x, $y) {
		$this->x = $x;
		$this->y = $y;
	}
	function scale($k) {
		$this->x *= $k;
		$this->y *= $k;
		return $this;
	}
	function rotate($theta) {
		$x = $this->x;
		$y = $this->y;
		$this->x = $x * cos($theta) - $y * sin($theta);
		$this->y = $x * sin($theta) + $y * cos($theta);
		return $this;
	}
	function shift($x, $y) {
		$this->x += $x;
		$this->y += $y;
		return $this;
	}
	function __toString() {
		return sprintf(, round($this->x, 3), round($this->y, 3));
	}
}
function debug($out) {
	global $DEBUG_LEVEL;
	if (!isset($DEBUG_LEVEL) || $DEBUG_LEVEL <= 0) {
		return null;
	}
	if (is_string($out)) {
		echo $out . ;
	} else {
		var_dump($out);
	}
}"
PHP,"<?php
        
        $fp = fopen(, );
        while(true) {
            $n = fgets($fp);
            if($n == 0) break;
            
            $data = new Data();
            for($i = 0; $i < $n; $i++) {
                $buf = fgets($fp);
                $splited = explode(, $buf);
                $data->update($splited[0], $splited[1]*$splited[2]);
            }
            $data->countGoodEmployee();
        }
        
        Class Data {
            private $_employee;
            
            public function __construct() {
                $this->_employee = array();
            }
            
            public function update($id, $sales) {
                for($i = 0; $i < count($this->_employee); $i++) {
                    if( $this->_employee[$i]->getId() == $id ) {
                        $this->_employee[$i]->addSales($sales);
                        return;
                    }
                }
                $new_employee = new Employee($id, $sales);
                array_push($this->_employee, $new_employee);
            }
            
            public function countGoodEmployee() {
                $flg = true;
                for($i = 0; $i < count($this->_employee); $i++) {
                    if( $this->_employee[$i]->getSales() >= 1000000 ) {
                        echo $this->_employee[$i]->getId().;
                        $flg = false;
                    }
                }
                if($flg) echo ;
            }
        }
        
        Class Employee {
            private $_id;
            private $_sales;
            
            public function __construct($id, $sales) {
                $this->_id = $id;
                $this->_sales = $sales;
            }
            
            public function addSales($sales) {
                $this->_sales += $sales;
            }
            
            public function getId() {
                return $this->_id;
            }  
            
            public function getSales() {
                return $this->_sales;
            }  
            
            public function printEmployee() {
                echo .$this->_id..$this->_sales.;
            }
        }
        ?>"
PHP,"<?php
$count = 2;	
$value = array();	
while(1){
	$res =fscanf(STDIN, '%d %d %d %d %d %d', $a,$b,$c,$d,$e,$f);
	if ($res==0) break;
	
	$value[0][0]=$a;  $value[0][1]=$b;  $value[0][2]=$c;
	$value[1][0]=$d;  $value[1][1]=$e;  $value[1][2]=$f;
	
	
	if ($a===0 && $e===0){
		
		$y = $c/$b;  $x = $f/$d;
		$x = round($x, 3);  $y = round($y, 3);
		$x = sprintf('%.3f', $x);  $y = sprintf('%.3f', $y); 
		echo $x.' '.$y.PHP_EOL;
		continue;
	} else if ($a===0 || $e===0) {
		$value[0][0]=$d;  $value[0][1]=$e;  $value[0][2]=$f;
		$value[1][0]=$a;  $value[1][1]=$b;  $value[1][2]=$c;
	}
	
	for($i=0; $i<$count; ++$i){
		
		$a = $value[$i][$i];
		
		
		for($j=$i; $j<=$count; ++$j){
			$value[$i][$j] = $value[$i][$j]/$a;
		}
		
		
		for($j=0; $j<$count; ++$j){
			
			if ($j===$i) continue;
			
			$tmp = $value[$j][$i];
			
			for($k=0; $k<=$count; ++$k){
				
				$value[$j][$k] = $value[$j][$k] - $tmp*$value[$i][$k];
			}
		}
	}
	
	
	$x = $value[0][2];  $y = $value[1][2];
	$x = round($x, 3);  $y = round($y, 3);
	$x = sprintf('%.3f', $x);  $y = sprintf('%.3f', $y);
	echo $x.' '.$y.PHP_EOL;
}"
PHP,"<?php
/**
 * Created by PhpStorm.
 * User: ramia
 * Date: 2016/08/31
 * Time: 10:28
 */
/*
 * http:
 */
class Item{
	public $name;
	public $price;
	public $minimumPrice;
	public $material_items = [];
	public function __construct( $name , $price ){
		$this->name  = $name;
		$this->price = intval($price);
		$this->minimumPrice = intval($price);
	}
	public function materialItems($material_items){
		$this->material_items = $material_items;
	}
	public function getMaterials(){
		return $this->material_items;
	}
	public function setMinimumPrice( $minimumPrice ){
		$this->minimumPrice = intval($minimumPrice);
	}
	public function getMinimumPrice(){
		return $this->minimumPrice;
	}
}
while(true){
	$items = [];
	$n = fgets(STDIN);
	if( $n == 0 ){
		exit;
	}
	for( $i=0;$i<$n;$i++ ){
		$line = trim(fgets(STDIN));
		list( $name , $price ) = explode(' ',$line);
		$items[$name] = new Item( $name, $price );
	}
	$n = fgets(STDIN);
	for( $i=0;$i<$n;$i++ ){
		$line = trim(fgets(STDIN));
		$recipe_arr = explode(' ',$line);
		$generate_item = '';
		$material_items = [];
		for ( $j=0;$j<count($recipe_arr);$j++ ){
			if( $j == 0 ){
				$generate_item = $recipe_arr[$j];
			}
			if( $j >= 2 ){
				$material_items[] = $recipe_arr[$j];
			}
		}
		$items[$generate_item]->materialItems($material_items);
	}
	$emulateItem = trim(fgets(STDIN));
	$loop = true;
	while( $loop ){
		$loop = false;
		foreach ( $items as $item_key => $item_value ){
			$materials = $item_value->getMaterials();
			if( count($item_value->getMaterials()) > 0 ){
				$create_value = 0;
				foreach ( $materials as $material_value ){
					$create_value += $items[$material_value]->getMinimumPrice();
				}
				if( $item_value->getMinimumPrice() > $create_value ){
					$item_value->setMinimumPrice($create_value);
					$loop = true;
				}
			}
		}
	}
	echo $items[$emulateItem]->getMinimumPrice().;
}
?>"
PHP,"<?php
$file_handle = fopen('php:
function wfs() {
	global $cnt;
	global $sec;
	global $ary_start;
	global $goal_flag;
	global $queue;
	$queue[0] = $ary_start;			
	$queue_size = count($queue[0]);	
	$queue[0]['sec'] = 0;			
	while (!empty($queue)) {		
	   $cur = array_shift($queue);	
	   
	   
	   $cnt = 0;	
	   for($i=0; $i<$queue_size; $i++){
	       if ($cur[$i] !== $cur[0]){ break; }
	       $cnt++;
	   }
	   if ($cnt === $queue_size) {
	       $goal_flag = 1;
	       $sec = $cur['sec'];	
	       break;	
	   }
	   
	   
	    for($i=0; $i<$queue_size-1; $i++){
	    	if ($cur[$i] !== $cur[$i+1]){
    			$new = $cur;
    			$new['sec'] = $cur['sec'] + 1;
	    		if ($cur[$i] !== 'r' && $cur[$i+1] !== 'r'){	
	    			$new[$i] = 'r';  $new[$i+1] = 'r';
	    		} else if ($cur[$i] !== 'g' && $cur[$i+1] !== 'g'){
	    			$new[$i] = 'g';  $new[$i+1] = 'g';
	    		} else {
	    			$new[$i] = 'b';  $new[$i+1] = 'b';
	    		}
	    		$str = toString($new);
	    		if (empty($visited[$str])){
		    		array_push($queue, $new);
				    $visited[$str] = 1;
				}
	    	}
	    }
	}
}
function toString($ary){
	$str = '';
	foreach ($ary as $key => $val){
		if (is_numeric($key)) {	
			$str = $str.$val;
		}
	}
	return $str;
}
while (1){
	
	$cnt = 0;	
	$sec = 0;
	$goal_flag = 0;
	$queue = array();
	
	$stdin = trim(fgets($file_handle));
	
	if ($stdin == '0'){
		break;
	}
	$ary_start = str_split($stdin);
	
	
	wfs();
	
	if ($goal_flag === 1){
		echo $sec;
	} else {
		echo 'NA';
	}
	echo PHP_EOL;
}
fclose($file_handle);"
PHP,"<?php
    while (true) {
        $num = trim(fgets(STDIN));
        if (strlen($num <= 3)){
                break;
        }
        $hit = 0;
        $brow = 0;
        $brow2 = 0;
        $num = str_split($num);
        
        for($i = 0; $i < 4; $i++){
            if($num[$i] == $num[5]){
                $brow++;
            }if($num[$i] == $num[6]){
                $brow++;
            }if($num[$i] == $num[7]){
                $brow++;
            }if($num[$i] == $num[8]){
                $brow++;
            }
        }
                if ($num[0] == $num[5]) {
                    $hit++;
                    $brow--;
                }if ($num[1] == $num[6]) {
                    $hit++;
                    $brow--;
                }if ($num[2] == $num[7]) {
                    $hit++;
                    $brow--;
                }if ($num[3] == $num[8]) {
                    $hit++;
                    $brow--;
                }
            echo $hit .  . $brow . ;
    }"
PHP,"<?php
$mp = array_fill(0, 10, array_fill(0, 10, 0));
$updateRange = [];
$updateRange[1] = [[1, 0], [0, -1], [0, 0], [0, 1], [-1, 0]];
$updateRange[2] = [[1, -1], [1, 0], [1, 1], [0, -1], [0, 0], [0, 1], [-1, -1], [-1, 0], [-1, 1]];
$updateRange[3] = [[2, 0], [1, -1], [1, 0], [1, 1], [0, -2], [0, -1], [0, 0], [0, 1], [0, 2], [-1, -1], [-1, 0], [-1, 1], [-2, 0]];
function drop($x, $y, $size) {
    global $updateRange;
    foreach ($updateRange[$size] as $point) {
        list($dx, $dy) = $point;
        $nx = $x + $dx;
        $ny = $y + $dy;
        update($nx, $ny);
    }
}
function update($nx, $ny) {
    global $mp;
    if ((0 <= $nx) and ($nx < 10) and (0 <= $ny) and ($ny < 10)) {
        $mp[$ny][$nx]++;
    }
}
while (fscanf(STDIN, , $x, $y, $s)) {
    drop($x, $y, $s, $updateRange, $mp);
}
$cnt = 0;
$score = 0;
for ($y = 0; $y < 10; $y++) {
    for ($x  = 0; $x < 10; $x++) {
        if ($mp[$y][$x] == 0) {
            $cnt++;
        }
        if ($mp[$y][$x] > $score) {
            $score = $mp[$y][$x];
        }
    }
}
echo $cnt . ;
echo $score . ;"
PHP,"<?php
$dice_default = array (
     => 1
    ,  => 5
    ,  => 3
    ,  => 2
    ,  => 4
    ,  => 6
);
$dice = array();
$last_dice = array();
while (true) {
    $stdin = trim(fgets(STDIN));
    if ($stdin == 0) {
        break;
    }
    $dice = $dice_default;
    $result = $dice[];
    for ($i = 0;$i < $stdin;$i++) {
        $command = trim(fgets(STDIN));
        $last_dice = $dice;
        switch ($command) {
            case :
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
            break;
            case :
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
            break;
            case :
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
            break;
            case :
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
            break;
            case :
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
            break;
            case :
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
                $dice[] = $last_dice[];
            break;
            default:
            break;
        }
        $result += $dice[];
    }
    echo $result.;
}
?>"
PHP,"<?php
$templete = array(
    '(%d %s %d %s %d) %s %d',
    '((%d %s %d) %s %d) %s %d',
    '(%d %s (%d %s %d)) %s %d',
    '(%d %s %d) %s %d %s %d',
    '(%d %s %d) %s (%d %s %d)',
    '%d %s (%d %s %d %s %d)',
    '%d %s ((%d %s %d) %s %d)',
    '%d %s (%d %s %d) %s %d',
    '%d %s %d %s (%d %s %d)',
    '%d %s %d %s %d %s %d',
);
$operators = array(
    '+ + +',
    '+ + -',
    '+ + *',
    '+ - +',
    '+ - -',
    '+ - *',
    '+ * +',
    '+ * -',
    '+ * *',
    '- + +',
    '- + -',
    '- + *',
    '- - +',
    '- - -',
    '- - *',
    '- * +',
    '- * -',
    '- * *',
    '* + +',
    '* + -',
    '* + *',
    '* - +',
    '* - -',
    '* - *',
    '* * +',
    '* * -',
    '* * *',
);
while($line = trim(fgets(STDIN))){
    if($line == '0 0 0 0'){
        break;
    }
    $data_ary = explode(,$line);
    foreach($templete as $temp){
        $flg = false;
        if(getAnswer($data_ary,$operators,$temp)){
            $flg = true;
            break;
        }
    }
    if(!$flg){
        echo ;
    }
}
function getAnswer($data_ary,$opes,$temp){
    for($a = 0;$a < 4;$a++){
        for($b = 0;$b < 4;$b++){
            if($a != $b){
                for($c = 0;$c < 4;$c++){
                    if($a != $b && $b != $c && $a != $c){
                        for($d = 0;$d < 4 ;$d++){
                            if($a != $b && $b != $c && $c != $d && $a != $c && $a != $d && $b != $d){
                                foreach($opes as $ope){
                                    $op = explode(,$ope);
                                    $math = sprintf($temp,$data_ary[$d],$op[0],$data_ary[$c],$op[1],$data_ary[$b],$op[2],$data_ary[$a]);
                                    eval('$ans = '.$math.';');
                                    if($ans == 10){
                                        echo .$math.;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}"
PHP,"<?php
$file_handle = fopen('php:
$goal = array(0,1,2,3,4,5,6,7);	
$move = array(-4, 1, 4, -1);	
$visited = array();
function wfs() {
	
	global $goal;
	global $move;
	global $visited;
	
	$str = toString($goal);
	$visited[$str] = 0;			
	$queue[0] = $goal;			
	$queue[0]['dist'] = 0;
	while (!empty($queue)) {
	   $cur = array_shift($queue);	
	   
	   
	   
	   
	   
	   for ($i=0; $i<=7; $i++) {
	       if ($cur[$i]===0){
	           $zero = $i;
	           break;
	       }
	   }
	   
	   for ($i=0; $i<=3; $i++) {
	       
	       $new_zero = $zero + $move[$i];		
	       $new = $cur;		
	       if ($new_zero>=0 && !empty($new[$new_zero])) {
	           if ($zero===3 && $new_zero===4){ continue; }    
	           if ($zero===4 && $new_zero===3){ continue; }    
	           $new[$zero] = $new[$new_zero];
	           $new[$new_zero] = 0;
	           
	           $str = toString($new);
	           if (!isset($visited[$str])) {				
				    $new['dist'] = $cur['dist'] + 1;
				    $visited[$str] = $new['dist'];		
		    		array_push($queue, $new);
	           }
	       }
	   }
	}
}
function toString($ary){
	$str = '';
	foreach ($ary as $key => $val){
		if (is_numeric($key)) {		
			$str = $str.$val;
		}
	}
	return $str;
}
wfs();
while (1){
	
	
	$ary_start = fscanf($file_handle, '%d %d %d %d %d %d %d %d');
	
	if ($ary_start === false){
		break;
	}
	
	
	$str = toString($ary_start);
	
	
	if (isset($visited[$str])){
		echo $visited[$str];
	} else {
		echo 'ERROR';
	}
	echo PHP_EOL;
}
fclose($file_handle);"
PHP,"<?php
$format = array(
    '%d %s %d %s %d %s %d',
    '(%d %s %d %s %d) %s %d',
    '((%d %s %d) %s %d) %s %d',
    '(%d %s (%d %s %d)) %s %d',
    '%d %s (%d %s %d %s %d)',
    '%d %s ((%d %s %d) %s %d)',
    '%d %s (%d %s (%d %s %d))',
    '(%d %s %d) %s %d %s %d',
    '%d %s (%d %s %d) %s %d',
    '%d %s %d %s (%d %s %d)',
    '(%d %s %d) %s (%d %s %d)'
);
while (($line = trim(fgets(STDIN))) !== '0 0 0 0') {
    sscanf($line, '%d %d %d %d', $a, $b, $c, $d);
    $group = getGroup($a, $b, $c, $d);
    $result = 0;
    foreach ($format as $f) {
        foreach ($group as $g) {
            $ptn = getPattern($f, $g);
            foreach ($ptn as $str) {
                eval();
                if ($n === 10) {
                    $result = $str;
                    break 3;
                }
            }
        }
    }
    echo $result, PHP_EOL;
}
function getGroup($a, $b, $c, $d)
{
    $arr = array($a, $b, $c, $d);
    $group = array();
    $check = array();
    for ($i = 0; $i < 4; $i++) {
        for ($j = 0; $j < 4; $j++) {
            if ($i === $j) {
                continue;
            }
            for ($k = 0; $k < 4; $k++) {
                if ($i === $k || $j === $k) {
                    continue;
                }
                $l = 6 - $i - $j - $k;
                $arr2 = array($arr[$i], $arr[$j], $arr[$k], $arr[$l]);
                $str = implode(',', $arr2);
                if (!in_array($str, $check)) {
                    $check[] = $str;
                    $group[] = $arr2;
                }
            }
        }
    }
    return $group;
}
function getPattern($format, $group)
{
    $ptn = array();
    $arr = explode(',', '+,-,*');
    list($a, $b, $c, $d) = $group;
    for ($i = 0; $i < 3; $i++) {
        for ($j = 0; $j < 3; $j++) {
            for ($k = 0; $k < 3; $k++) {
                $ptn[] = sprintf($format, $a, $arr[$i], $b, $arr[$j], $c, $arr[$k], $d);
            }
        }
    }
    return $ptn;
}"
PHP,"<?php
$output = array();
while (true) {
  $words = array();
  $times = array();
  $score = array();
  $minMember = array();
  $member = 0;
  
  $member = trim(fgets(STDIN));
  
  if ($member == ) {
    break;
  }
  
  for ($j = 0; $j < $member; $j++) {
    
    $words = preg_split(, trim(fgets(STDIN)));
    
    $name = $words[0];
    
    $score[$name] = 0;
    
    $kind = $words[1];
    for ($k = 2; $k < count($words); $k++) {
      
      $times[$words[$k]][] = $name;
    }
  }
  
  foreach ($times as $key => $value) {
    $number = count($value);
    foreach ($value as $character) {
      $score[$character] += $member - $number + 1;
    }
  }
  
  $min = min($score);
  foreach ($score as $key => $value) {
    if ($min == $value) {
      $minMember[] = $key;
    }
  }
  
  sort($minMember);
  
  $output[] = $min . ' ' . $minMember[0];
}
foreach ($output as $key => $value) {
  print $output[$key] . PHP_EOL;
}"
PHP,"<?php
$field = array();
for ($i = 0; $i < 10; $i++) {
    $field[] = array();
    for ($j = 0; $j < 10; $j++) {
        $field[$i][] = 0;
    }
}
$dx = array(
    array(1, -1, 0, 0),
    array(1, 1, -1, -1),
    array(2, -2, 0, 0),
);
$dy = array(
    array(0, 0, 1, -1),
    array(1, -1, 1, -1),
    array(0, 0, 2, -2),
);
while (TRUE) {
    fscanf(STDIN, '%d,%d,%d', $x, $y, $size);
    if (feof(STDIN)) {
        break;
    }
    drop($x, $y, $size);
}
$max = 0;
$c = 0;
for ($i = 0; $i < 10; $i++) {
    for ($j = 0; $j < 10; $j++) {
        if ($field[$i][$j] > $max) {
            $max = $field[$i][$j];
        } elseif ($field[$i][$j] === 0) {
            $c++;
        }
    }
}
echo $c . PHP_EOL;
echo $max . PHP_EOL;
function drop($x, $y, $size) {
    global $field, $dx, $dy;
    $field[$y][$x]++;
    for ($i = 0; $i < $size; $i++) {
        for($j = 0; $j < 4; $j++) {
            $nx = $x + $dx[$i][$j];
            $ny = $y + $dy[$i][$j];
            if (isset($field[$ny][$nx])) {
                $field[$ny][$nx]++;
            }
        }
    }
}"
PHP,"<?php
class Node {
	public $left;
	public $right;
	public $value;
	public $largest;
	public function __construct($value) {
		$this->value = $value;
	}
	public function max_value() {
		if ($this->largest !== null) {
			return $this->largest;
		}
		if (is_null($this->left) && is_null($this->right)) {
			return $this->value;
		}
		$left  = is_null($this->left)  ? -1 : $this->left->max_value();
		$right = is_null($this->right) ? -1 : $this->right->max_value();
		return $this->largest = $this->value + max($left, $right);
	}
}
$diamond = array();
while ($line = trim(fgets(STDIN))) {
	$diamond[] = explode(',', $line);
}
$nodes = array();
for ($i = 0; $i < count($diamond); $i++) {
	for ($j = 0; $j < count($diamond[$i]); $j++) {
		$nodes[$i][$j] = new Node($diamond[$i][$j]);
	}
}
for ($i = 0; $i < count($nodes); $i++) {
	for ($j = 0; $j < count($nodes[$i]); $j++) {
		$n = $nodes[$i][$j];
		if ($i < count($diamond)/2 - 1) {
			$n->left  = isset($nodes[$i + 1][$j])     ? $nodes[$i + 1][$j]     : null;
			$n->right = isset($nodes[$i + 1][$j + 1]) ? $nodes[$i + 1][$j + 1] : null;
		} else {
			$n->left  = isset($nodes[$i + 1][$j - 1]) ? $nodes[$i + 1][$j - 1] : null;
			$n->right = isset($nodes[$i + 1][$j])     ? $nodes[$i + 1][$j]     : null;
		}
	}
}
$top = $nodes[0][0];
echo $top->max_value() . ;"
PHP,"<?php
while (true) {
    $line = trim(fgets(STDIN));
    list($H, $W) = explode(' ', $line);
    if ($W == 0 && $H == 0) {
        break;
    }
    $room = array();
    for ($i = 0; $i < $H; $i++) {
        $room[$i] = trim(fgets(STDIN));
    }
    $visited = array();
    for ($i = 0; $i < $H; $i++) {
        for ($j = 0; $j < $W; $j++) {
            $visited[$i][$j] = false;
        }
    }
    $x = 0; $y = 0;
    $isLoop = false;
    while (true) {
        $line = $room[$y];
        $dir = $line[$x];
        if ($dir == '.') {
            break;
        }
        $visited[$y][$x] = true;
        switch ($dir) {
            case '>':
                $x++;
                break;
            case '<':
                $x--;
                break;
            case 'v':
                $y++;
                break;
            case '^':
                $y--;
                break;
        }
        if ($visited[$y][$x]) {
            $isLoop = true;
            break;
        }
    }
    if ($isLoop) {
        echo ;
    } else {
        echo ;
    }
}"
PHP,"<?php
class PQ extends SplPriorityQueue
{
        public function compare($priority1, $priority2)
        {
                if ($priority1 === $priority2) return 0;
                return $priority1 > $priority2 ? -1 : 1;
        }
}
$n=trim(fgets(STDIN));
$m=trim(fgets(STDIN));
$cost=[];
for ($i=0; $i < $m; $i++) {
        list($a,$b,$c,$d)=explode(',',trim(fgets(STDIN)));
        $a--;$b--;
        $cost[$a][$b]=$c;
        $cost[$b][$a]=$d;
}
list($x1,$x2,$y1,$y2)=explode(',',trim(fgets(STDIN)));
$x1--;$x2--;
$y1-=$y2;
$que=new PQ();
$que->insert($x1,0);
$expense=array_fill(0,$n,PHP_INT_MAX/6);
$expense[$x1]=0;
while($que->count()){
        $now=$que->extract();
        if ($now===$x2) {
                break;
        }
        foreach ($cost[$now] as $next => $v) {
                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {
                        $expense[$next]=$expense[$now]+$cost[$now][$next];
                        $que->insert($next,$expense[$next]);
                }
        }
}
$y1-=$expense[$x2];
$que=new PQ();
$que->insert($x2,0);
$expense=array_fill(0,$n,PHP_INT_MAX/6);
$expense[$x2]=0;
while($que->count()){
        $now=$que->extract();
        if ($now===$x1) {
                break;
        }
        foreach ($cost[$now] as $next => $v) {
                if ($expense[$next]>$expense[$now]+$cost[$now][$next]) {
                        $expense[$next]=$expense[$now]+$cost[$now][$next];
                        $que->insert($next,$expense[$next]);
                }
        }
}
$y1-=$expense[$x1];
echo $y1.PHP_EOL;"
PHP,"<?php
$rightCard = 0;
$leftCard = 0;
$rightAns = 0;
$leftAns = 0;
while(true){
    $stdin=trim(fgets(STDIN));
    
    if($stdin == 0){
        break;
    }
    
    if($stdin <= 10000){
        
        for($i = 0;$i<$stdin;$i++){
            
            $cardin=trim(fgets(STDIN));
            $cards = explode(, $cardin);
            
            $leftCard = $cards[0];
            $rightCard = $cards[1];
            
            if($leftCard > $rightCard){
                $leftAns += $leftCard + $rightCard;
            }
            else if($leftCard < $rightCard){
                $rightAns += $leftCard + $rightCard;
            }
            else if($leftCard == $rightCard){
                $leftAns += $leftCard;
                $rightAns += $rightCard;
            }
        }
        
        echo $leftAns..$rightAns.;
        
        $rightAns = 0;
        $leftAns = 0;
    }
}"
PHP,"<?php
        for($loop_cnt = 0; $loop_cnt < 5; $loop_cnt++)
        {
                $data_set = array();
                $data = array();
                
                $input_n = trim(fgets(STDIN));
                if( 0 == $input_n)
                {
                        break;
                }
                
                for($loop_n = 0; $loop_n < $input_n; $loop_n++)
                {
                        $input_conv = explode(  , trim(fgets(STDIN)) );
                        $data_set = $data_set + array( $input_conv[0] => $input_conv[1]) ;
                }
                
                $input_m = trim(fgets(STDIN));
                
                for($loop_m = 0; $loop_m < $input_m; $loop_m++)
                {
                        $input_data = trim(fgets(STDIN));
                        $data[$loop_m] = $input_data;
                }
                
                $work = [];
                for($loop_m = 0; $loop_m < $input_m; $loop_m++)
                {
                        if( isset( $data_set[$data[$loop_m]] ) )
                        {
                                $work[] = $data_set[ $data[$loop_m] ];
                        }
                        else
                        {
                                $work[] = $data[$loop_m];
                        }
                }
                echo implode('' , $work);
                echo ;
        };
?>"
PHP,"<?php
$file_handle = fopen('php:
$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));
function dfs($y, $x){
	global $move;
	global $map;
	$map[$y][$x] = 0;	
	for ($i=0; $i<=3; $i++){	
		$y2 = $y + $move[$i][1];
		$x2 = $x + $move[$i][0];
		if (!empty($map[$y2][$x2]) && $map[$y2][$x2]==1){
			dfs($y2, $x2);
		}
	}
	return;
}
do {
	$num_island = 0;	
	$map = array();
	
	for($y=0; $y<=11; $y++){
		$stdin = trim(fgets($file_handle));
		$map[$y] = str_split($stdin);	
	}
	
	
	for($y=0; $y<=11; $y++){
		for($x=0; $x<=11; $x++){
			if ($map[$y][$x] == 1){		
				dfs($y, $x);
				$num_island++;
			}
		}
	}
	
	echo $num_island;
	echo PHP_EOL;
	
	
	$stdin = fgets($file_handle);
	$flag = ($stdin == PHP_EOL) ? 1 : 0;
} while ($flag === 1);
fclose($file_handle);"
PHP,"<?php
class Queue {
    private $arr = [];
    private $size = 0;
    
    public function push($item) {
        $this->size++;
        array_push($this->arr, $item);
    }
    
    public function pop() {
        $this->size--;
        return array_shift($this->arr);
    }
    
    public function isEmpty() {
        return $this->size === 0;
    }
}
while (true) {
    $s = trim(fgets(STDIN));
    if ($s === ) {
        break;
    }
    search($s);
}
function search($s) {
    $length = strlen($s);
    $que = new Queue();
    $que->push([0, $s]);
    $dic = [];
    $r = ;
    $g = ;
    $b = ;
    for ($i = 0; $i < $length; $i++) {
        $r .= ;
        $g .= ;
        $b .= ;
    }
    $singles = [$r, $g, $b];
    $ok = false;
    while (!$que->isEmpty()) {
        list($score, $state) = $que->pop();
        if (isSingleColor($state, $singles)) {
            echo $score . ;
            $ok = true;
            break;
        }
        for ($i = 0; $i < $length - 1; $i++) {
            $c1 = $state[$i];
            $c2 = $state[$i + 1];
            if ($c1 != $c2) {
                $c3 = other($c1, $c2);
                $newState = substr_replace($state, $c3, $i, 2);
                if (!array_key_exists($newState, $dic)) {
                    $dic[$newState] = $score + 1;
                    $que->push([$score + 1, $newState]);
                }
            }
        }
    }
    if (!$ok) {
        echo ;
    }
}
function isSingleColor($s, $singles) {
    foreach ($singles as $single) {
        if ($s === $single) {
            return true;
        }
    }
    return false;
}
function other($c1, $c2) {
    if ($c1 === ) {
        if ($c2 === ) {
            return ;
        } elseif ($c2 === ) {
            return ;
        }
    } elseif ($c1 === ) {
        if ($c2 === ) {
            return ;
        } elseif ($c2 === ) {
            return ;
        }
    } elseif ($c1 === ) {
        if ($c2 === ) {
            return ;
        } elseif ($c2 === ) {
            return ;
        }
    }
}"
PHP,"<?php
  const DIRS = array('R','D','L','U');
  $p = array(1,0,0);
  $path = 'R';
  $step =  array(array(1,0), array(0,1), array(-1,0), array(0,-1));
  function frontIsClear($p, $l) {
      list($x,$y,$d) = $p;
      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1))
             || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))
             || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1))
             || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));
  }
  function canMove($p,$l) {
      list($x,$y,$d) = $p;
      switch($p[2]) {
      case 0:
          return $x!=4 && $l[2*$y][$x];
      case 1:
          return $y!=4 && $l[2*$y+1][$x];
      case 2:
          return $x!=0 && $l[2*$y][$x-1];
      case 3:
          return $y!=0 && $l[2*$y-1][$x];
      }
  }
  function move(&$p,$step) {
      $p[0] = $p[0] + $step[$p[2]][0];
      $p[1] = $p[1] + $step[$p[2]][1];
  }
  for($i=0;$i<9;$i++)
      $l[] = trim(fgets(STDIN));
  while(true) {
       if(!frontIsClear($p,$l)){
          $p[2] = ($p[2]+3) % 4;
       } else {
           while(!canMove($p,$l)) {
              $p[2] = ($p[2]+1) % 4;
           }
       }
       if($p == array(0,0,0))
           break;
       move($p,$step);
       $path .= DIRS[$p[2]];
  }
  echo $path.PHP_EOL;"
PHP,"<?php
	$inputArr = ReadStd();
	$octalArr = ChangeOctalToDecimal($inputArr);
	$answerArr = CreateAnswer($octalArr);
	Display($answerArr);
	/**
      * ?¨??????\\?????????????????????????????????????????????????????????
      */
    function ReadStd(){
	    $inputArr = array();
		while(intval($line_num = trim(fgets(STDIN)))!=0){
			$inputArr[] =  intval($line_num);
		}
		return $inputArr;
	}
	/**
      * ?????°??§??????????????????????????°???????????????????????°????????????????????????
      */
	function ChangeOctalToDecimal($inputArr){
		$octalArr = array();
		foreach ($inputArr as $num) {
			$octalArr[] = decoct ( $num );
		}
		return $octalArr;
	}
	/**
      * 4567???????????????5789??????????????????
      * ?????????8?????°???0,1,2,3,4,5,6,7?????????
      * ?????????8?????°???0,1,2,3,5,7,8,9???????????????????????????
      */
	function CreateAnswer($octalArr){
		$answerArr = array();
		foreach ($octalArr as $num) {
	    $targets    = array(,,,);
	    $modifieds  = array(,,,);
            
            
            
            
            $num = str_replace ( $targets , $modifieds , $num );
            $answerArr[] = $num;
		}
		return $answerArr;
	}
	/**
      * ?????????????????????
      */
	function Display($answerArr){
		echo implode(,$answerArr);
	}
?>"
PHP,"<?php
while (true) {
    $line = trim(fgets(STDIN));
    list($H, $W) = explode(' ', $line);
    if ($W == 0 && $H == 0) {
        break;
    }
    $room = array();
    for ($i = 0; $i < $H; $i++) {
        $room[$i] = trim(fgets(STDIN));
    }
    $visited = array();
    for ($i = 0; $i < $H; $i++) {
        for ($j = 0; $j < $W; $j++) {
            $visited[$i][$j] = false;
        }
    }
    $x = 0; $y = 0;
    $isLoop = false;
    while (true) {
        $line = $room[$y];
        $dir = $line[$x];
        if ($dir == '.') {
            break;
        }
        $visited[$y][$x] = true;
        switch ($dir) {
            case '>':
                $x++;
                break;
            case '<':
                $x--;
                break;
            case 'v':
                $y++;
                break;
            case '^':
                $y--;
                break;
        }
        if ($visited[$y][$x]) {
            $isLoop = true;
            break;
        }
    }
    if ($isLoop) {
        echo ;
    } else {
        echo ; 
    }
}"
PHP,"<?php
$up=1;
$south=2;
$east=3;
$west=4;
$north=5;
$down=6;
$ans=1;
$tmp;
$count=0;
while($count<5){
    
    $stdin=trim(fgets(STDIN));
    
    if($stdin==0){
        break;
    }
    if($stdin<=10000){
        
        for($i=0;$i<$stdin;$i++){
            $diceRoll=trim(fgets(STDIN));
            
            switch($diceRoll){
                case:
                    $tmp=$up;
                    $up=$south;
                    $south=$down;
                    $down=$north;
                    $north=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$north;
                    $north=$down;
                    $down=$south;
                    $south=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$east;
                    $east=$down;
                    $down=$west;
                    $west=$tmp;
                    break;
                case:
                    $tmp=$up;
                    $up=$west;
                    $west=$down;
                    $down=$east;
                    $east=$tmp;
                    break;
                case:
                    $tmp=$south;
                    $south=$east;
                    $east=$north;
                    $north=$west;
                    $west=$tmp;
                    break;
                case:
                    $tmp=$south;
                    $south=$west;
                    $west=$north;
                    $north=$east;
                    $east=$tmp;
                    break;
                default:
            }
            
            $ans+=$up;
        }
        
        echo $ans.;
        
        $up=1;
        $south=2;
        $east=3;
        $west=4;
        $north=5;
        $down=6;
        $ans=1;
        
        $count++;
    }
}"
PHP,"<?php
$file_handle = fopen('php:
fscanf($file_handle, '%d', $n);
for($i=1; $i<=$n; $i++){
	fscanf($file_handle,'%f %f %f %f %f %f',$x1,$y1,$x2,$y2,$x3,$y3);
	
	
	
	
	if ( ($x1-$x2)==0 ){
		$a1 = false;
		$ra1 = 0;
	} else if ( ($y1-$y2)==0 ){
		$a1 = 0;
		$ra1 = false;
	} else {
		$a1 = ($y1-$y2) / ($x1-$x2);
		$ra1 = -1 / $a1;
	}
	if ( ($x2-$x3)==0 ){
		$a2 = false;
		$ra2 = 0;
	} else if ( ($y2-$y3)==0 ){
		$a2 = 0;
		$ra2 = false;
	} else {
		$a2 = ($y2-$y3) / ($x2-$x3);
		$ra2 = -1 / $a2;
	}
	if ( ($x3-$x1)==0 ){
		$a3 = false;
		$ra3 = 0;
	} else if ( ($y3-$y1)==0 ){
		$a3 = 0;
		$ra3 = false;
	} else {
		$a3 = ($y3-$y1) / ($x3-$x1);
		$ra3 = -1 / $a3;
	}
	
	
	
	
	
	
	$mx1 = ($x1+$x2)/2;  $my1 = ($y1+$y2)/2;
	$mx2 = ($x2+$x3)/2;  $my2 = ($y2+$y3)/2;
	$mx3 = ($x3+$x1)/2;  $my3 = ($y3+$y1)/2;
	
	$rb1 = $my1 - $ra1*$mx1;
	$rb2 = $my2 - $ra2*$mx2;
	$rb3 = $my3 - $ra3*$mx3;
	
	if ($ra1 !== false && $ra2 !== false) {
		$px = ($rb2-$rb1) / ($ra1-$ra2);
		$py = $ra1*$px + $rb1;
	} else if ($ra2 !== false && $ra3 !== false) {
		$px = ($rb3-$rb2) / ($ra2-$ra3);
		$py = $ra2*$px + $rb2;
	} else if ($ra3 !== false && $ra1 !== false) {
		$px = ($rb1-$rb3) / ($ra3-$ra1);
		$py = $ra3*$px + $rb3;
	}
	
	$sqr = pow($px-$x1,2) + pow($py-$y1,2);
	$r = sqrt($sqr);
	
	$px = round($px, 3); $px = sprintf('%.3f', $px);
	$py = round($py, 3); $py = sprintf('%.3f', $py);
	$r = round($r, 3);   $r = sprintf('%.3f', $r);
	
	echo $px.' '.$py.' '.$r.PHP_EOL;
}"
PHP,"<?php
$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));
function dfs($c, $y, $x){
	global $move;
	global $map;
	global $goal_flag;
	global $yg;
	global $xg;
	if ($y === $yg && $x === $xg){	
		$goal_flag = 1;
		return;
	}
	$map[$c][$y][$x] = 0;	
	for ($i=0; $i<=3; $i++){	
		$y2 = $y + $move[$i][1];
		$x2 = $x + $move[$i][0];
		if (!empty($map[$c][$y2][$x2]) && $map[$c][$y2][$x2]===1){
			dfs($c, $y2, $x2);
		}
	}
	return;
}
while(1){
	
	$goal_flag = 0;
	$map = array();
	$usecolor = 0;		
	
	fscanf(STDIN, '%d %d', $w, $h);
	
	if ($w==0 && $h==0){
		break;
	}
	fscanf(STDIN, '%d %d', $xs, $ys);
	fscanf(STDIN, '%d %d', $xg, $yg);
	fscanf(STDIN, '%d', $n);
	for ($i=0; $i<$n; $i++){
		fscanf(STDIN, '%d %d %d %d', $c, $d, $xblock, $yblock);
		
		if ($d === 0){		
			for ($p=0; $p<=3; $p++){
				for ($q=0; $q<=1; $q++){
					$map[$c][$yblock + $q][$xblock + $p] = 1;
				}
			}
		} else {
			for ($p=0; $p<=1; $p++){
				for ($q=0; $q<=3; $q++){
					$map[$c][$yblock + $q][$xblock + $p] = 1;
				}
			}
		}
	}
	
	for ($c=1; $c<=5; $c++){
		if (!empty($map[$c][$ys][$xs]) && $map[$c][$ys][$xs] === 1){
			$usecolor = $c;
			break;
		}
	}
	
	if ($usecolor !== 0){
		dfs($usecolor, $ys, $xs);
	}
	
	if ($goal_flag === 1){
		echo 'OK';
	} else {
		echo 'NG';
	}
	echo PHP_EOL;
}"
PHP,"<?php
while (true) {
    $line = trim(fgets(STDIN));
    list($H, $W) = explode(' ', $line);
    if ($W == 0 && $H == 0) {
        break;
    }
    $rooms = array();
    for ($i = 0; $i < $H; $i++) {
        $room[$i] = trim(fgets(STDIN));
    }
    $visited = array();
    for ($i = 0; $i < $H; $i++) {
        for ($j = 0; $j < $W; $j++) {
            $visited[$i][$j] = false;
        }
    }
    $x = 0; $y = 0;
    $isLoop = false;
    while (true) {
        $line = $room[$y];
        $dir = $line[$x];
        if ($dir == '.') {
            break;
        }
        $visited[$y][$x] = true;
        switch ($dir) {
            case '>':
                $x++;
                break;
            case '<':
                $x--;
                break;
            case 'v':
                $y++;
                break;
            case '^':
                $y--;
                break;
        }
        if ($visited[$y][$x]) {
            $isLoop = true;
            break;
        }
    }
    if ($isLoop) {
        echo ;
    } else {
        echo ; 
    }
}
 "
PHP,"<?php
$dsCount = trim(fgets(STDIN));
$stdin = array();
$i = 0;
$outCount = 0;
$hitCount = 0;
$roopNo = 0;
$score = 0;
$scores = array($dsCount);
while (true) {
  
  $stdin[$i] = trim(fgets(STDIN));
  
  if ($stdin[$i] == ) {
    
    $hitCount++;
    
    if ($hitCount >= 4) {
      $hitCount = 3;
      $score += 1;
    }
  
  } elseif ($stdin[$i] == ) {
    
    $outCount++;
  
  } elseif ($stdin[$i] == ) {
  	$score += ($hitCount + 1);
  	$hitCount = 0;
  }
  
  if ($outCount >= 3) {
  	
    if ($roopNo >= ($dsCount - 1)) {
      
      $scores[$roopNo] = $score;
      
      break;
    
    } else {
      
      $scores[$roopNo] = $score;
      
      $score = 0;
      $hitCount = 0;
      $outCount = 0;
    }
    
    $roopNo++;
  }
}
foreach ($scores as $key => $value) {
  print $value . PHP_EOL;
}"
PHP,"<?php
main();
function main() {
	$points = array();
	while ($line = trim(fgets(STDIN))) {
		list($x, $y) = explode(',', $line);
		$points[] = new Point($x, $y);
	}
	$sum = 0;
	$o = $points[0];
	for ($i = 1; $i < count($points) - 1; $i++) {
		$p1 = $points[$i];
		$p2 = $points[$i+1];
		$T = new Triangle($o, $p1, $p2);
		$sum += $T->getArea();
	}
	echo $sum . ;
}
class Triangle {
	public $A, $B, $C;
	public $a, $b, $c;
	public function __construct(Point $A, Point $B, Point $C) {
		$this->A = $A;
		$this->B = $B;
		$this->C = $C;
		$this->a = $B->distanceFrom($C);
		$this->b = $C->distanceFrom($A);
		$this->c = $A->distanceFrom($B);
	}
	public function getArea() {
		$z = ($this->a + $this->b + $this->c) / 2;
		return sqrt($z * ($z - $this->a) * ($z - $this->b) * ($z - $this->c));
	}
}
class Point {
	public $x, $y;
	public function __construct($x, $y) {
		$this->x = $x;
		$this->y = $y;
	}
	public function distanceFrom(Point $p) {
		$dx = $this->x - $p->x;
		$dy = $this->y - $p->y;
		return sqrt($dx * $dx + $dy * $dy);
	}
}"
PHP,"<?php
function bomber($data, $x, $y){
	if($x > 0 && $y > 0 && $x < 9 && $y < 9 && $data[$y][$x] > 0){
		
		$data[$y][$x] = 0;
		
		for($i = 1; $i <= 3; $i++){
			$data = bomber($data, $x-$i, $y);
			$data = bomber($data, $x+$i, $y);
			$data = bomber($data, $x, $y-$i);
			$data = bomber($data, $x, $y+$i);
		}
	}
	return $data;
}
$count = intval(fgets(STDIN));
$dataset = array();	
$total = 11 * $count;	
$now = 0;		
while($line = fgets(STDIN)){
	$line = trim($line);
	
	if($line == ){
		$now++;
		$dataset[$now] = array();
		$col = 1;
	}else{
		if($col == 10){
			
			$dataset[$now][] = intval($line);
		}else if($col == 9){
			
			$dataset[$now][] = intval($line);
			$col++;
		}else{
			$dataset[$now][$col] = array();
			for($row = 1; $row <= 8; $row++){
				$dataset[$now][$col][$row] = intval(substr($line, $row-1, 1));
			
			}
			$col++;
		}
	}
	
	
	$total--;
	if($total < 1) break;
}
foreach($dataset as $key => $data){
	
	$x = $data[]; 
	$y = $data[];
	
	
	unset($data[]);
	unset($data[]);
	
	
	$data = bomber($data, $x, $y);
	
	echo ;
	foreach($data as $row){
		echo implode($row).;
	}
}"
PHP,"<?php
while (true) {
    $line = trim(fgets(STDIN));
    list($H, $W) = explode(' ', $line);
    if ($W == 0 && $H == 0) {
        break;
    }
    $room = array();
    for ($i = 0; $i < $H; $i++) {
        $room[$i] = trim(fgets(STDIN));
    }
    $visited = array();
    for ($i = 0; $i < $H; $i++) {
        for ($j = 0; $j < $W; $j++) {
            $visited[$i][$j] = false;
        }
    }
    $x = 0; $y = 0;
    $isLoop = false;
    while (true) {
        $line = $room[$y];
        $dir = $line[$x];
        if ($dir == '.') {
            break;
        }
        $visited[$y][$x] = true;
        switch ($dir) {
            case '>':
                $x++;
                break;
            case '<':
                $x--;
                break;
            case 'v':
                $y++;
                break;
            case '^':
                $y--;
                break;
        }
        if ($visited[$y][$x]) {
            $isLoop = true;
            break;
        }
    }
    if ($isLoop) {
        echo ;
    } else {
        echo ; 
    }
}"
PHP,"<?php
while (true) {
    $line = trim(fgets(STDIN));
    list($H, $W) = explode(' ', $line);
    if ($W == 0 && $H == 0) {
        break;
    }
    $room = array();
    for ($i = 0; $i < $H; $i++) {
        $room[$i] = trim(fgets(STDIN));
    }
    $visited = array();
    for ($i = 0; $i < $H; $i++) {
        for ($j = 0; $j < $W; $j++) {
            $visited[$i][$j] = false;
        }
    }
    $x = 0; $y = 0;
    $isLoop = false;
    while (true) {
        $line = $room[$y];
        $dir = $line[$x];
        if ($dir == '.') {
            break;
        }
        $visited[$y][$x] = true;
        switch ($dir) {
            case '>':
                $x++;
                break;
            case '<':
                $x--;
                break;
            case 'v':
                $y++;
                break;
            case '^':
                $y--;
                break;
        }
        if ($visited[$y][$x]) {
            $isLoop = true;
            break;
        }
    }
    if ($isLoop) {
        echo ;
    } else {
        echo ; 
    }
}
 "
PHP,"<?php
$alphabet = range('a', 'z');
$arr = array(1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25);
fscanf(STDIN, '%d', $n);
for ($i = 0; $i < $n; $i++) {
    $str = trim(fgets(STDIN));
    foreach ($arr as $a) {
        for ($b = 0; $b < 26; $b++) {
            
            $encode = array();
            foreach ($alphabet as $m => $ch) {
                $encode[$ch] = $alphabet[($a * $m + $b) % 26];
            }
            $word1 = $encode['t'] . $encode['h'] . $encode['i'] . $encode['s'];
            $word2 = $encode['t'] . $encode['h'] . $encode['a'] . $encode['t'];
            $format = ;
            
            if (preg_match($format, $str)) {
                
                $decode = array_flip($encode);
                break 2;
            }
        }
    }
    for ($j = 0, $len = strlen($str); $j < $len; $j++) {
        $ch = $str[$j];
        echo ctype_alpha($ch) ? $decode[$ch] : $ch;
    }
    echo PHP_EOL;
}"
PHP,"<?php
while((list($h, $w) = explode(, trim(fgets(STDIN)))) && $h && $w) {
    $field = array();
    for($i = 0; $i < $h; $i++) {
        foreach(str_split(trim(fgets(STDIN))) as $dir) {
            $field[$i][] = new Tile($dir);
        }
    }
    $person = new Person(0, 0);
    $flg = false;
    while(($dir = $field[$person->getY()][$person->getX()]->getDir()) != null) {
        if($flg = $person->move($dir)) {
            break;
        }
    }
    echo $flg ? $person->showPos() : , PHP_EOL;
}
class Tile {
    private $flg_;
    private $dir_;
    function __construct($dir) {
        $this->flg_ = false;
        $this->dir_ = $dir;
    }
    function getDir() {
        if($this->flg_) {
            return null;
        } else {
            $this->flg_ = true;
            return $this->dir_;
        }
    }
}
class Person {
    private $y_;
    private $x_;
    function __construct($y, $x) {
        $this->y_ = $y;
        $this->x_ = $x;
    }
    function move($dir) {
        switch($dir) {
          case :
            $this->y_++;
            return false;
          case :
            $this->y_--;
            return false;
          case :
            $this->x_++;
            return false;
          case :
            $this->x_--;
            return false;
          case :
            return true;
        }
    }
    function getY() {
        return $this->y_;
    }
    function getX() {
        return $this->x_;
    }
    function showPos() {
        echo $this->x_, , $this->y_;
    }
}"
PHP,"<?php
while(1) {
    $c = trim(fgets(STDIN));
    if($c == 0){
        break;
    }
    
    $aa = 0;
    $r = 0;
    $wr = 0;
    for ($i = 0; $i < $c; $i++) {
        $n = 0;
        $w = 0;
        
         $ww = trim(fgets(STDIN));
         $www = explode(,trim($ww));
        
         if(count($www) == 4) {
         $n = $www[0] + $www[1] + $www[2]; 
         $w = $www[3];
         switch($n){
         case $n <= 60:
             $r = 600;
             break;
         case $n <= 80:
            
             $r = 800;
             break;
         case $n <= 100:
            $r = 1000;
            break;
        case $n <= 120:
            $r = 1200;
            break;
        case $n <= 140:
            $r = 1400;
            break;
        case $n <= 160:
            $r = 1600;
            break;
        case $n > 160:
            $r = 666;
            
            break;
    }
    switch($w){
         case $w <= 2:
             $wr = 600;
             break;
         case $w <= 5:
             $wr = 800;
             break;
         case $w <= 10;
            $wr = 1000;
            break;
        case $w <= 15:
            $wr = 1200;
            break;
        case $w <= 20;
            $wr = 1400;
            break;
        case $w <= 25:
            $wr = 1600;
            
            break;
        case $w > 25:
            $wr = 666;
            break;
    }
    
    
    if($r == 666 || $wr == 666) {
                    
    } elseif($r < $wr) {
        $aa += $wr;
        
    } else {
        $aa += $r;
    }
    
    }
        
    }
    echo $aa . PHP_EOL;
    
}"
PHP,"<?php
$case = 0;
while(true){
    $input_line = fgets(STDIN);
    $W = str_replace(array(,,), '', $input_line);
    $input_line = fgets(STDIN);
    $N = str_replace(array(,,), '', $input_line);    
    if($W == 0) {
        break;
    }
    $case++;
    $array_v = array(-1);
    $array_w = array(-1);
    for($i = 0; $i < $N; $i++){
        $input_line = fgets(STDIN);
        $input_line = str_replace(array(,,), '', $input_line);
        $array = explode(, $input_line);
        array_push($array_v, $array[0]);
        array_push($array_w, $array[1]);
    }
    $dp = array();
    $dp_w = array();
    for($i = 0; $i <= $N; $i++){
        for($j = 0; $j <= $W; $j++){
            $x = 0;
            $y = 0;
            $x_w = 0;
            $y_w = 0;
            if($i == 0){
                $dp[$i][$j] = 0;
                $dp_w[$i][$j] = 0;
            } else{
                $x = $dp[$i - 1][$j];
                $x_w = $dp_w[$i - 1][$j];
                if($array_w[$i] <= $j) {
                    $y = $dp[$i - 1][$j - $array_w[$i]] + $array_v[$i];
                    $y_w = $dp_w[$i - 1][$j - $array_w[$i]] + $array_w[$i];
                }
                $dp[$i][$j] = ($x > $y) ? $x : $y;
                $dp_w[$i][$j] = ($x > $y) ? $x_w : $y_w;
            }
        }
        
        if ($i >= 2) {
            unset($dp[$i-2]);
        }
    }
    /*
     * デバッグ用出力
    for($i = 0; $i <= $N; $i++){
        echo $i.;
        for($j = 0; $j <= $W; $j++){
            echo $dp[$i][$j].;
        }
        echo ;
    }
    echo ;
    for($i = 0; $i <= $N; $i++){
        echo $i.;
        for($j = 0; $j <= $W; $j++){
            echo $dp_w[$i][$j].;
        }
        echo ;
    }
    */
    $array_ans_w = array();
    for($j = 0; $j <= $W; $j++){
        if($dp[$N][$j] == $dp[$N][$W]){
            array_push($array_ans_w, $dp_w[$N][$j]);
        }
    }
    echo ;
    echo $dp[$N][$W] . ;
    echo min($array_ans_w) . ;
}
?>"
PHP,"<?php
 
$file_handle = fopen('php:
 
function dfs($cur) {
    
    global $dist;
    global $leaf;
    global $flag;
     
    
    
    
    $flag[$cur['node']] = 1;
     
    $childnode = childnode($cur['node']);
    if (empty( $childnode )) return;
    foreach ($childnode as $island_num => $distance) {
    	if ( $flag[$island_num] === 1 ) continue;
        $grandchildnode = childnode($island_num);
        if (!empty($grandchildnode)) {
            $new['node'] = $island_num;
            $new['dist'] = $cur['dist'] + $dist[$cur['node']][$new['node']];
            dfs($new);
        } else {
            $leaf[$cur['node']] = $cur['dist'];     
            $dist[$cur['node']][$island_num] = 0;   
            $dist[$island_num][$cur['node']] = 0;   
        }
    }
}
 
function childnode($island){
    global $dist;
    global $flag;
   
   $childnode = array();
   if (!empty($dist[$island])){
       foreach ($dist[$island] as $key => $val){
           if ($flag[$key] !== 1) {
               $childnode[$key] = $val;
           }
       }
   }
   return $childnode;
}
 
function max_dist($leaf){
    $max = 0;
    foreach ($leaf as $key => $val){
        if ($max < $leaf[$key]){
            $max = $leaf[$key];
        }
    }
    return $max;
}
 
function calc(){
    global $dist;
    global $leaf;
    global $max_dist;
    
    $sum = 0;
    foreach($dist as $key => $val){
        foreach($dist[$key] as $d2){
            $sum += $d2;
        }
    }
     
    
    $sum -= $max_dist;
    return $sum;
}
 
while (1){
    
    $dist = array();
    $leaf = array();    
    $flag = array();	
 
    
    $stdin = fscanf($file_handle, '%d');    
    $n = $stdin[0];
    
    if ($n == 0){
        break;
    }
     
    for ($i=0; $i < $n-1; $i++){
        $info = fscanf($file_handle, '%d %d %d');
        $parent = $info[0]; $child = $info[1]; $distance = $info[2];
        $dist[$parent][$child] = $distance;
        $dist[$child][$parent] = $distance;
    }
    
    for ($i=1; $i<=$n; $i++){
    	$flag[$i] = 0;	
    }
    
 
    
    $stack['node'] = 1;     
    $stack['parent'] = NULL;
    $stack['dist'] = 0;
    dfs($stack);
    $max_dist = max_dist($leaf);
    $sum = calc();
    
    
    echo $sum;
    echo PHP_EOL;
}
 
fclose($file_handle);"
PHP,"<?php
fscanf(STDIN, '%d', $N);
for ($i = 0; $i < $N; $i++) {
    fscanf(STDIN, '%s', $a);
    fscanf(STDIN, '%s', $b);
    
    if (max(strlen($a), strlen($b)) > 80) {
        echo ;
        continue;
    }
    
    $arr = array_fill(0, 81, 0);
    $a = sprintf('%081s', $a);
    $b = sprintf('%081s', $b);
    
    for ($j = 80; $j > 0; $j--) {
        
        $n = $arr[$j] + $a[$j] + $b[$j];
        
        if ($n >= 10) {
            
            $arr[$j] = substr($n, 1);
            
            $arr[$j - 1] += 1;
        } else {
            $arr[$j] = $n;
        }
    }
    
    $result = preg_replace('/^0+(\\d+)$/', '$1', implode('', $arr));
    if (strlen($result) > 80) {
        echo ;
    } else {
        echo $result, PHP_EOL;
    }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = inp.split(' ').map(Number);
    var found = false;
 
  FIRST:for(var a = 0; a < 4; a++){
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
 
          for(var op1 = 0; op1 < 3; op1++){
            for(var op2 = 0; op2 < 3; op2++){
              for(var op3 = 0; op3 < 3; op3++){
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inp[a], inp[b], operands[op1], inp[c], operands[op2], inp[d], operands[op3]];
                    break;
                  case 1:
                    
                    polish = [inp[a], inp[b], inp[c], operands[op1], operands[op2], inp[d], operands[op3]];
                    break;
                  case 2:
                    
                    polish = [inp[a], inp[b], operands[op1],inp[c], inp[d], operands[op2], operands[op3]];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        if(w - tw < 0){
          dp[w] = pdp[w];
        }else{
          dp[w] = max(pdp[w-tw] + tv, pdp[w]);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      if(pdp[i] > resultCost){
        resultCost = pdp[i];
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('hex', 0, bytesRead).split('0a'); 
main();
 
function main(){
  
  var multiply = new Int8Array([1,3,5,7,9,11,15,17,19,21,23,25]);
  var lenj = multiply.length;
  var alphabets = new Int8Array(26);
  var convertTable = new Int8Array(123);
  for(var init = 123; init--;)
    convertTable[init] = init;
FIRST:for(var i = 1, leni = input.length - 1; i < leni; i++){
    var inp = input[i];
    var c = inp.split('20');
    var clen = c.length;
  
    for(var j = 0; j < lenj; j++){
      var alpha = multiply[j];
      for(var beta = 26; beta--;){
        for(var conv = 26; conv--;){ 
          alphabets[conv] = (conv * alpha + beta) % 26 + 97;
        }
        
        var thatIs = alphabets[19].toString(16) + alphabets[7].toString(16) + alphabets[0].toString(16) + alphabets[19].toString(16);
        var thisIs = alphabets[19].toString(16) + alphabets[7].toString(16) + alphabets[8].toString(16) + alphabets[18].toString(16);
        var found = false;
        for(var d = clen; d--;){
          var cd = c[d];
          if(cd == thatIs || cd == thisIs){
            found = true;
            break;
          }
        }
        
        if(found){
          for(var conv = 26; conv--;){
            var fromCode = alphabets[conv];
            convertTable[fromCode] = conv + 97; 
          }
          
          var result = ;
          for(var k = 0; k < inp.length; k+=2){
            result += String.fromCharCode(convertTable[parseInt(inp[k] + inp[k+1], 16)]);
          }
          console.log(result);
          continue FIRST;
        }
        
      }
    }
  
  }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = new Int8Array(inp.split(' ').map(Number));
    var found = false;
    var searched = new Int8Array(10000);
 
  FIRST:for(var a = 0; a < 4; a++){
    var inpa = inp[a]; 
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      var inpb = inp[b];
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        var inpc = inp[c];
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
          var inpd = inp[d];
          var target = inpa*1000 + inpb*100 + inpc*10 + inpd;
          if(searched[target])
            continue;
          searched[target]++;
          for(var op1 = 0; op1 < 3; op1++){
            var operandsop1 = operands[op1];
            for(var op2 = 0; op2 < 3; op2++){
              var operandsop2 = operands[op2];
              for(var op3 = 0; op3 < 3; op3++){
                var operandsop3 = operands[op3];
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inpa, inpb, operandsop1, inpc, operandsop2, inpd, operandsop3];
                    break;
                  case 1:
                    
                    polish = [inpa, inpb, inpc, operandsop1, operandsop2, inpd, operandsop3];
                    break;
                  case 2:
                    
                    polish = [inpa, inpb, operandsop1,inpc, inpd, operandsop2, operandsop3];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w]|0;
        dp[w] = pdpw;
        if(w - tw >= 0){
          dp[w] = max((pdp[w-tw]|0) + tv, pdpw);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"function Main(input) {
	var week = [,,,,,,];
    inputLine = input.split();
    for(var i=0;;i++){
    	var time = new Date();
    	time.setFullYear(2004);
    	var date = inputLine[i].split();
    	var month = Int(date[0]);
    	var day = Int(date[1]);
    	if(month == 0)break;
    	time.setMonth(month-1);
    	time.setDate(day);
    	output(week[time.getDay()]);
    }
}
function ascendingOrder(val1,val2){
    return val1 - val2;
}
function descendingOrder(val1,val2){
    return val2 - val1;
}
function Int(str){
    return parseInt(str, 10);
}
function Str(num){
    return num.toString(10);
}
function output(str){
	if(_Isdebug){
		document.getElementById().value+=(str+);
	}
	console.log(str);
}
var _Isdebug = false;
function debug(){
	_Isdebug = true;
	var input = document.getElementById().value;
	document.getElementById().value+=;
	Main(input);
}
Main(require().readFileSync(, ));"
JavaScript,"var fs = require('fs'),
    length = fs.fstatSync(process.stdin.fd).size,
    buffer = new Buffer(length),
    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
    input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 return a - ((a-b) & ((a-b) >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
    
function main(){
  var primeNumbers = calcPrimeNumbers();
  for(var i = 0, len = input.length; i < len; i++){
    console.log(primeNumbers[parseInt(input[i], 10)]);
  }
}
   
function calcPrimeNumbers(){
  var max = 999999;
  var primeNumbers = new Int32Array(max + 1);
   
  
  primeNumbers[0] = primeNumbers[1] = 0;
  
  for(var i = 2; i <= 1000; i++){
  if(primeNumbers[i]){
      continue;
    }
       
    for(var j = (i<<1); j <= max; j+=i){
      primeNumbers[j] = 1;
    }
  }
   
   for(var i = 2; i <= max; i++){
    
    primeNumbers[i] = primeNumbers[i-1] + 1 - primeNumbers[i];
  }
     
  return primeNumbers;
}"
JavaScript,"var fs = require('fs'),
    length = fs.fstatSync(process.stdin.fd).size,
    buffer = new Buffer(length),
    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
    input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  while(len--){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  while(y--){
    var x = 10;
    while(x--){
      var fyx = f[y+2][x+2];
      nd += !fyx;
      md = mx(fyx, md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 return a - ((a-b) & ((a-b) >> 31));
}"
JavaScript,"var fs = require();
var primes = [2];
function scan_primes(max) {
    var min = primes[primes.length - 1];
    if(max <= min) {
        return;
    }
    for(var n = min + 1; n <= max; n++) {
        var isPrime = true;
        var limit = Math.sqrt(n);
        
        for(var i = 0; i < primes.length; i++) {
            var p = primes[i];
            if(p > limit) {
                break;
            }
            if(n % p === 0) {
                isPrime = false;
                break;
            }
        }
        if(isPrime) {
            primes.push(n);
        }
    }
}
function count_primes_until(m) {
    for(var i = 0; i < primes.length; i++) {
        if(primes[i] > m) {
            return i;
        }
    }
    return primes.length;
}
var input = fs.readFileSync('/dev/stdin').toString();
var lines = input.split();
for(var i = 0; i < lines.length; i++) {
    var n = parseInt(lines[i]);
    if(!isNaN(n)) {
        scan_primes(n + 1);
        
        
        console.log(count_primes_until(n));
    }
}"
JavaScript,"/*
	?§£????????????:Area of Polygon
	(http:
	-status:null(????????????????????±??????????????????...)
	-comment:
        ????????????????????????
*/
var log = console.log;
if (typeof process != ) {
    var input = ;
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', function(chunk) {
        input += chunk;
    });
    process.stdin.on('end', function() {
        var lines = input.split();
        main(lines);
    });
}
function main(lines) {
    lines = lines.map(function(line) {
        return line.split().filter(function(e) {
            return e != ;
        }).map(function(e) {
            var n = Number(e);
            if (n.toString() == ) {
                return e.replace(/(\\r)|(\\n)/g, );
            }
            return n;
        });
    });
    var last = lines.pop();
    if (last.length == 8) {
        lines.push(last);
    }
    
    
    
    while (lines.length > 0) {
        var dataset = lines.shift();
        p_set(dataset);
    }
}
function p_set(ps) {
    var va = [ps[0] - ps[6], ps[1] - ps[7]];
    var vb = [ps[2] - ps[6], ps[3] - ps[7]];
    var vc = [ps[4] - ps[6], ps[5] - ps[7]];
    var s1 = sign_s_main(va, vb) > 0 ? 1 : -1;
    var s2 = sign_s_main(vb, vc) > 0 ? 1 : -1;
    var s3 = sign_s_main(vc, va) > 0 ? 1 : -1;
    if (
        s1 == s2 &&
        s2 == s3 &&
        s3 == s1
    ) {
        log();
    } else {
        log();
    }
}
function sign_s_main(pa, pb) {
    
    return (pa[0] * pb[1] - pa[1] * pb[0]);
}"
JavaScript,"var f = [];
function main(){
  for(var y=-2;y<12;y++){
    f[y] = [];
    for(var x=-2;x<12;x++){
      f[y][x] = 0;
    }
  }
  
  for(var i=0,len=input.length - 1;i<len;i++){
    var s = input[i].split(',');
    eval(+s[2]++s[0]++s[1]+);
  }
  var nd=0;
  var md=0;
  for(var y=0;y<10;y++){
    for(var x=0;x<10;x++){
      if(f[y][x] == 0)
        nd++;
      if(f[y][x] > md)
        md = f[y][x];
    }
  }
  console.log(nd);
  console.log(md);
}
function d1(x, y){
  f[y+1][x]++;
  f[y][x-1]++;
  f[y][x]++;
  f[y][x+1]++;
  f[y-1][x]++;
}
function d2(x, y){
  d1(x, y);
  f[y+1][x-1]++;
  f[y+1][x+1]++;
  f[y-1][x-1]++;
  f[y-1][x+1]++;
}
function d3(x, y){
  d2(x, y);
  f[y+2][x]++;
  f[y-2][x]++;
  f[y][x-2]++;
  f[y][x+2]++;
}
var
input = '';
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"function main() {
  input.forEach(function(str) {
    var
    num = str.split(' ').map(parseFloat);
    if(num.length !== 4 || str.indexOf('0 0 0 0') === 0) return;
    console.log(expr(num));
  });
}
var
op = ['+','-','*']
ex = ['(@%@)%(@%@)','@%(@%@)%@','@%@%@%@', '(@%(@%@))%@'];
function format(txt,a,b){
 var
 i,j = i = 0;
 return txt.replace(/@/g,function(){
  return a[i++];
 }).replace(/%/g,function(){
  return b[j++];
 });
}
function perm(xs) {
 var
 x, i, len = xs.length,
 ret = [];
 if(len === 0) return [[]];
 for(i = 0; i < len; i++){
  x = xs.shift();
  ret = ret.concat(perm(xs).map(function(ys){
   return (ys.unshift(x), ys);
  }));
  xs.push(x);
 }
 return ret;
}
function expr(src){
 var
 i,j,k,m,n,r;
 src = perm(src); 
 for(i = 0; i < 24; i++)for(j = 0; j < 3; j++)for(k = 0; k < 3; k++)for(m = 0; m < 3; m++)for(n = 0; n < 4; n++){
  r = format(ex[n],src[i],[op[j],op[k],op[m]]);
      if(eval(r) === 10) return r;
 }
 return 0;
}
var
input = '';
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"'use strict';
var NS = {};
function addProps(ns) {
    var isBrowser = function() {
        return typeof window !== 'undefined';
    }
    ns.isBrowser = isBrowser;
    
    var isNodejs = function() {
        return ! isBrowser();
    }
    ns.isNodejs = isNodejs;
    
    if (isBrowser()) {
        var getHtmlEncoded = function(string0) {
            return String(string0)
                    .replace(/&/g, '&amp;')
                    .replace(/""/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
        }
        ns.getHtmlEncoded = getHtmlEncoded;
        
        var outputCode = function() {
            document.getElementById('code').innerHTML = '<pre><code>' + getHtmlEncoded(addProps) + '</code></pre>';
        }
        ns.outputCode = outputCode;
    }
    
    var getInput = function() {
        var inputLines = [];
        if (isBrowser()) {
            var html = document.getElementById('input').innerHTML;
            inputLines = html.split('<br>');
        }
        if (isNodejs()) {
            inputLines = require().readFileSync(, ).trim().split('\\n');
        }
        return inputLines;
    }
    
    var doOutput = function(outputLines) {
        if (isBrowser()) {
            document.getElementById('output').innerHTML = outputLines.map(getHtmlEncoded).join('<br>\\n');
        }
        if (isNodejs()) {
            for (var i = 0; i < outputLines.length; i++) {
                console.log(outputLines[i]);
            }
        }
    }
    ns.doOutput = doOutput;
    
    var getProduct = function(a, b) {
        return a * b;
    }
    
    var main = function() {
        var strings = [];
        for (var a = 1; a <= 9; a++) {
            for (var b = 1; b <= 9; b++) {
                var s = a + 'x' + b + '=' + getProduct(a, b);
                strings.push(s);
            }
        }
        doOutput(strings);
    }
    ns.main = main;
}
addProps(NS);
if (NS.isBrowser()) {
    window.onload = function() {
        NS.outputCode();
    }
}
NS.main();"
JavaScript,"var print = console.log; 
var input_lines; 
function PreMain(input) {
    input_lines = input.split();
    var f = function () {
        return input_lines.shift();
    };
    Main(f);
}
function IL(min1Flg) {
    var s = input_lines.shift().split(' ');
    var offset = min1Flg ? -1 : 0;
    var res = [];
    for (var i = 0; i < s.length; i++) {
        res.push(parseInt(s[i]));
    }
    return res;
}
/**
 * @return {number}
 */
Array.prototype.SUM = function SUM() {
    var sum = 0;
    this.forEach(function (elm) {
        sum += elm;
    });
    return sum;
};
/**
 * @return {string}
 */
Array.prototype.Format = function Format(split) {
    if (split === undefined) {
        split = ;
    }
    return this.join(split);
};
Array.prototype.Copy = function Copy() {
    return [].concat(this);
};
/***
 * ??????Sort
 * <Array>.sort?????¨???(?????????)???????????????????????¨????????¨???
 * ??°????????????????????§?????°????????????????????????????????´??????????????????????????¨?????????
 * @constructor
 */
Array.prototype.Sort = function Sort() {
    this.sort(function (a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    });
};
/*
(((???????????)??? ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
*/
function range(i, n) {
    var res = [];
    for (; i < n; i++) {
        res.push(i);
    }
    return res;
}
function get_pattern() {
    var pat = {};
    range(1, 26).forEach(function (a) {
        if (a % 2 === 0 || a % 13 === 0) {
            return;
        }
        var acode = 'a'.charCodeAt(0);
        for (var b = 0; b < 26; b++) {
            var converted_alphabet = '';
            for (var c = 0; c < 26; c++) {
                converted_alphabet += String.fromCharCode(((a * c + b) % 26) + acode);
            }
            var tmp = '';
            var tmp2 = '';
            for (var i = 0; i < 4; i++) {
                var x = 'this'.charCodeAt(i) - acode;
                tmp += converted_alphabet.charAt(x);
                var y = 'that'.charCodeAt(i) - acode;
                tmp2 += converted_alphabet.charAt(y);
            }
            pat[tmp] = converted_alphabet;
            pat[tmp2] = converted_alphabet;
        }
    });
    return pat;
}
function get_foo(str, str2) {
    var acode = 'a'.charCodeAt(0);
    var res = '';
    for (var i = 0; i < str.length; i++) {
        if (str.charAt(i) === ' ') {
            res += ' ';
        } else {
            res += String.fromCharCode(str2.indexOf(str.charAt(i)) + acode);
        }
    }
    return res;
}
function Main(input) {
    var n = parseInt(input());
    var p = get_pattern();
    var str2;
    for (var j = 0; j < n; j++) {
        var str_org = input();
        var str = str_org.split(' ');
        for (var i = 0; i < str.length; i++) {
            if (p.hasOwnProperty(str[i])) {
                str2 = p[str[i]];
                break;
            }
        }
        print(get_foo(str_org,str2));
    }
}
 PreMain(require().readFileSync(, ));"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
  
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
      
    var treasures = +input[read++];
    var pdp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
  
      var dp = new Int16Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = (w-tw < 0) ? pdpw : max(pdp[w-tw] + tv, pdpw);
      }
      pdp = dp;
    }
  
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
      
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var input = '';
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
    input += chunk;
});
process.stdin.on('end', function() {
    main(input)
});
function main(arg){
    var mountains = arg.split('\\n');
    mountains = mountains.map(function(x){ return parseInt(x); })
    var topMountains = [];
    iterateTopMountains(function init(i){
        topMountains[i] = 0;
    })
    for(var i = 0; i < mountains.length; i += 1){
        var mountain = mountains[i];
        iterateTopMountains(function displace(rank){
            if(mountain > topMountains[rank]){
                topMountains.splice(rank, 0, mountain);
                return true;
            }
        })
    }
    iterateTopMountains(function show(i){
        console.log(topMountains[i]);
    })
}
function iterateTopMountains(func){
    var numTopMountains = 3;
    for(var i = 0; i < numTopMountains; i += 1){
        var needBreak = func(i);
        if(needBreak){ break; }
    }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  
  var multiply = new Int8Array([1,3,5,7,9,11,15,17,19,21,23,25]);
  
  FIRST:for(var i = 1, len = +input[0]; i <= len; i++){
    var inp = input[i];
    for(var j = 0, lenj = multiply.length; j < lenj; j++){
      var alpha = multiply[j];
      for(var beta = 26; beta--;){
        var alphabets = new Int8Array(26);
        for(var conv = 26; conv--;){
          alphabets[conv] = (conv * alpha + beta) % 26 + 97;
        }
        var thChar = String.fromCharCode(alphabets[19], alphabets[7]);
        var atChar = String.fromCharCode(alphabets[0], alphabets[19]);
        var isChar = String.fromCharCode(alphabets[8], alphabets[18]);
        if(new RegExp(thChar + +atChar++isChar+).test(inp)){
          console.log(inp.replace(/[a-z]/g,function(a){for(var b = 26, c=a.charCodeAt(0); b--;)if(c==alphabets[b]){return String.fromCharCode(b+97)}}));
          continue FIRST;
        }
      }
    }
  }
}
     "
JavaScript,"var f = [];
 
function main(){
  var localInput = input;
  
  for(var y=-2;y<12;y++){
    f[y] = [];
    for(var x=-2;x<12;x++){
      f[y][x] = 0;
    }
  }
 
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    eval(+localInput[len][4]++localInput[len][0]++localInput[len][2]+);
  }
 
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y][x]);
      md = mx(f[y][x], md);
    }
  }
 
  console.log(nd);
  console.log(md);
}
 
function d1(x, y){
  f[y+1][x]++;
  f[y][x-1]++;
  f[y][x]++;
  f[y][x+1]++;
  f[y-1][x]++;
}
 
function d2(x, y){
  d1(x, y);
  f[y+1][x-1]++;
  f[y+1][x+1]++;
  f[y-1][x-1]++;
  f[y-1][x+1]++;
}
 
function d3(x, y){
  d2(x, y);
  f[y+2][x]++;
  f[y-2][x]++;
  f[y][x-2]++;
  f[y][x+2]++;
}
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
 
var
input = '';
 
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"function main() {
  input.forEach(function(str) {
    var
    num = str.split(' ').map(parseFloat);
    if(num.length !== 4 || str.indexOf('0 0 0 0') === 0) return;
    console.log(expr(num));
  });
}
var
op = ['+','-','*']
ex = ['(@%@)%(@%@)','@%(@%@)%@','@%@%@%@', '(@%(@%@))%@'];
function format(txt,a,b){
 var
 i,j = i = 0;
 return txt.replace(/@/g,function(){
  return a[i++];
 }).replace(/%/g,function(){
  return b[j++];
 });
}
function perm(xs) {
 var
 x, i, len = xs.length,
 ret = [];
 if(len === 0) return [[]];
 for(i = 0; i < len; i++){
  x = xs.shift();
  ret = ret.concat(perm(xs).map(function(ys){
   return (ys.unshift(x), ys);
  }));
  xs.push(x);
 }
 return ret;
}
function expr(src){
 var
 i,j,k,m,n,r;
 src = perm(src); 
 for(i = 0; i < 24; i++)for(j = 0; j < 3; j++)for(k = 0; k < 3; k++)for(m = 0; m < 3; m++)for(n = 0; n < 3; n++){
  r = format(ex[n],src[i],[op[j],op[k],op[m]]);
      if(eval(r) === 10) return r;
 }
 return 0;
}
var
input = '';
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  
  for(var i = 0, len = input.length; i < len; i++){
    var c = input[i].split(',');
    
    console.log(
         !isInner(c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7])
      && !isInner(c[2],c[3],c[4],c[5],c[6],c[7],c[0],c[1])  
      && !isInner(c[4],c[5],c[6],c[7],c[0],c[1],c[2],c[3])
      && !isInner(c[6],c[7],c[0],c[1],c[2],c[3],c[4],c[5]) ?
            'YES':'NO');
  }
  
}
function isInner(x1,y1,x2,y2,x3,y3,x4,y4){
    var v1 = new Vector2D(x1, y1);
    var v2 = new Vector2D(x2, y2);
    var v3 = new Vector2D(x3, y3);
    var vp = new Vector2D(x4, y4);
 
    var v12 = v2.sub(v1);
    var v2p = vp.sub(v2);
     
    var v23 = v3.sub(v2);
    var v3p = vp.sub(v3);
 
    var v31 = v1.sub(v3);
    var v1p = vp.sub(v1);
 
    var c1 = v12.cross(v2p);
    var c2 = v23.cross(v3p);
    var c3 = v31.cross(v1p);
 
    return (c1 >= 0 && c2 >= 0 && c3 >= 0) || (c1 < 0 && c2 < 0 && c3 < 0);
}
function Vector2D(x, y){
  this.x = x - 0, this.y = y - 0;
  this.sub = function(v){
    return new Vector2D(this.x - v.x, this.y - v.y);
  };
  this.cross = function(v){
    return this.x * v.y - this.y * v.x;
  };
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
function main(){
  var x=y=0;
  var d='R';
  var route='';
  while(true){
    var dy = y*2+1;
    var uy = y*2-1;
    var ny = y*2;
    var lx = x-1;
    var rx = x+1;
    var nx = x;
    switch(d){
    case 'L':
      if(dy < input.length && +input[dy][nx]){
        d='D';y++;
      }else if(+input[ny][lx]){
        d='L';x--;
      }else if(uy > 0 && +input[uy][nx]){
        d='U';y--;
      }else{
        d='R';x++;
      }
      break;
    case 'R':
      if(uy > 0 && +input[uy][nx]){
        d='U';y--;
      }else if(+input[ny][nx]){
        d='R';x++;
      }else if(dy < input.length && +input[dy][nx]){
        d='D';y++;
      }else{
        d='L';x--;
      }
      break;
    case 'D':
      if(+input[ny][nx]){
        d='R';x++;
      }else if(dy < input.length && +input[dy][nx]){
        d='D';y++;
      }else if(+input[ny][lx]){
        d='L';x--;
      }else{
        d='U';y--;
      }
      break;
    case 'U':
      if(+input[ny][lx]){
        d='L';x--;
      }else if(uy > 0 && +input[uy][nx]){
        d='U';y--;
      }else if(+input[ny][nx]){
        d='R';x++;
      }else{
        d='D';y++;
      }
      break;
    default:
      return;
    }
    route+=d;
    if(!x && !y)
      break;
  }
  console.log(route);
}"
JavaScript,"var input = require('fs').readFileSync('/dev/stdin').toString();
var inputArray = input.split();
 
var words = {};			
var mostAppearedValue = 0;	
var mostAppearedIndex = 0;	
var longestValue = 0;		
var longestIndex = 0;		
 
for (var i = 0; i < inputArray.length; i++) {
	
	if (words[inputArray[i]]) {
		
		words[inputArray[i]]++;
	}
	
	else {
	
	words[inputArray[i]] = 1;
 
		
		if (inputArray[i].length > longestValue) {
			longestValue = inputArray[i].length;
			longestIndex = i;
		}
	}
 
	
	if (words[inputArray[i]] > mostAppearedValue) {
		mostAppearedValue = words[inputArray[i]];
		mostAppearedIndex = i;
	}
}
 
console.log(inputArray[mostAppearedIndex] +  + inputArray[longestIndex]);"
JavaScript,"function main(){
  for(var y=0;y<14;y++){
    for(var x=0;x<14;x++){
      eval(+ x +  + y + );
    }
  }
  
  for(var i=0,len=input.length - 1;i<len;i++){
    eval(+input[i][4]++(input[i][0]-0+2)++(input[i][2]-0+2)+);
  }
  var nd=0;
  var md=0;
  for(var y=2;y<12;y++){
    for(var x=2;x<12;x++){
      if(eval(+ x +  + y) == 0)
        nd++;
      if(eval(+ x +  + y) > md)
        md = eval(+ x +  + y);
    }
  }
  console.log(nd);
  console.log(md);
}
function d1(x, y){
  eval(+ x +  + y + );
  eval(+ (x-0+1) +  + y + );
  eval(+ (x-1) +  + y + );
  eval(+ x +  + (y-0+1) + );
  eval(+ x +  + (y-1) + );
}
function d2(x, y){
  d1(x, y);
  eval(+ (x-0+1) +  + (y-0+1) + );
  eval(+ (x-0+1) +  + (y-1) + );
  eval(+ (x-1) +  + (y-0+1) + );
  eval(+ (x-1) +  + (y-1) + );
}
function d3(x, y){
  d2(x, y);
  eval(+ x +  + (y-0+2) + );
  eval(+ x +  + (y-2) + );
  eval(+ (x-0+2) +  + y + );
  eval(+ (x-2) +  + y + );
}
var
input = '';
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"'use strict';
var len = 10;
var map = new Array(len);
for (var i = 0; i < map.length; ++i) {
	map[i] = new Array(len);
	for (var j = 0; j < map.length; ++j) {
		map[i][j] = 0;
	}
}
var input = require('fs').readFileSync('/dev/stdin', 'utf8');
var inks = input.trim().split('\\n');
for (var i in inks) {
	var ink = inks[i].trim().split(',');
	ink[0] = parseInt(ink[0]);
	ink[1] = parseInt(ink[1]);
	++map[ink[0]][ink[1]];
	switch (ink[2]) {
		case '3':
			if (ink[0] - 2 >= 0) {
				++map[ink[0] - 2][ink[1]];
			}
			if (ink[0] + 2 < len) {
				++map[ink[0] + 2][ink[1]];
			}
			if (ink[1] - 2 >= 0) {
				++map[ink[0]][ink[1] - 2];
			}
			if (ink[1] + 2 < len) {
				++map[ink[0]][ink[1] + 2];
			}
		case '2':
			if (ink[0] - 1 >= 0 && ink[1] - 1 >= 0) {
				++map[ink[0] - 1][ink[1] - 1];
			}
			if (ink[0] - 1 >= 0 && ink[1] + 1 < len) {
				++map[ink[0] - 1][ink[1] + 1];
			}
			if (ink[0] + 1 < len && ink[1] - 1 >= 0) {
				++map[ink[0] + 1][ink[1] - 1];
			}
			if (ink[0] + 1 < len && ink[1] + 1 < len) {
				++map[ink[0] + 1][ink[1] + 1];
			}
		case '1':
			if (ink[0] - 1 >= 0) {
				++map[ink[0] - 1][ink[1]];
			}
			if (ink[0] + 1 < len) {
				++map[ink[0] + 1][ink[1]];
			}
			if (ink[1] - 1 >= 0) {
				++map[ink[0]][ink[1] - 1];
			}
			if (ink[1] + 1 < len) {
				++map[ink[0]][ink[1] + 1];
			}
			break;
	}
}
var zeroden = 0;
var maxden = 0;
for (var row in map) {
	for (var col in map[row]) {
		if (map[row][col] === 0) {
			++zeroden;
		} else if (map[row][col] > maxden) {
			maxden = map[row][col];
		}
	}
}
console.log(zeroden);
console.log(maxden);"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
  
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
      
    var treasures = +input[read++];
    var dp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
  
      for(var w = maxWeight; w - tw >= 0; w--){
        dp[w] = max(dp[w-tw] + tv, dp[w]);
      }
    }
  
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var dpi = dp[i];
      if(dpi > resultCost){
        resultCost = dpi;
        resultWeight = i;
      }
    }
      
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
function main(){
  for(var i = 0, len = input.length; i < len; i++){
    var c = input[i].trim().split(',').sort(function(a,b){return b-a;}).map(Number);
    var result = ;
    if((c[0] == c[1] && c[1] == c[2] && c[2] == c[3]) ||
       (c[1] == c[2] && c[2] == c[3] && c[3] == c[4])
       ){
      result = ;
    }else if(c[0] == c[1] && c[1] == c[2] && c[3] == c[4]
             || c[0] == c[1] && c[2] == c[3] && c[3] == c[4]){
      result = ;
    }else if(c[0] == c[1] + 1 && c[1] == c[2] + 1 && c[2] == c[3] + 1
             && ((c[0] == 13 && c[4] == 1) || (c[3] == c[4] + 1))){
      result = ;
    }else if((c[0] == c[1] && c[1] == c[2])
             || (c[1] == c[2] && c[2] == c[3])
             || (c[2] == c[3] && c[3] == c[4])
             ){
      result = ;
    }else if((c[0] == c[1] && (c[2] == c[3] || c[3] == c[4])) || (c[1] == c[2] && c[3] == c[4])){
      result = ;
    }else if(c[0] == c[1] || c[1] == c[2] || c[2] == c[3] || c[3] == c[4]){
      result = ;
    }
    console.log(result);
  }
}"
JavaScript,"(function underscore(undefined) {
	'use strict';
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	var push = ArrayProto.push,
	slice = ArrayProto.slice,
	concat = ArrayProto.concat,
	toString = ObjProto.toString,
	hasOwnProperty = ObjProto.hasOwnProperty;
	var nativeForEach = ArrayProto.forEach,
	nativeMap = ArrayProto.map,
	nativeReduce = ArrayProto.reduce,
	nativeReduceRight = ArrayProto.reduceRight,
	nativeFilter = ArrayProto.filter,
	nativeEvery = ArrayProto.every,
	nativeSome = ArrayProto.some,
	nativeIndexOf = ArrayProto.indexOf,
	nativeLastIndexOf = ArrayProto.lastIndexOf,
	nativeIsArray = Array.isArray,
	nativeKeys = Object.keys,
	nativeBind = FuncProto.bind;
	this._ = {};
	var each = _.each = _.forEach = function(obj, iterator, context) {
		if (obj == null) return;
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, l = obj.length; i < l; i++) {
				if (iterator.call(context, obj[i], i, obj) === breaker) return;
			}
		} else {
			for (var key in obj) {
				if (_.has(obj, key)) {
					if (iterator.call(context, obj[key], key, obj) === breaker) return;
				}
			}
		}
	};
	_.extend = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			}
		});
		return obj;
	};
}).call(global);
(function(undefined){
	'use strict';
	var INPUT_TYPE = 'number';
	var Solver = {
		fire: function() {
			setTimeout( Solver.solve, 0, this );
		},
		solve: function solve() {
			var n = input_number();
			var res = 0;
			for ( var a = 0; a <= 9; ++ a ) {
				for ( var b = 0; b <= 9; ++ b ) {
					for ( var c = 0; c <= 9; ++ c ) {
						for ( var d = 0; d <= 9; ++ d ) {
							if ( a + b + c + d === n )
								res ++;
						}
					}
				}
			}
			output(res);
			if ( ! has_next() )
				setTimeout( Solver.solve, 0, this );
		}
	};
	(function init() {
		_.extend( this, {
			output: function() {
				console.log.apply( console, arguments );
			},
			stdin: process.openStdin(),
			input_list: [],
			input_number: function() {
				return parseInt( input_list.splice(0,1)[0] );
			},
			input_text: function() {
				return input_list.splice(0,1)[0];
			},
			has_next: function() {
				return ! input_list.length;
			}
		} );
		var INPUT_REGEXP_LIST = {};
		INPUT_REGEXP_LIST['string'] = /\\w*/g;
		INPUT_REGEXP_LIST['number'] = /[-]?\\d+/g;
		var INPUT_REGEXP = INPUT_REGEXP_LIST[INPUT_TYPE];
		stdin.setEncoding('utf8');
		stdin.on('data', function(chunk){
			var result = chunk.match(INPUT_REGEXP);
			input_list = input_list.concat(result.filter(function(line){
				return line.length;
			}));
		});
		stdin.on('end', function(){
			Solver.fire.call(this);
		});
	}).call( this );
}).call(global);"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
  
function main(){
  var i = 1;
  for(var len = input[0] - 0;len--;){
    var x = input[i++].split('').reverse().join('').trim();
    var y = input[i++].split('').reverse().join('').trim();
    var loop = x.length > y.length ? x.length : y.length;
    var results = new Int8Array(loop + 1);
    for(var j = 0; j < loop; j++){
      var xj = x.length > j ? x[j] - 0 : 0;
      var yj = y.length > j ? y[j] - 0 : 0;
      var rj = results[j] - 0;
      var sum = xj + yj + rj;
      if(sum >= 10){
        sum -= 10;
        results[j + 1]++;
      }
      results[j] = sum;
    }
    var result = ;
    for(loop++;loop--;){
      result += results[loop];
    }
    result=result.replace(/^0/g, );
    console.log(result.length > 80 ? 'overflow' : result);
  }
}"
JavaScript,"(function underscore(undefined) {
	'use strict';
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	var push = ArrayProto.push,
	slice = ArrayProto.slice,
	concat = ArrayProto.concat,
	toString = ObjProto.toString,
	hasOwnProperty = ObjProto.hasOwnProperty;
	var nativeForEach = ArrayProto.forEach,
	nativeMap = ArrayProto.map,
	nativeReduce = ArrayProto.reduce,
	nativeReduceRight = ArrayProto.reduceRight,
	nativeFilter = ArrayProto.filter,
	nativeEvery = ArrayProto.every,
	nativeSome = ArrayProto.some,
	nativeIndexOf = ArrayProto.indexOf,
	nativeLastIndexOf = ArrayProto.lastIndexOf,
	nativeIsArray = Array.isArray,
	nativeKeys = Object.keys,
	nativeBind = FuncProto.bind;
	this._ = {};
	var each = _.each = _.forEach = function(obj, iterator, context) {
		if (obj == null) return;
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, l = obj.length; i < l; i++) {
				if (iterator.call(context, obj[i], i, obj) === breaker) return;
			}
		} else {
			for (var key in obj) {
				if (_.has(obj, key)) {
					if (iterator.call(context, obj[key], key, obj) === breaker) return;
				}
			}
		}
	};
	_.extend = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			}
		});
		return obj;
	};
}).call(global);
(function(undefined){
	'use strict';
	var INPUT_TYPE = 'number';
	var SIZE = 1000001;
	var Solver = {
		primes: [],
		fire: function() {
			setTimeout( Solver.solve, 0, this );
		},
		pre_calc: function() {
			var primes = Solver.primes;
			for ( var i = 0; i < SIZE; ++ i )
				primes[i] = false;
			primes[2] = true;
			for ( var i = 3; i < SIZE; i += 2 )
				primes[i] = true;
			for ( var i = 3; i < SIZE; i += 2 ) {
				if ( ! primes[i] )
					continue;
				for ( var j = i + i; j < SIZE; j += i )
					primes[j] = false;
			}
		},
		solve: function solve() {
			var primes = Solver.primes;
			var n = input_number();
			output( primes.slice(0,n+1).filter(function(element){
				return element;
			}).length );
			if ( ! has_next() )
				setTimeout( Solver.solve, 0, this );
		}
	};
	if ( Solver.pre_calc instanceof Function )
		Solver.pre_calc.call(this);
	(function init() {
		_.extend( this, {
			output: function() {
				console.log.apply( console, arguments );
			},
			stdin: process.openStdin(),
			input_list: [],
			input_number: function() {
				return parseInt( input_list.splice(0,1)[0] );
			},
			input_text: function() {
				return input_list.splice(0,1)[0];
			},
			has_next: function() {
				return ! input_list.length;
			}
		} );
		var INPUT_REGEXP_LIST = {};
		INPUT_REGEXP_LIST['string'] = /\\w*/g;
		INPUT_REGEXP_LIST['number'] = /[-]?\\d+/g;
		var INPUT_REGEXP = INPUT_REGEXP_LIST[INPUT_TYPE];
		stdin.setEncoding('utf8');
		stdin.on('data', function(chunk){
			var result = chunk.match(INPUT_REGEXP);
			input_list = input_list.concat(result.filter(function(line){
				return line.length;
			}));
		});
		stdin.on('end', function(){
			Solver.fire.call(this);
		});
	}).call( this );
}).call(global);"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        if(w - tw < 0){
          dp[w] = pdp[w];
        }else{
          dp[w] = max(pdp[w-tw] + tv, pdp[w]);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      if(pdp[i] > resultCost){
        resultCost = pdp[i];
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var primeNxt = new Array(1000000);
function primeGenerator()
{
    var p, fact, m;
    var maxN = 9999999;
    var primePrv = new Array(1000000);
    
    for(p=2;p<=maxN;++p){
        primeNxt[p] = p + 1;
        primePrv[p] = p - 1;
    }
    primePrv[2] = 0;
    primeNxt[maxN] = 0;
    
    
    for(p=2;p*p<=maxN;p=primeNxt[p]){
        for(fact=p;p*fact<=maxN;fact=primeNxt[fact]){
            for(m=p*fact;m<=maxN;m*=p){
                primeNxt[primePrv[m]] = primeNxt[m];
                primePrv[primeNxt[m]] = primePrv[m];
            }
        }
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
 
process.stdin.on('data', function(input){
    primeGenerator();
    input.trim().split('\\n').forEach(function(val){
        var N = parseInt(val);
        if( N === 1 ){
            console.log(0);
        }
        else if(N===2){
            console.log(1);
        }
        else{
            var i, cnt;
            cnt = 0;
            for(i=2;i<=N;i=primeNxt[i]){
                ++cnt;
            }
            console.log(cnt);
        }
    });
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int16Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = (w-tw < 0) ? pdpw : max(pdp[w-tw] + tv, pdpw);
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"process.stdin.resume();
process.stdin.setEncoding('utf8');
const figureNames = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
const figureIndices = [
    [[1,0], [0, 1], [1, 1]],
    [[0, 1], [0, 2], [0, 3]],
    [[1, 0], [2, 0], [3, 0]],
    [[-1, 1], [0, 1], [-1, 2]],
    [[1, 0], [1, 1], [2, 1]],
    [[0, 1], [1, 1], [1, 2]],
    [[1,0], [-1, 1], [0, 1]]
]
function distinguishFigure(plane){
    const rows = plane.split('\\n')
    
    for(let i = 0, l = rows.length; i < l; i++){
        
        for(let j = 0, m = rows[i].length; j < m; j++){
            
            
            if(rows[i][j] === '1'){
                
              for(let k = 0, n = figureIndices.length; k < n; k++){
                   
                  let figureIndex = figureIndices[k]
                   
                  let isFound = true
                   
                  for(let index of figureIndex){
                       
                        let right = index[0]
                        let down = index[1]
                        
                        if(
                            !( (j + right) < m && (j + right) >= 0 && (i + down) < l ) || 
                            rows[i+down][j+right] === '0'
                        ){
                            isFound = false
                            break
                        }
                        
                       
                  }
                   
                  if(isFound)
                        return figureNames[k]
                   
              }
                
            }
            
        }
        
    }
}
const fs = require('fs')
const length = fs.fstatSync(process.stdin.fd).size
const buffer = Buffer.alloc(length)
const bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0)
const input = buffer.toString('utf8', 0, bytesRead)
let result = ''
for(let plane of input.split('\\n\\n')){
    
    result += `${distinguishFigure(plane)}\\n`
}
console.log(result.slice(0, -1))"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
          dp[w] = pdp[w];
        if(w - tw >= 0){
          dp[w] = max(pdp[w-tw] + tv, pdp[w]);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var perm=[];
var flag=[];
for(var i=0;i<4;i++)flag[i]=false;
var cnt=0;
for(var i=0;i<4;i++){flag[i]=true;
for(var ii=0;ii<4;ii++){if(flag[ii])continue;flag[ii]=true;
for(var iii=0;iii<4;iii++){if(flag[iii])continue;flag[iii]=true;
for(var iiii=0;iiii<4;iiii++){if(flag[iiii])continue;
perm[cnt]=[i,ii,iii,iiii];
cnt++;
}flag[iii]=false;
}flag[ii]=false;
}flag[i]=false;
}
var input = require('fs').readFileSync('/dev/stdin', 'utf8');
var Arr=(input.trim()).split();
while(true){
var abcd=Arr.shift();
if(abcd==)break;
var ary=abcd.split().map(Number);
var ans=0;
var s=[,,];
for(var i=0;i<3;i++){
for(var j=0;j<3;j++){
for(var k=0;k<3;k++){
perm.forEach(function(v){
var a=ary[v[0]];
var b=ary[v[1]];
var c=ary[v[2]];
var d=ary[v[3]];
if(ans==0 && eval(a+s[i]+b+s[j]+c+s[k]+d)==10)ans=a+s[i]+b+s[j]+c+s[k]+d;
if(ans==0 && eval(+a+s[i]+b+s[j]+c++s[k]+d)==10)ans=+a+s[i]+b+s[j]+c++s[k]+d;
if(ans==0 && eval(+a+s[i]+b++s[j]++c+s[k]+d+)==10)ans=+a+s[i]+b++s[j]++c+s[k]+d+;
if(ans==0 && eval(++a+s[i]+b++s[j]+c++s[k]+d)==10)ans=++a+s[i]+b++s[j]+c++s[k]+d;
});
}
}
}
if(ans!=0)ans=+ans+;
console.log(ans);
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
    
function main(){
  var intInput = new Int32Array(input);
  var primeNumbers = calcPrimeNumbers();
  for(var i = 0, len = input.length - 1; i < len; i++){
    console.log(primeNumbers[intInput[i]]);
  }
   
     
}
   
function calcPrimeNumbers(){
  var max = 999999;
  var primeNumbers = new Int32Array(max + 1);
   
  
  primeNumbers[0] = primeNumbers[1] = 0;
  for(var i = 2, maxI = ~~Math.sqrt(max); i <= maxI; i++){
    if(primeNumbers[i]){
      continue;
    }
       
    for(var j = (i<<1); j <= max; j+=i){
      primeNumbers[j] = 1;
    }
  }
   
   for(var i = 2; i <= max; i++){
     
     primeNumbers[i] = primeNumbers[i-1] - primeNumbers[i] + 1;
  }
     
  return primeNumbers;
}"
JavaScript,"function bigAdd(A, B)
{
    var m, n, mn, i, j, carry, tmp;
    var buf, a1, a2;
    
    if(A.length > B.length){
        m = A.length;
        n = B.length;
        a1 = A.split();
        a2 = B.split();
    }
    else{
        m = B.length;
        n = A.length;
        a1 = B.split();
        a2 = A.split();
    }
    
    if( m > 80 ){
        console.log();
        return;
    }
    
    mn = m + 1;
    buf = new Array(mn);
    for(j=m-1,i=n-1,carry=0;i>=0;--i,--j){
        tmp = parseInt(a1[j]) + parseInt(a2[i]) + carry;
        buf[j+1] = tmp % 10;
        carry = parseInt(tmp / 10);
    }
    
    for(;j>=0;--j){
        tmp = parseInt(a1[j]) + carry;
        buf[j+1] = tmp % 10;
        carry = parseInt(tmp / 10);
    }
    buf[0] = carry;
    
    if( carry > 0 ){
        if( m == 80 ){
            console.log();
        }
        else{
            console.log(buf.join());
        }
    }
    else{
        console.log(buf.slice(1,mn).join());
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(input){
    var line = input.trim().split();
    var i = 0;
    var N = parseInt(line[i++].trim());
    {
        for(;N>0;--N){
            bigAdd(line[i], line[i+1]);
            i=i+2;
        }
    }
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
    
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w < tw; w++){
        dp[w] = pdp[w];
      }
      
      for(var w = tw; w <= maxWeight; w++){
        dp[w] = max(pdp[w-tw] + tv, pdp[w]);
      }
      pdp = dp;
    }
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      if(pdp[i] > resultCost){
        resultCost = pdp[i];
        resultWeight = i;
      }
    }
    
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int16Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = (w-tw < 0) ? pdpw : tmax(pdp[w-tw] + tv, pdpw);
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
function tmax(a, b){
  return a>b?a:b;
}
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require('fs'),
    length = fs.fstatSync(process.stdin.fd).size,
    buffer = new Buffer(length),
    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
    input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 return a - ((a-b) & ((a-b) >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = new Int8Array(inp.split(' ').map(Number));
    var found = false;
    var searched = new Int8Array(10000);
 
  FIRST:for(var a = 0; a < 4; a++){
    var inpa = inp[a]; 
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      var inpb = inp[b];
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        var inpc = inp[c];
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
          var inpd = inp[d];
          var target = inpa*1000 + inpb*100 + inpc*10 + inpd;
          if(searched[target])
            continue;
          searched[target]++;
          for(var op1 = 0; op1 < 3; op1++){
            var operandsop1 = operands[op1];
            for(var op2 = 0; op2 < 3; op2++){
              var operandsop2 = operands[op2];
              for(var op3 = 0; op3 < 3; op3++){
                var operandsop3 = operands[op3];
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inpa, inpb, operandsop1, inpc, operandsop2, inpd, operandsop3];
                    break;
                  case 1:
                    
                    polish = [inpa, inpb, inpc, operandsop1, operandsop2, inpd, operandsop3];
                    break;
                  case 2:
                    
                    polish = [inpa, inpb, operandsop1,inpc, inpd, operandsop2, operandsop3];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = inp.split(' ').map(Number);
    var found = false;
 
  FIRST:for(var a = 0; a < 4; a++){
    var inpa = inp[a]; 
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      var inpb = inp[b];
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        var inpc = inp[c];
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
          var inpd = inp[d];
          for(var op1 = 0; op1 < 3; op1++){
            var operandsop1 = operands[op1];
            for(var op2 = 0; op2 < 3; op2++){
              var operandsop2 = operands[op2];
              for(var op3 = 0; op3 < 3; op3++){
                var operandsop3 = operands[op3];
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inpa, inpb, operandsop1, inpc, operandsop2, inpd, operandsop3];
                    break;
                  case 1:
                    
                    polish = [inpa, inpb, inpc, operandsop1, operandsop2, inpd, operandsop3];
                    break;
                  case 2:
                    
                    polish = [inpa, inpb, operandsop1,inpc, inpd, operandsop2, operandsop3];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"var perm=[];
var flag=[];
for(var i=0;i<4;i++)flag[i]=false;
var cnt=0;
for(var i=0;i<4;i++){flag[i]=true;
for(var ii=0;ii<4;ii++){if(flag[ii])continue;flag[ii]=true;
for(var iii=0;iii<4;iii++){if(flag[iii])continue;flag[iii]=true;
for(var iiii=0;iiii<4;iiii++){if(flag[iiii])continue;
perm[cnt]=[i,ii,iii,iiii];
cnt++;
}flag[iii]=false;
}flag[ii]=false;
}flag[i]=false;
}
var input = require('fs').readFileSync('/dev/stdin', 'utf8');
 
var Arr=(input.trim()).split();
while(true){
var abcd=Arr.shift();
if(abcd==)break;
var ary=abcd.split().map(Number);
var ans=0;
var s=[,,];
for(var i=0;i<3;i++){
for(var j=0;j<3;j++){
for(var k=0;k<3;k++){
perm.forEach(function(v){
var a=ary[v[0]];
var b=ary[v[1]];
var c=ary[v[2]];
var d=ary[v[3]];
if(ans==0 && eval(a+s[i]+b+s[j]+c+s[k]+d)==10)ans=a+s[i]+b+s[j]+c+s[k]+d;
if(ans==0 && eval(+a+s[i]+b+s[j]+c++s[k]+d)==10)ans=+a+s[i]+b+s[j]+c++s[k]+d;
if(ans==0 && eval(+a+s[i]+b++s[j]++c+s[k]+d+)==10)ans=+a+s[i]+b++s[j]++c+s[k]+d+;
if(ans==0 && eval(++a+s[i]+b++s[j]+c++s[k]+d)==10)ans=++a+s[i]+b++s[j]+c++s[k]+d;
});
}
}
}
 
console.log(ans);
}"
JavaScript,"var primeNxt = new Array(1000000);
function primeGenerator()
{
    var p, fact, m;
    var maxN = 1002001;
    var primePrv = new Array(1000000);
    
    for(p=2;p<=maxN;++p){
        primeNxt[p] = p + 1;
        primePrv[p] = p - 1;
    }
    primePrv[2] = 0;
    primeNxt[maxN] = 0;
    
    
    for(p=2;p*p<=maxN;p=primeNxt[p]){
        for(fact=p;p*fact<=maxN;fact=primeNxt[fact]){
            for(m=p*fact;m<=maxN;m*=p){
                primeNxt[primePrv[m]] = primeNxt[m];
                primePrv[primeNxt[m]] = primePrv[m];
            }
        }
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
 
process.stdin.on('data', function(input){
    primeGenerator();
    var lines = input.trim().split('\\n');
    var len = lines.length;
    for(var t=0;t<len;++t){
        var N = parseInt(lines[t]);
        var cnt = 1;
        if( N == 1 ){
            console.log(0);
        }
        else if( N == 2 ){
            console.log(1);
        }
        else{
            for(var i=3;i<=N;i=primeNxt[i]){
               ++cnt;
            }
            console.log(cnt);
        }
    }
});"
JavaScript,"var input = require('fs').readFileSync('/dev/stdin', 'utf8');
var lines = input.trim().split('\\n');
var line;
while (line = lines.shift()) {
	var board = [];
	board.push(line.split('').map(function(f){return +f;}));
	for (var i = 0; i < 7; i++) {
		board.push(lines.shift().split('').map(function(f){return +f;}));
	}
	if (lines.length > 0)
		lines.shift();
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			if (board[y][x])
				break;
		}
		if (board[y][x])
			break;
	}
	var fig;
	if (board[y][x+1] & board[(y+1)%8][x] & board[(y+1)%8][x+1]) fig = 'A';
	else if (board[(y+1)%8][x] & board[(y+2)%8][x] & board[(y+3)%8][x]) fig = 'B';
	else if (board[y][x+1] & board[y][x+2] & board[y][x+3]) fig = 'C';
	else if (board[(y+1)%8][x-1] & board[(y+1)%8][x] & board[(y+2)%8][x-1]) fig = 'D';
	else if (board[y][x+1] & board[(y+1)%8][x+1] & board[(y+1)%8][x+2]) fig = 'E';
	else if (board[(y+1)%8][x] & board[(y+1)%8][x+1] & board[(y+2)%8][x+1]) fig = 'F';
	else fig = 'G';
	console.log(fig);
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var primeNumbers = new Int32Array(65535);
  var maxNum = 0;
  
  for(var line = 0, inputLength = input.length; line < inputLength - 1; line++){
    var num = input[line] - 0;
    maxNum = maxNum < num ? num : maxNum;
  }
  
  primeNumbers[0] = 2;
  var pcount = 1;
  for(var i = 3; i <= maxNum; i+=2){
    var isPrime = true;
    for(var j = 3, maxJ = ~~Math.sqrt(i); j <= maxJ; j+=2){
      if(!(i % j)){
        isPrime = false;
        break;
      }
    }
    if(isPrime){
      primeNumbers[pcount] = i;
      pcount++;
    }
  }
  
MLOOP: for(var line = 0, inputLength = input.length; line < inputLength - 1; line++){
    for(var k = 0; k < pcount; k++){
      var prime = primeNumbers[k];
      if(prime > (input[line] - 0)){
        console.log(k);
        continue MLOOP;
      }
    }
  console.log(pcount);
  
  }
  
  
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = pdpw;
        if(w - tw >= 0){
          dp[w] = max(pdp[w-tw] + tv, pdpw);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
    
function main(){
  var primeNumbers = calcPrimeNumbers();
  for(var i = 0, len = input.length; i < len; i++){
    console.log(primeNumbers[parseInt(input[i], 10)]);
  }
}
   
function calcPrimeNumbers(){
  var max = 999999;
  var primeNumbers = new Int32Array(max + 1);
   
  
  
  
  for(var i = 2; i <= 1000; i++){
    if(primeNumbers[i]){
      continue;
    }
       
    for(var j = (i<<1); j <= max; j+=i){
      primeNumbers[j] = 1;
    }
  }
  
  for(var i = 2; i <= max; i++){
    
    primeNumbers[i] = primeNumbers[i-1] + 1 - primeNumbers[i];
  }
     
  return primeNumbers;
}"
JavaScript,"var f = [];
function main(){
  for(var y=-2;y<12;y++){
    f[y] = [];
    for(var x=-2;x<12;x++){
      f[y][x] = 0;
    }
  }
  
  for(var i=0,len=input.length - 1;i<len;i++){
    
    
    eval(+input[i][4]++input[i][0]++input[i][2]+);
  }
  var nd=0;
  var md=0;
  for(var y=0;y<10;y++){
    for(var x=0;x<10;x++){
      if(f[y][x] == 0)
        nd++;
      if(f[y][x] > md)
        md = f[y][x];
    }
  }
  console.log(nd);
  console.log(md);
}
function d1(x, y){
  f[y+1][x]++;
  f[y][x-1]++;
  f[y][x]++;
  f[y][x+1]++;
  f[y-1][x]++;
}
function d2(x, y){
  d1(x, y);
  f[y+1][x-1]++;
  f[y+1][x+1]++;
  f[y-1][x-1]++;
  f[y-1][x+1]++;
}
function d3(x, y){
  d2(x, y);
  f[y+2][x]++;
  f[y-2][x]++;
  f[y][x-2]++;
  f[y][x+2]++;
}
var
input = '';
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"(function() {
	'use strict';
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	var push = ArrayProto.push,
	slice = ArrayProto.slice,
	concat = ArrayProto.concat,
	toString = ObjProto.toString,
	hasOwnProperty = ObjProto.hasOwnProperty;
	var
	nativeForEach = ArrayProto.forEach,
	nativeMap = ArrayProto.map,
	nativeReduce = ArrayProto.reduce,
	nativeReduceRight = ArrayProto.reduceRight,
	nativeFilter = ArrayProto.filter,
	nativeEvery = ArrayProto.every,
	nativeSome = ArrayProto.some,
	nativeIndexOf = ArrayProto.indexOf,
	nativeLastIndexOf = ArrayProto.lastIndexOf,
	nativeIsArray = Array.isArray,
	nativeKeys = Object.keys,
	nativeBind = FuncProto.bind;
	this._ = {};
	var each = _.each = _.forEach = function(obj, iterator, context) {
		if (obj == null) return;
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, l = obj.length; i < l; i++) {
				if (iterator.call(context, obj[i], i, obj) === breaker) return;
			}
		} else {
			for (var key in obj) {
				if (_.has(obj, key)) {
					if (iterator.call(context, obj[key], key, obj) === breaker) return;
				}
			}
		}
	};
	_.extend = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			}
		});
		return obj;
	};
}).call(global);
(function(undefined){
	'use strict';
	var INPUT_TYPE = 'string';
	var INPUT_REGEXP_LIST = {};
	INPUT_REGEXP_LIST['string'] = /\\w*/g;
	INPUT_REGEXP_LIST['number'] = /[-]?\\d+/g;
	var INPUT_REGEXP = INPUT_REGEXP_LIST[INPUT_TYPE];
	(function init() {
		this.output = function() {
			console.log.apply( console, arguments );
		};
		this.stdin = process.openStdin();
		stdin.setEncoding('utf8');
		this.input_list = [];
		stdin.on('data', function(chunk){
			var result = chunk.match(INPUT_REGEXP);
			input_list = input_list.concat(result.filter(function(line){
				return line.length;
			}));
		});
		stdin.on('end', function(){
			fire();
		});
		_.extend( this, {
			input_number: function() {
				return parseInt( input_list.splice(0,1)[0] );
			},
			input_text: function() {
				return input_list.splice(0,1)[0];
			},
			has_next: function() {
				return ! input_list.length;
			}
		} );
	}).call( this );
	(function solver(){
		this.fire = function() {
			setTimeout( solve, 0, this );
		};
		function solve() {
			output( input_text().split('').reverse().join('') );
			if ( ! has_next() )
				setTimeout( solve, 0, this );
		}
	}).call(this);
}).call(global);"
JavaScript,"var Triangle;
(function (Triangle) {
    var RightAngle = (function () {
        function RightAngle(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
        RightAngle.prototype.isRightAngle = function () {
            var values = [this.a, this.b, this.c].sort(function (a, b) {
                return b - a;
            });
            return Math.pow(values[0], 2.0) == (Math.pow(values[1], 2.0) + Math.pow(values[2], 2.0));
        };
        return RightAngle;
    })();
    Triangle.RightAngle = RightAngle;
})(Triangle || (Triangle = {}));
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function (chunk) {
    chunk.trim().split('\\n').forEach(function (line) {
        var items = line.trim().split(' ');
        if (items.length == 3) {
            var r = new Triangle.RightAngle(+items[0], +items[1], +items[2]);
            if (r.isRightAngle()) {
                console.log();
            } else {
                console.log();
            }
        }
    });
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('hex', 0, bytesRead).split('0a'); 
main();
 
function main(){
  
  var multiply = new Int8Array([1,3,5,7,9,11,15,17,19,21,23,25]);
  var alphabets = new Int8Array(26);
  var convertTable = new Int8Array(123);
  for(var init = 123; init--;)
    convertTable[init] = init;
FIRST:for(var i = 1, leni = input.length - 1; i < leni; i++){
    var inp = input[i];
    var c = inp.split('20');
  
    for(var j = 0, lenj = multiply.length; j < lenj; j++){
      var alpha = multiply[j];
      for(var beta = 26; beta--;){
        for(var conv = 26; conv--;){ 
          alphabets[conv] = (conv * alpha + beta) % 26 + 97;
        }
        
        var thatIs = alphabets[19].toString(16) + alphabets[7].toString(16) + alphabets[0].toString(16) + alphabets[19].toString(16);
        var thisIs = alphabets[19].toString(16) + alphabets[7].toString(16) + alphabets[8].toString(16) + alphabets[18].toString(16);
        if(new RegExp( + thatIs +  + thisIs + ).test(inp)){
          for(var conv = 26; conv--;){
            var fromCode = alphabets[conv];
            convertTable[fromCode] = conv + 97; 
          }
          
          var result = ;
          for(var k = 0; k < inp.length; k+=2){
            result += String.fromCharCode(convertTable[parseInt(inp[k] + inp[k+1], 16)]);
          }
          console.log(result);
          continue FIRST;
        }
        
      }
    }
  
  }
}"
JavaScript,"var f = [];
 
function main(){
  for(var y=-2;y<12;y++){
    f[y] = [];
    for(var x=-2;x<12;x++){
      f[y][x] = 0;
    }
  }
 
   
  for(var i=0,len=input.length - 1;i<len;i++){
    var s = input[i].split(',');
    eval(+s[2]++s[0]++s[1]+);
  }
 
  var nd=0;
  var md=0;
  for(var y=0;y<10;y++){
    for(var x=0;x<10;x++){
      nd += !(f[y][x]);
      md = mx(f[y][x], md);
    }
  }
 
  console.log(nd);
  console.log(md);
}
 
function d1(x, y){
  f[y+1][x]++;
  f[y][x-1]++;
  f[y][x]++;
  f[y][x+1]++;
  f[y-1][x]++;
}
 
function d2(x, y){
  d1(x, y);
  f[y+1][x-1]++;
  f[y+1][x+1]++;
  f[y-1][x-1]++;
  f[y-1][x+1]++;
}
 
function d3(x, y){
  d2(x, y);
  f[y+2][x]++;
  f[y-2][x]++;
  f[y][x-2]++;
  f[y][x+2]++;
}
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
 
var
input = '';
 
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"(function utils(undefined){
	this.print_float = function print_float(val, base, pad, prec) {
		var p10=Math.pow(10,prec);
		var ival=+Math.round(val*p10);
		if ( ival === '0' )
			return '0.'+Array(prec+1).join('0');
		var ilen=ival.length-prec;
		if(ilen===0)
			return +ival.substr(ilen,prec);
		return ival.substr(0,ilen)++ival.substr(ilen,prec);
	};
}).call(global);
(function math(undefined) {
	this.gcd = function gcd( a, b ) {
		return !b ? a : gcd( b, a % b );
	};
	this.lcm = function lcm( a, b ) {
		return a / gcd( a, b ) * b;
	};
	this.sq = function sq(x) {
		return x * x;
	};
}).call(global);
(function(undefined){
	'use strict';
	(function init() {
		this.output = function() {
			console.log.apply( console, arguments );
		};
		this.stdin = process.openStdin();
		stdin.setEncoding('utf8');
		this.input_list = [];
		stdin.on('data', function(chunk){
			var result = chunk.match(/[-]?\\d+/g);
			input_list = input_list.concat(result);
		});
		stdin.on('end', function(){
			fire();
		});
		this.input_number = function() {
			return parseInt( input_list.splice(0,1)[0] );
		};
		this.has_next = function() {
			return ! input_list.length;
		};
	}).call( this );
	(function solver(){
		this.fire = function() {
			setTimeout( solve, 0, this );
		};
		function solve() {
			var args = [input_number(), input_number()];
			output( gcd.apply( this, args ), lcm.apply( this, args ) );
			if ( ! has_next() )
				setTimeout( solve, 0, this );
		}
	}).call(this);
}).call(global);"
JavaScript,"var primeNxt = new Array(1000000);
function primeGenerator()
{
    var p, fact, m;
    var maxN = 1002001;
    var primePrv = new Array(1000000);
    
    for(p=2;p<=maxN;++p){
        primeNxt[p] = p + 1;
        primePrv[p] = p - 1;
    }
    primePrv[2] = 0;
    primeNxt[maxN] = 0;
    
    
    for(p=2;p*p<=maxN;p=primeNxt[p]){
        for(fact=p;p*fact<=maxN;fact=primeNxt[fact]){
            for(m=p*fact;m<=maxN;m*=p){
                primeNxt[primePrv[m]] = primeNxt[m];
                primePrv[primeNxt[m]] = primePrv[m];
            }
        }
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
 
process.stdin.on('data', function(input){
    primeGenerator();
    input.trim().split('\\n').forEach(function(val){
        var N = parseInt(val);
        var cnt = 1;
        if( N == 1 ){
            console.log(0);
        }
        else if( N == 2 ){
            console.log(1);
        }
        else{
            for(var i=3;i<=N;i=primeNxt[i]){
               ++cnt;
            }
            console.log(cnt);
        }
    });
});"
JavaScript,"function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = inp.split(' ').map(Number);
    var found = false;
 
  FIRST:for(var a = 0; a < 4; a++){
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
 
          for(var op1 = 0; op1 < 3; op1++){
            for(var op2 = 0; op2 < 3; op2++){
              for(var op3 = 0; op3 < 3; op3++){
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inp[a], inp[b], operands[op1], inp[c], operands[op2], inp[d], operands[op3]];
                    break;
                  case 1:
                    
                    polish = [inp[a], inp[b], inp[c], operands[op1], operands[op2], inp[d], operands[op3]];
                    break;
                  case 2:
                    
                    polish = [inp[a], inp[b], operands[op1],inp[c], inp[d], operands[op2], operands[op3]];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"(function(input) {
  var p = input.replace(/\\n$/, '').split('\\n');
  var m = [];
  for (var i = 0; i < p.length; i++) {
    m.push(p[i].split('').map(Number))
  }
  console.log('R' + move(m, 0, 0, 'R'));
})(require('fs').readFileSync('/dev/stdin', 'utf8'));
function move(m, x, y, d) {
  
  if (x === 0 && y === 0 && d === 'L') {
    return '';
  }
  if (d === 'R') {
    if (mm(m, x + 1, y - 1)) {
      return 'U' + move(m, x + 1, y - 1, 'U');
    }
    if (mm(m, x + 1, y)) {
      return 'R' + move(m, x + 1, y, 'R');
    }
    if (mm(m, x + 1, y + 1)) {
      return 'D' + move(m, x + 1, y + 1, 'D');
    }
    return 'L' + move(m, x, y, 'L');
  }
  if (d === 'L') {
    if (mm(m, x, y + 1)) {
      return 'D' + move(m, x, y + 1, 'D');
    }
    if (mm(m, x - 1, y)) {
      return 'L' + move(m, x - 1, y, 'L');
    }
    if (mm(m, x, y - 1)) {
      return 'U' + move(m, x, y - 1, 'U');
    }
    return 'R'+ move(m, x, y, 'R');
  }
  if (d === 'D') {
    if (mm(m, x, y + 1)) {
      return 'R' + move(m, x, y + 1, 'R');
    }
    if (mm(m, x, y + 2)) {
      return 'D' + move(m, x, y + 2, 'D');
    }
    if (mm(m, x - 1, y + 1)) {
      return 'L' + move(m, x - 1, y + 1, 'L');
    }
    return 'U' + move(m, x, y, 'U');
  }
  if (d === 'U') {
    if (mm(m, x - 1, y - 1)) {
      return 'L' + move(m, x - 1, y - 1, 'L');
    }
    if (mm(m, x, y - 2)) {
      return 'U' + move(m, x, y - 2, 'U');
    }
    if (mm(m, x, y - 1)) {
      return 'R' + move(m, x, y - 1, 'R');
    }
    return 'D' + move(m, x, y, 'D');
  }
}
function mm(m, x, y) {
  if (y < 0 || y >= m.length) {
    return 0;
  }
  if (x < 0 || x >= m[y].length) {
    return 0;
  }
  return m[y][x] === 1;
}"
JavaScript,"function calcultateGCD(a,b,res) {
	if(a==b)
		return a*res;
    else if ((a&1)==0 && (b&1)==0) 
    	return calcultateGCD(a>>1, b>>1, res<<1);	
    else if ((a&1)==0) 
    	return calcultateGCD(a>>1, b, res); 
    else if ((b&1)==0) 
    	return calcultateGCD(a, b>>1, res); 
    else if (a>b) 
    	return calcultateGCD(a-b, b, res);
    else 
    	return calcultateGCD(a, b-a, res); 
}
function calcultateLCM(a,b,gcd) {
	  return a*b/gcd;
}
var input = require('fs').readFileSync('/dev/stdin', 'utf8');
var lines = input.split('\\n');
if(lines.length > 50) {
	console.log(+lines.length+);
} else {
	for (var i = 0; i < lines.length; i++) {
		var line = lines[i].trim();
	    if (line == '') break;
	    var vals = line.split(' ').map(function(i){return +i;});
	    if(vals.length != 2 || isNaN(vals[0]) || isNaN(vals[1]) || vals[0] < 0 || vals[0] > 2000000000 || vals[1] < 0 || vals[1] > 2000000000) {
	    	console.log(+line+ );
	    } else {
	    	var gcd = calcultateGCD(vals[0],vals[1],1);
	    	var lcm = calcultateLCM(vals[0],vals[1],gcd);
	    	if(lcm > 2000000000)
		    	console.log(+line+ +lcm+);
	    	else 
	    		console.log(gcd++lcm);
		}
	}
}"
JavaScript,"(function set_utils(undefined){
	this.print_float = function print_float(val, base, pad, prec) {
		var p10=Math.pow(10,prec);
		var ival=+Math.round(val*p10);
		if ( ival === '0' )
			return '0.'+Array(prec+1).join('0');
		var ilen=ival.length-prec;
		if(ilen===0)
			return +ival.substr(ilen,prec);
		return ival.substr(0,ilen)++ival.substr(ilen,prec);
	};
	this.gcd = function gcd( a, b ) {
		return !b ? a : gcd( b, a % b );
	};
	this.lcm = function lcm( a, b ) {
		return a / gcd( a, b ) * b;
	};
}).call(global);
(function(undefined){
	'use strict';
	(function init() {
		this.output = function() {
			console.log.apply( console, arguments );
		};
		this.stdin = process.openStdin();
		stdin.setEncoding('utf8');
		this.input_list = [];
		stdin.on('data', function(chunk){
			var result = chunk.match(/[-]?\\d+/g);
			input_list = input_list.concat(result);
		});
		stdin.on('end', function(){
			fire();
		});
		this.input_number = function() {
			return parseInt( input_list.splice(0,1)[0] );
		};
		this.has_next = function() {
			return ! input_list.length;
		};
	}).call( this );
	(function solver(){
		function sq(x) {
			return x * x;
		}
		function check(v) {
		}
		this.fire = function() {
			setTimeout( solve, 0, this );
		};
		function solve() {
			var args = [input_number(), input_number()];
			output( gcd.apply( this, args ), lcm.apply( this, args ) );
			if ( ! has_next() )
				setTimeout( solve, 0, this );
		}
	}).call(this);
}).call(global);"
JavaScript,"(function underscore(undefined) {
	'use strict';
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	var push = ArrayProto.push,
	slice = ArrayProto.slice,
	concat = ArrayProto.concat,
	toString = ObjProto.toString,
	hasOwnProperty = ObjProto.hasOwnProperty;
	var nativeForEach = ArrayProto.forEach,
	nativeMap = ArrayProto.map,
	nativeReduce = ArrayProto.reduce,
	nativeReduceRight = ArrayProto.reduceRight,
	nativeFilter = ArrayProto.filter,
	nativeEvery = ArrayProto.every,
	nativeSome = ArrayProto.some,
	nativeIndexOf = ArrayProto.indexOf,
	nativeLastIndexOf = ArrayProto.lastIndexOf,
	nativeIsArray = Array.isArray,
	nativeKeys = Object.keys,
	nativeBind = FuncProto.bind;
	this._ = {};
	var each = _.each = _.forEach = function(obj, iterator, context) {
		if (obj == null) return;
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, l = obj.length; i < l; i++) {
				if (iterator.call(context, obj[i], i, obj) === breaker) return;
			}
		} else {
			for (var key in obj) {
				if (_.has(obj, key)) {
					if (iterator.call(context, obj[key], key, obj) === breaker) return;
				}
			}
		}
	};
	_.extend = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			}
		});
		return obj;
	};
}).call(global);
(function(undefined){
	'use strict';
	var INPUT_TYPE = 'number';
	var INPUT_REGEXP_LIST = {};
	INPUT_REGEXP_LIST['string'] = /\\w*/g;
	INPUT_REGEXP_LIST['number'] = /[-]?\\d+/g;
	var INPUT_REGEXP = INPUT_REGEXP_LIST[INPUT_TYPE];
	var Solver = {
		fire: function() {
			setTimeout( Solver.solve, 0, this );
		},
		solve: function solve() {
			var n = input_number();
			var m = 100000;
			for ( var i = 0; i < n; ++ i ) {
				m = parseInt(m * 1.05);
				if ( m % 1000 > 0 ) {
					m += 1000;
				}
				m = (function(m){
					return Math.floor(m/1000)*1000;
				})(m);
			}
			output(m);
			if ( ! has_next() )
				setTimeout( Solver.solve, 0, this );
		}
	};
	(function init() {
		_.extend( this, {
			output: function() {
				console.log.apply( console, arguments );
			},
			stdin: process.openStdin(),
			input_list: [],
			input_number: function() {
				return parseInt( input_list.splice(0,1)[0] );
			},
			input_text: function() {
				return input_list.splice(0,1)[0];
			},
			has_next: function() {
				return ! input_list.length;
			}
		} );
		stdin.setEncoding('utf8');
		stdin.on('data', function(chunk){
			var result = chunk.match(INPUT_REGEXP);
			input_list = input_list.concat(result.filter(function(line){
				return line.length;
			}));
		});
		stdin.on('end', function(){
			Solver.fire.call(this);
		});
	}).call( this );
}).call(global);"
JavaScript,"(function(input) {
  var p = input.replace(/\\n$/, '').split('\\n\\n');
  for (var j = 0; j < p.length; j++) {
    var b = p[j].split('\\n');
    var m = [];
    for (var i = 0; i < b.length; i++) {
      m.push(b[i].split('').map(Number));
    }
    console.log(exists(m));
    
  }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));
function exists(m) {
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (m[i][j] === 1) {
        return exists_(m, j, i);
      }
    }
  }
}
function exists_(m, x, y) {
  if (check(m, x + 1, y) && check(m, x, y + 1) && check(m, x + 1, y + 1)) {
    return 'A';
  }
  if (check(m, x, y + 1) && check(m, x, y + 2) && check(m, x, y + 3)) {
    return 'B';
  }
  if (check(m, x + 1, y) && check(m, x + 2, y) && check(m, x + 3, y)) {
    return 'C';
  }
  if (check(m, x, y + 1) && check(m, x - 1, y + 1) && check(m, x - 1, y + 2)) {
    return 'D';
  }
  if (check(m, x + 1, y) && check(m, x + 1, y + 1) && check(m, x + 2, y + 1)) {
    return 'E';
  }
  if (check(m, x, y + 1) && check(m, x + 1, y + 1) && check(m, x + 1, y + 2)) {
    return 'F';
  }
  if (check(m, x + 1, y) && check(m, x, y + 1) && check(m, x - 1, y + 1)) {
    return 'G';
  }
}
function check(m, x, y) {
  if (x < 0 || x > 7 || y < 0 || y > 7) {
    return false;
  }
  return m[y][x] === 1;
}"
JavaScript,"(function(input) {
  var p = input.replace(/\\n$/, '').split('\\n');
  var n = p.length;
  var m = new Array(10);
  for (var i = 0; i < m.length; i++) {
    m[i] = (new Array(11)).join('0').split('').map(Number);
  }
  for (i = 0; i < n; i++) {
    var a = p.shift().split(',').map(Number);
    var x = a.shift();
    var y = a.shift();
    var s = a.shift();
    drop(m, x, y, s);
  }
  var max = 0;
  var space = 0;
  
  for (i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
      var c = m[i][j];
      
      if (c > max) {
        max = c;
      }
      if (c === 0) {
        space++;
      }
    }
  }
  console.log(space);
  console.log(max);
})(require('fs').readFileSync('/dev/stdin', 'utf8'));
function drop(m, x, y, s) {
  drop_(m, x, y);
  drop_(m, x, y - 1);
  drop_(m, x - 1, y);
  drop_(m, x + 1, y);
  drop_(m, x, y + 1);
  if (s >= 2) {
    drop_(m, x - 1, y - 1);
    drop_(m, x + 1, y - 1);
    drop_(m, x - 1, y + 1);
    drop_(m, x + 1, y + 1);
  }
  if (s >= 3) {
    drop_(m, x, y - 2);
    drop_(m, x - 2, y);
    drop_(m, x + 2, y);
    drop_(m, x, y + 2);
  }
}
function drop_(m, x, y) {
  if (x < 0 || x > 9 || y < 0 || y > 9) {
    return;
  }
  m[x][y]++;
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = inp.split(' ').map(Number);
    var found = false;
 
  FIRST:for(var a = 0; a < 4; a++){
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
 
          for(var op1 = 0; op1 < 3; op1++){
            for(var op2 = 0; op2 < 3; op2++){
              for(var op3 = 0; op3 < 3; op3++){
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inp[a], inp[b], operands[op1], inp[c], operands[op2], inp[d], operands[op3]];
                    break;
                  case 1:
                    
                    polish = [inp[a], inp[b], inp[c], operands[op1], operands[op2], inp[d], operands[op3]];
                    break;
                  case 2:
                    
                    polish = [inp[a], inp[b], operands[op1],inp[c], inp[d], operands[op2], operands[op3]];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"var print = console.log; 
var input_lines; 
function PreMain(input) {
    input_lines = input.split();
    var f = function () {
        return input_lines.shift();
    };
    Main(f);
}
function IL(min1Flg) {
    var s = input_lines.shift().split(' ');
    var offset = min1Flg ? -1 : 0;
    var res = [];
    for (var i = 0; i < s.length; i++) {
        res.push(parseInt(s[i]));
    }
    return res;
}
/**
 * @return {number}
 */
Array.prototype.SUM = function SUM() {
    var sum = 0;
    this.forEach(function (elm) {
        sum += elm;
    });
    return sum;
};
/**
 * @return {string}
 */
Array.prototype.Format = function Format(split) {
    if (split === undefined) {
        split = ;
    }
    return this.join(split);
};
Array.prototype.Copy = function Copy() {
    return [].concat(this);
};
/***
 * ??????Sort
 * <Array>.sort?????¨???(?????????)???????????????????????¨????????¨???
 * ??°????????????????????§?????°????????????????????????????????´??????????????????????????¨?????????
 * @constructor
 */
Array.prototype.Sort = function Sort() {
    this.sort(function (a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    });
};
/*
(((???????????)??? ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
*/
function prime_numbers(n) {
    var tbl = [-1, -1];
    for (var i = 2; i <= n; i++) {
        tbl.push(0)
    }
    for (var i = 2; i <= Math.sqrt(n); i++) {
        if (tbl[i] === 0) {
            for (var j = i * 2; j <= n; j += i) {
                tbl[j] = -1;
            }
        }
    }
    var res = [];
    tbl.forEach(function (t, number) {
        if (t === 0) {
            res.push(number);
        }
    });
    return res;
}
function range(i,n){
    var res = [];
    for(;i<n;i++){
        res.push(i);
    }
    return res;
}
function get_a_pat() {
    var pat = {};
    range(1,26).forEach(function (a) {
        if(a % 2===0 || a % 13===0){
            return;
        }
        var acode = 'a'.charCodeAt(0);
        for (var b = 0; b < 26; b++) {
            var tmp = '';
            var tmp2 = '';
            for (var i = 0; i < 4; i++) {
                var x = 'this'.charCodeAt(i) - acode;
                tmp += String.fromCharCode(((a * x + b) % 26) + acode);
                var y = 'that'.charCodeAt(i) - acode;
                tmp2 += String.fromCharCode(((a * y + b) % 26) + acode);
            }
            if (pat.hasOwnProperty(tmp)) {
                print(tmp);
            }
            if (pat.hasOwnProperty(tmp2)) {
                print(tmp2);
            }
            pat[tmp] = [a, b];
            pat[tmp2] = [a, b];
        }
    });
    return pat;
}
function get_foo(a, b, str) {
    var acode = 'a'.charCodeAt(0);
    var tmp = '';
    for (var i = 0; i < 26; i++) {
        tmp += String.fromCharCode(((a * i + b) % 26) + acode);
    }
    var res = '';
    for (var i = 0; i < str.length; i++) {
        if (str.charAt(i) === ' ') {
            res += ' ';
        } else {
            res += String.fromCharCode(tmp.indexOf(str.charAt(i)) + acode);
        }
    }
    return res;
}
function Main(input) {
    var n = parseInt(input());
    var p = get_a_pat();
    var key;
    for (var j = 0; j < n; j++) {
        var str_org = input();
        var str = str_org.split(' ');
        for (var i = 0; i < str.length; i++) {
            if (p.hasOwnProperty(str[i])) {
                key = p[str[i]];
                break;
            }
        }
        print(get_foo(key[0], key[1], str_org));
    }
}
 PreMain(require().readFileSync(, ));"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int16Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = pdpw;
        if(w - tw >= 0){
          dp[w] = max(pdp[w-tw] + tv, pdpw);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"function Main(input) {
	var input = input.split();
    var  N = Int(input[0]);
    for(var i=1;i<=N;i++){
        var side = input[i].split();
        for(var j =0;j<3;j++){
            side[j]=Int(side[j]);
        }
        side.sort(descendingOrder);
        if(side[0]*side[0]==side[1]*side[1]+side[2]*side[2]){
            output();
        }else{
            output();
        }
    }
}
function ascendingOrder(val1,val2){
    return val1 - val2;
}
function descendingOrder(val1,val2){
    return val2 - val1;
}
function Int(str){
    return parseInt(str, 10);
}
function Str(num){
    return num.toString(10);
}
function output(str){
	if(_Isdebug){
		document.getElementById().value+=(str+);
	}
	console.log(str);
}
var _Isdebug = false;
function debug(){
	_Isdebug =true;
	var input = document.getElementById().value;
	Main(input);
}
Main(require().readFileSync(, ));"
JavaScript,"(function(input) {
    var p = input.replace(/\\n$/, '').split('\\n').map(Number);
    for (var i = 0; i < p.length; i++) {
        var n = p[i];
        var count = 0;
        for (var a = 0; a < 10; a++) {
            
            var sa = n - a;
            if (sa < 0) {
                break;
            }
            for (var b = 0; b < 10; b++) {
                
                var sb = sa - b;
                if (sb < 0) {
                    break;
                }
                for (var c = 0; c < 10; c++) {
                    
                    var sc = sb - c;
                    if (sc < 0) {
                        break;
                    }
                    for (var d = 0; d < 10; d++) {
                        
                        var sd = sc - d;
                        if (sd === 0) {
                            
                            count++;
                            break;
                        }
                    }
                }
            }
        }
        console.log(count);
    }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int16Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = (w-tw < 0) ? pdpw : Math.max(pdp[w-tw] + tv, pdpw);
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
    
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        if(w - tw < 0){
          dp[w] = pdp[w];
        }else{
          dp[w] = max(pdp[w-tw] + tv, pdp[w]);
        }
      }
      pdp = dp;
    }
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      if(pdp[i] > resultCost){
        resultCost = pdp[i];
        resultWeight = i;
      }
    }
    
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require();
/*
    determinant of 2x2 matrix
    [ a  b ]
    [ c  d ]
*/
function det(a, b, c, d) {
    return a * d - b * c;
}
/*
    ax+by=c
    dx+ey=f
    [a b] = [c]
    [d e] = [f]
    x matrix:
    [c b]
    [f e]
    y matrix:
    [a c]
    [d f]
*/
function solve_xy(a, b, c, d, e, f) {
    var D = det(a, b, d, e)
    var x = det(c, b, f, e) / D;
    var y = det(a, c, d, f) / D;
    return { x: x, y: y }
}
var input = fs.readFileSync('/dev/stdin').toString();
var lines = input.split();
for(var i = 0; i < lines.length; i++) {
    var parts = lines[i].split();
    var a = parseInt(parts.shift());
    var b = parseInt(parts.shift());
    var c = parseInt(parts.shift());
    var d = parseInt(parts.shift());
    var e = parseInt(parts.shift());
    var f = parseInt(parts.shift());
    if(!isNaN(a)) {
        var solution = solve_xy(a, b, c, d, e, f);
        console.log(solution.x.toFixed(3), solution.y.toFixed(3));
    }
}"
JavaScript,"(function set_utils(undefined){
	this.print_float = function print_float(val, base, pad, prec) {
		var p10=Math.pow(10,prec);
		var ival=+Math.round(val*p10);
		if ( ival === '0' )
			return '0.'+Array(prec+1).join('0');
		var ilen=ival.length-prec;
		if(ilen===0)
			return +ival.substr(ilen,prec);
		return ival.substr(0,ilen)++ival.substr(ilen,prec);
	};
}).call(global);
(function(undefined){
	'use strict';
	(function init() {
		this.output = function() {
			console.log.apply( console, arguments );
		};
		this.stdin = process.openStdin();
		stdin.setEncoding('utf8');
		this.input_list = [];
		stdin.on('data', function(chunk){
			var result = chunk.match(/[-]?\\d+/g);
			input_list = input_list.concat(result);
		});
		stdin.on('end', function(){
			fire();
		});
		this.input_number = function() {
			return parseInt( input_list.splice(0,1)[0] );
		};
		this.has_next = function() {
			return ! input_list.length;
		};
	}).call( this );
	(function solver(){
		function sq(x) {
			return x * x;
		}
		function check(v) {
		}
		this.fire = function() {
			setTimeout( function solve() {
				var a = input_number();
				var b = input_number();
				var c = input_number();
				var d = input_number();
				var e = input_number();
				var f = input_number();
				var delta = 1.0 / ( a*e - b*d );
				var x = ( e * c - b * f ) * delta;
				var y = ( a * f - d * c ) * delta;
				output( print_float(x,10,3,3) + ' ' + print_float(y,10,3,3)  );
				if ( ! has_next() )
					setTimeout( solve, 0, this );
			}, 0, this );
		};
	}).call(this);
}).call(global);"
JavaScript,"var fs = require('fs'),
    length = fs.fstatSync(process.stdin.fd).size,
    buffer = new Buffer(length),
    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
    input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 return a - ((a-b) & ((a-b) >> 31));
}"
JavaScript,"(function(input) {
  var p = input.replace(/\\n$/, '').split('\\n');
  var a;
  while (a = p.shift().split(' ').map(Number)) {
    if (a.every(function(e) {
        return e ===  0;
      })) {
      return;
    }
    
    console.log(conv(result(a)));
  }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));
function result(a) {
  for (var i = 0; i < 4; i++) {
    var r = Array(4);
    r[i] = a[0];
    for (var j = 0; j < 4; j++) {
      if (r[j] !== undefined) {
        continue;
      }
      r[j] = a[1];
      for (var k = 0; k < 4; k++) {
        if (r[k] !== undefined) {
          continue;
        }
        r[k] = a[2];
        for (var l = 0; l < 4; l++) {
          if (r[l] !== undefined) {
            continue;
          }
          r[l] = a[3];
          
          var op = ['+', '-', '*'];
          for (var m = 0; m < 3; m++) {
            for (var n = 0; n < 3; n++) {
              for (var o = 0; o < 3; o++) {
                for (var p = 0; p < 3; p++) {
                  var f = [];
                  if (p == 0) {
                    f = [r[0], r[1], r[2], op[m], op[n], r[3], op[o]];
                  } else if (p == 1) {
                    f = [r[0], r[1], op[m], r[2], op[n], r[3], op[o]];
                  } else {
                    f = [r[0], r[1], op[m], r[2], r[3], op[n], op[o]];
                  }
                  
                  if (calc(f) == 10) {
                    
                    return f;
                  }
                }
              }
            }
          }
          r[l] = undefined;
        }
        r[k] = undefined;
      }
      r[j] = undefined;
    }
  }
  return false;
}
function calc(a) {
  var stack = [];
  for (var i = 0; i < a.length; i++) {
    var n = a[i];
    
    if (isNaN(n)) {
      var str = stack.pop();
      str = stack.pop() + ' ' + n + ' ' + str;
      
      var acm = eval(str);
      
      stack.push(acm);
      continue;
    }
    stack.push(Number(n));
  }
  return stack.pop();
}
function conv(a) {
  if (!a) {
    return '0';
  }
  var stack = [];
  for (var i = 0; i < a.length; i++) {
    var n = a[i];
    
    if (isNaN(n)) {
      var str = stack.pop();
      str = '(' + stack.pop() + ' ' + n + ' ' + str + ')';
      
      
      
      stack.push(str);
      continue;
    }
    stack.push(Number(n));
  }
  return stack.pop();
}"
JavaScript,"function Vector(x, y) {
  this.x = x;
  this.y = y;
}
Vector.prototype.sub = function(v) {
  return new Vector(this.x - v.x, this.y - v.y);
};
Vector.prototype.product = function(v) {
  return this.x * v.y - this.y * v.x;
};
(function(input) {
  var p = input.replace(/\\n$/, '').split('\\n');
  var n = p.length;
  for (var i = 0; i < n; i++) {
    var a = p.shift().split(',').map(Number);
    console.log(cross.apply(null, a));
  }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));
function cross(xa, ya, xb, yb, xc, yc, xd, yd) {
  var va = new Vector(xa, ya);
  var vb = new Vector(xb, yb);
  var vc = new Vector(xc, yc);
  var vd = new Vector(xd, yd);
  var vba = vb.sub(va);
  var vcb = vc.sub(vb);
  var vdc = vd.sub(vc);
  var vad = va.sub(vd);
  var c1 = vba.product(vcb);
  var c2 = vcb.product(vdc);
  var c3 = vdc.product(vad);
  var c4 = vad. product(vba);
  if ((c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) ||
    (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0)) {
    return 'YES';
  }
  return 'NO';
}
function cross_(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}"
JavaScript,"var primeNxt = new Array(1000000);
function primeGenerator()
{
    var p, fact, m;
    var maxN = 9999999;
    var primePrv = new Array(1000000);
    
    for(p=2;p<=maxN;++p){
        primeNxt[p] = p + 1;
        primePrv[p] = p - 1;
    }
    primePrv[2] = 0;
    primeNxt[maxN] = 0;
    
    
    for(p=2;p*p<=maxN;p=primeNxt[p]){
        for(fact=p;p*fact<=maxN;fact=primeNxt[fact]){
            for(m=p*fact;m<=maxN;m*=p){
                primeNxt[primePrv[m]] = primeNxt[m];
                primePrv[primeNxt[m]] = primePrv[m];
            }
        }
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
 
process.stdin.on('data', function(input){
    primeGenerator();
    input.trim().split('\\n').forEach(function(val){
        var N = parseInt(val);
        var cnt = 1;
        if( N == 1 ){
            console.log(0);
        }
        else if( N == 2 ){
            console.log(1);
        }
        else{
            for(var i=3;i<=N;i=primeNxt[i]){
               ++cnt;
            }
            console.log(cnt);
        }
    });
});"
JavaScript,"function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"function main(){
  var localInput = input;
  var f = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ,[0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]) + 2;
    var iy = parseInt(l[2]) + 2;
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y+2][x+2]);
      md = mx(f[y+2][x+2], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"process.stdin.resume();
process.stdin.setEncoding('utf8');
var _HEIGHT = 8;
var input_string = '';
process.stdin.on('data', function(chunk) {
    input_string += chunk.toString();
});
process.stdin.on('end', function() {
    
    var lines = input_string.split('\\n');
    lines = lines.filter(function(val) {
        return val !== '';
    });
    
    while (lines.length >= _HEIGHT) {
        judge(lines.splice(0, _HEIGHT));
    }
});
function judge(ary) {
    tmpAry = ary.filter(function(val) {
       return val.indexOf('1') >= 0; 
    });
    
    compShape(tmpAry);
}
function compShape(ary) {
    switch (ary.length) {
        case 1:
            console.log('C')
            break;
        case 2:
            case2(ary);
            break;
        case 3:
            case3(ary);
            break;
        case 4:
            console.log('B')
            break;
        default:
            console.log('Error');
    }
}
function case2(ary) {
    ind0 = ary[0].indexOf('1');
    ind1 = ary[1].indexOf('1');
    
    if (ind0 < ind1) {
        console.log('E');
    }
    else if (ind0 > ind1) {
        console.log('G');
    }
    else {
        console.log('A');
    }
}
function case3(ary) {
    ind0 = ary[0].indexOf('1');
    ind1 = ary[1].indexOf('1');
    
    if (ind0 > ind1) {
        console.log('D');
    }
    else {
        console.log('F');
    }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
  
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
      
    var treasures = +input[read++];
    var dp = [];
    dp.length = maxWeight + 1;
    
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
  
      for(var w = maxWeight; w - tw >= 0; w--){
        dp[w] = max((dp[w-tw]|0) + tv, (dp[w]|0));
      }
    }
  
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var dpi = dp[i];
      if(dpi > resultCost){
        resultCost = dpi;
        resultWeight = i;
      }
    }
      
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var primeNxt = new Array(1000000);
function primeGenerator()
{
    var p, fact, m;
    var maxN = 1002001;
    var primePrv = new Array(1000000);
    
    for(p=2;p<=maxN;++p){
        primeNxt[p] = p + 1;
        primePrv[p] = p - 1;
    }
    primePrv[2] = 0;
    primeNxt[maxN] = 0;
    
    
    for(p=2;p*p<=maxN;p=primeNxt[p]){
        for(fact=p;p*fact<=maxN;fact=primeNxt[fact]){
            for(m=p*fact;m<=maxN;m*=p){
                primeNxt[primePrv[m]] = primeNxt[m];
                primePrv[primeNxt[m]] = primePrv[m];
            }
        }
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
 
process.stdin.on('data', function(input){
    primeGenerator();
    input.trim().split('\\n').forEach(function(val){
        var N = parseInt(val);
        var cnt = 1;
        if( N == 1 ){
            console.log(0);
        }
        else if( N == 2 ){
            console.log(1);
        }
        else{
            for(var i=3;i<=N;i=primeNxt[i]){
               ++cnt;
            }
            console.log(cnt);
        }
    });
});"
JavaScript,"function calcultateGCD(a,b,res) {
	if(a==b)
		return a*res;
    else if ((a&1)==0 && (b&1)==0) 
    	return calcultateGCD(a>>1, b>>1, res<<1);	
    else if ((a&1)==0) 
    	return calcultateGCD(a>>1, b, res); 
    else if ((b&1)==0) 
    	return calcultateGCD(a, b>>1, res); 
    else if (a>b) 
    	return calcultateGCD(a-b, b, res);
    else 
    	return calcultateGCD(a, b-a, res); 
}
function calcultateLCM(a,b,gcd) {
	  return a*b/gcd;
}
var input = require('fs').readFileSync('/dev/stdin', 'utf8');
var lines = input.split('\\n');
if(lines.length > 50) {
	console.log(+lines.length+);
} else {
	for (var i = 0; i < lines.length; i++) {
		var line = lines[i].trim();
	    if (line == '') break;
	    var vals = line.split(' ').map(function(i){return +i;});
	    if(vals.length != 2 || isNaN(vals[0]) || isNaN(vals[1]) || vals[0] < 0 || vals[0] > 2000000000 || vals[1] < 0 || vals[1] > 2000000000) {
	    	console.log(+line+ );
	    } else {
	    	var gcd = calcultateGCD(vals[0],vals[1],1);
	    	var lcm = calcultateLCM(vals[0],vals[1],gcd);
	    	if(lcm > 2000000000)
		    	console.log(+line+ +lcm+);
	    	else 
	    		console.log(gcd++lcm);
		}
	}
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int32Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        if(w - tw < 0){
          dp[w] = pdp[w];
        }else{
          dp[w] = max(pdp[w-tw] + tv, pdp[w]);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
function main(){
  for(var i = 0, len = input.length; i < len; i++){
    var iarr = input[i].split(' ');
    j = 0;
    var v1 = new Vector2D(iarr[j++], iarr[j++]);
    var v2 = new Vector2D(iarr[j++], iarr[j++]);
    var v3 = new Vector2D(iarr[j++], iarr[j++]);
    var vp = new Vector2D(iarr[j++], iarr[j++]);
    var v12 = v2.sub(v1);
    var v2p = vp.sub(v2);
    
    var v23 = v3.sub(v2);
    var v3p = vp.sub(v3);
    var v31 = v1.sub(v3);
    var v1p = vp.sub(v1);
    var c1 = v12.cross(v2p);
    var c2 = v23.cross(v3p);
    var c3 = v31.cross(v1p);
    if((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0) ){
      console.log('YES');
    }else{
      console.log('NO');
    }
    
  }
}
function Vector2D(x, y){
  this.x = x - 0, this.y = y - 0;
  this.sub = function(v){
    return new Vector2D(this.x - v.x, this.y - v.y);
  };
  this.cross = function(v){
    return this.x * v.y - this.y * v.x;
  };
}"
JavaScript,"(function set_utils(undefined){
	this.print_float = function print_float(val, base, pad, prec) {
		var p10=Math.pow(10,prec);
		var ival=+Math.round(val*p10);
		if ( ival === '0' )
			return '0.000';
		var ilen=ival.length-prec;
		if(ilen===0)
			return +ival.substr(ilen,prec);
		return ival.substr(0,ilen)++ival.substr(ilen,prec);
	};
}).call(global);
(function(undefined){
	'use strict';
	(function init() {
		this.output = function() {
			console.log.apply( console, arguments );
		};
		this.stdin = process.openStdin();
		stdin.setEncoding('utf8');
		this.input_list = [];
		stdin.on('data', function(chunk){
			var result = chunk.match(/[-]?\\d+/g);
			input_list = input_list.concat(result);
		});
		stdin.on('end', function(){
			fire();
		});
		this.input_number = function() {
			return parseInt( input_list.splice(0,1)[0] );
		};
		this.has_next = function() {
			return ! input_list.length;
		};
	}).call( this );
	(function solver(){
		function sq(x) {
			return x * x;
		}
		function check(v) {
		}
		this.fire = function() {
			setTimeout( function solve() {
				var a = input_number();
				var b = input_number();
				var c = input_number();
				var d = input_number();
				var e = input_number();
				var f = input_number();
				var delta = 1.0 / ( a*e - b*d );
				var x = ( e * c - b * f ) * delta;
				var y = ( a * f - d * c ) * delta;
				output( print_float(x,10,3,3) + ' ' + print_float(y,10,3,3)  );
				if ( ! has_next() )
					setTimeout( solve, 0, this );
			}, 0, this );
		};
	}).call(this);
}).call(global);"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = inp.split(' ').map(Number);
    var found = false;
  FIRST:for(var a = 0; a < 4; a++){
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
          for(var op1 = 0; op1 < 3; op1++){
            for(var op2 = 0; op2 < 3; op2++){
              for(var op3 = 0; op3 < 3; op3++){
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inp[a], inp[b], operands[op1], inp[c], operands[op2], inp[d], operands[op3]];
                    break;
                  case 1:
                    
                    polish = [inp[a], inp[b], inp[c], operands[op1], operands[op2], inp[d], operands[op3]];
                    break;
                  case 2:
                    
                    polish = [inp[a], inp[b], operands[op1],inp[c], inp[d], operands[op2], operands[op3]];
                    break;
                  }
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
                  if(stack.pop() == 10){
                    found = true;
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                    
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
    if(!found)
      console.log(0);
    
  }
}
     "
C,"/*
連立方程式「ax+by=c, dx+ey=f」の解を求めよ。
結果：Time limit exceeded
連立方程式を解くのに苦労した。
タイムリミットと言われても、どうしたものか。
----------------------------------------------------------------------
13:35 2013/01/19
10027の例に倣い、配列ではなくした。これで軽くなっただろう。
・・・それでも駄目だった。
結果：Time limit exceeded
----------------------------------------------------------------------
23:06 2013/02/06
式の変形をすると、
x=(ce-bf)/(ae-bd);
y=(cd-af)/(bd-ae);
だ、そうで。
サンプルと同じ結果は出るものの、送ったらWAが返ってきた。はて。
結果：Wrong answer
*/
#include <stdio.h>
#include <math.h>
double yosute00(double n, int i);									
int main()
{
	double a,b,c,d,e,f,x,y;
	int i=0,count=0;
	double sp;
	int cal,ret;
	while(1){
		ret=scanf(,&a,&b,&c,&d,&e,&f);
		if(ret==EOF){
			break;
		}
		x = ((c*e)-(b*f)) / ((a*e)-(b*d));
		y = ((c*d)-(a*f)) / ((b*d)-(a*e));
		x = yosute00(x, 4);
		y = yosute00(y, 4);
		printf(,x,y);
	}
	return 0;
}
double yosute00(double n, int i)
{
	switch(i){
		case -5:
			n/=100000;
			n+=0.5;
			n=floor(n);
			n*=100000;
			break;
		
		case -4:
			n/=10000;
			n+=0.5;
			n=floor(n);
			n*=10000;
		
		case -3:
			n/=1000;
			n+=0.5;
			n=floor(n);
			n*=1000;
		
		case -2:
			n/=100;
			n+=0.5;
			n=floor(n);
			n*=100;
		
		case -1:
			n/=10;
			n+=0.5;
			n=floor(n);
			n*=10;
		
		case 1:
			n+=0.5;
			n=floor(n);
			break;
		
		case 2:
			n*=10;
			n+=0.5;
			n=floor(n);
			n/=10;
			break;
		
		case 3:
			n*=100;
			n+=0.5;
			n=floor(n);
			n/=100;
			break;
		
		case 4:
			n*=1000;
			n+=0.5;
			n=floor(n);
			n/=1000;
			break;
		
		case 5:
			n*=10000;
			n+=0.5;
			n=floor(n);
			n/=10000;
			break;
	}
	return n;
}"
C,"#include <stdio.h>
#include <math.h>
#define DIGIT 4
int main(void){
	double a[1000], b[1000], c[1000], d[1000], e[1000], f[1000];
	double term;
	int n = 0;
	int i, j, k,m=0;
	
	while (scanf(, &a[n], &b[n], &c[n], &d[n], &e[n], &f[n]) != EOF) {
		if ((-1000 <= (a[n],b[n],c[n],d[n],e[n],f[n]))
			&&((a[n],b[n],c[n],d[n],e[n],f[n])<=1000)) {
			n++;
		}
	}
	
	while (m < n) {
		double A[2][2] = {
			{e[m],-b[m]},
			{-d[m],a[m]}
		};
		double B[2][1] = {
			{c[m]},
			{f[m]}
		};
		double result[2];
		for (i = 0; i < 1; i++) {
			for (j = 0; j < 2; j++) {
				term = 0;
				for (k = 0; k < 2; k++) {
					term = term + A[j][k] * B[k][i];
				} 
				result[j] = term*(1 / (a[m] * e[m] - b[m] * d[m]));
				result[j] = (round(result[j]*(pow(10, DIGIT - 1))))/pow(10,DIGIT-1);
				if (result[j] == 0) {
					result[j] = copysign(0.0, 1.0);
				}
				if (a[m] == b[m] == c[m] == d[m] == e[m] == f[m]) {
					printf();
					break;
				}
			}
			printf(, result[0], result[1]);
		}
		m++;
	}
	return 0;
}"
C,"#include <stdio.h>
int main(){
    int i,m,m1,m2,m3;
    for(i=0;i<10;i++){
        scanf(,&m);
        if(i==0){
            m1=m;
        }
        else if(i==1){
            if(m>m1){
                m2=m1;
                m1=m;
            }
            else{
                m2=m;
            }
        }
        else if(i==2){
            if(m>m2){
                if(m>m1){
                    m3=m2;
                    m2=m1;
                    m1=m;
                }
                else{
                    m3=m2;
                    m2=m;
                }
            }
            else{
                m3=m;
            }
        }
        else{
            if(m>m3){
                if(m>m2){
                    if(m>m1){
                        m3=m2;
                        m2=m1;
                        m1=m;
                    }
                    else{
                        m3=m2;
                        m2=m;
                    }
                }
                else{
                    m3=m;
                }
            }
        }
    }
    printf(,m1,m2,m3);
    return 0;
}"
C,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)
#define N 2
void gauss(double a[N][N+1]){
  int i,j,k,l,pivot;
  double x[N];
  double p,q,m,b[1][N+1];
  rep(i,N){
    m = 0;
    pivot = i;
    REP(l,i,N) if(fabs(a[l][i]) > m){
      m = fabs(a[l][i]);
      pivot = l;
    }
    if(pivot != i) rep(j,N+1){
      b[0][j] = a[i][j];
      a[i][j] = a[pivot][j];
      a[pivot][j] = b[0][j];
    }
  }
  rep(k,N){
    p = a[k][k];
    a[k][k] = 1;
    REP(j,k+1,N+1) a[k][j] /= p;
    REP(i,k+1,N){
      q = a[i][k];
      REP(j,k+1,N+1) a[i][j] -= q * a[k][j];
      a[i][k] = 0;
    }
  }
  for(i=N-1; i>=0; i--){
    x[i] = a[i][N];
    for(j=N-1; j>i; j--){
      x[i] -= a[i][j] * x[j];
    }
  }
  printf(, x[0], x[1]);
}
int main(){
  int i,j;
  double a[N][N+1];
  while(scanf(,&a[0][0],&a[0][1],&a[0][2],&a[1][0],&a[1][1],&a[1][2]) != EOF){
    gauss(a);
  }
  return 0;
}"
C,"#include <stdio.h>
int count;
void comb(int n, int x) {                                                       
    int i;                                                                      
    for (i = 0; i < 10; i++) {                                                  
        if (n - i < 0)                                                          
            return;                                                             
        if (n - i == 0 && x == 0) {                                             
            count++;                                                            
            return;                                                             
        }                                                                       
        if (x > 0) {                                                            
            comb(n - i, x - 1);                                                 
        }                                                                       
    }                                                                           
}
int main(void) {                                                                
    int n;                                                                      
                                                                                
    while(scanf(, &n) != EOF) {                                             
        count = 0;                                                              
        comb(n, 3);                                                             
        printf(, count);                                                  
    }                                                                           
    return 0;                                                                   
}"
C,"#include <stdio.h>
#include <string.h>
#define N 2
int matrix(double **x);
 
int main(void){
	double x[N][N+1];
	double *y[N];
	double su1=0,su2=0;
	int i,j,k,n;
	char str[100],*line;
    
	for( ;fgets(str,sizeof(str),stdin)!=NULL; ){
		for(i=0;i<(N+1)*N;i++){
			if(i==0)
				line = strtok(str,);
			else
				line = strtok(NULL,);
			sscanf(line,,&n);
			x[i/(N+1)][i%(N+1)]=n;
			
		}
		for(i=0;i<N;i++)
			y[i]=x[i];
		matrix(y);
		for(i=0;i<N;i++){
			if(i) printf();
			printf(,x[i][N]);
		}
		printf();
	}
	return 0;
}
int matrix(double **x){
	int i,j,k;
	double su1=0,su2=0;
	for(k=0;k<=N-2;k++){
		for(j=k+1;j<=N-1;j++){
			su1=x[k][k];
			su2=x[j][k];
			for(i=0;i<=2;i++){
				x[j][i]=x[j][i]-x[k][i]*su2/su1;
			}
		}
	}	
	for(k=0;k<=N-2;k++){
		for(j=k+1;j<=N-1;j++){
			su1=x[1-k][1-k];
			su2=x[1-j][1-k];
			for(i=0;i<=2;i++){
				x[1-j][i]=x[1-j][i]-x[1-k][i]*su2/su1;
			}
		}
	}
	su1=0;
	for(j=0;j<=N-1;j++){
	su1=x[j][j];
		for(i=0;i<=N;i++){
		x[j][i]=x[j][i]/su1;
		}	
	}
	return 0;
}"
C,"#include <stdio.h>
int main() {
    
    int N, i, in1, in2, in3, a, b, c;
    
    scanf(, &N);
    
    for(i = 0; i < N; ++i) {
        
        scanf(, &in1, &in2, &in3);
        
        
        if(in1 >= in2 && in1 >= in3) {
            a = in2;
            b = in3;
            c = in1;
        } else if(in2 >= in1 && in2 >= in3) {
            a = in1;
            b = in3;
            c = in2;
        } else if(in3 >= in1 && in3 >= in2) {
            a = in1;
            b = in2;
            c = in3;
        }
        
        
        if(a*a + b*b == c*c) {
            printf();
        } else {
            printf();
        }
    } 
    return 0;
}"
C,"/*
	最大公約数を求めるためにユークリッドの互除法を利用する。
	____概要____
	A=Bq+r
	という式が与えられた時
	「AとBの公約数はBとrの公約数であるからGCD(A,B)とGCD(B,r)は一致する」
	____________
	上の式を変形して
	A/B=q...r
	つまり
	r=A%B
	となることを考えれば良い
	*/
#include<stdio.h>
unsigned long gcd(unsigned long, unsigned long);	
unsigned long lcm(unsigned long, unsigned long);	
int main(void){
	unsigned long a, b;
	int i;
	unsigned long g, l;	
	while (scanf(,&a,&b)!=EOF){
		g = gcd(a, b);
		l = lcm(a, b);
		printf(, g, l);
	}
	return 0;
}
unsigned long gcd(unsigned long a, unsigned long b){	
	unsigned long big, small;
	unsigned long r;	
	if (a == b){
		return a;
	}else if (a > b){
		big = a; small = b;
	}
	else if (a < b){
		big = b; small = a;
	}
	while (big%small != 0){
		r = big%small;
		if (small > r){
			big = small;
			small = r;
		}
		else if (small < r){
			big = r;
		}
		else if (small == r){
			big = r;
		}
	}
	return small;
}
unsigned long lcm(unsigned long a, unsigned long b){
	unsigned long l, g;
	g = gcd(a, b);
	l = a*b / g;
	return l;
}"
C,"#include <stdio.h>
#include <math.h>
int main(){
    int a,b,r=100,a2,b2,i,cnt=0,s=1;
    long int yaku[1000]={0},bai[1000];
    while(scanf(,&a,&b)!=EOF){
        a2=a;
        b2=b;
        if(a>b){
            r=a-b;
        }else{
            r=b-a;
        }
        while(r!=0){
            if(a2>b2){
                r=a2-b2;
                a2=b2;
                b2=r;
                s=1;
            }else{
                r=b2-a2;
                b2=a2;
                a2=r;
                s=2;
            }
        }
        if(s==1){
            yaku[cnt]=a2;
        }else{
            yaku[cnt]=b2;
        }
        bai[cnt]=1;
        for(i=100;i>1;i--){
            if(a%i==0&&b%i==0){
                while(1){
                    a=a/i;
                    b=b/i;
                    bai[cnt]*=i;
                    if(a%i!=0||b%i!=0) break;
                }
            }
        }
         
        bai[cnt]*=a*b;
        cnt++;
        r=100;
    }
    for(i=0;i<cnt;i++){
        printf(,yaku[i],bai[i]);
    }
    return 0;
}"
C,"#include<stdio.h>
int partition(int arr[],int low,int high){
    int mid;
    if(low<high){
        mid=(low+high)/2;
        partition(arr,low,mid);
        partition(arr,mid+1,high);
        mergeSort(arr,low,mid,high);
    }
    return 0;
}
int mergeSort(int arr[],int low,int mid,int high){
    int i,m,k,l,temp[10];
    l=low;
    i=low;
    m=mid+1;
    while((l<=mid)&&(m<=high)){
         if(arr[l]<=arr[m]){
             temp[i]=arr[l];
             l++;
         }
         else{
             temp[i]=arr[m];
             m++;
         }
         i++;
    }
    if(l>mid){
         for(k=m;k<=high;k++){
             temp[i]=arr[k];
             i++;
         }
    }
    else{
         for(k=l;k<=mid;k++){
             temp[i]=arr[k];
             i++;
         }
    }
    for(k=low;k<=high;k++){
         arr[k]=temp[k];
    }
    return 0;
}
int main(){
    int i,str[10];
    for(i=0;i<10;i++) scanf(,&str[i]);
    partition(str,0,9);
    for(i=9;i>6;i--) printf(,str[i]);
    return 0;
}"
C,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
double cal_Pow(int side){
    double cal;
    cal = pow(side,2);
    return cal;
}
int main(int argc, const char * argv[]){
    int i;
    int data_set;
    int side_a,side_b,side_c;
    scanf(,&data_set);
    if(data_set > 1000)
        exit(0);
    
    for(i = 0; i < data_set; i++){
        scanf(,&side_a,&side_b,&side_c);
        if((1 > side_a && side_a > 1000) && (1 > side_b && side_b > 1000) && (1 > side_c && side_c > 1000)){
            exit(0);
        }
        
        if((cal_Pow(side_a) + cal_Pow(side_b) == cal_Pow(side_c)) ||
           (cal_Pow(side_a) + cal_Pow(side_c) == cal_Pow(side_b)) ||
           (cal_Pow(side_b) + cal_Pow(side_c) == cal_Pow(side_a))){
            printf();
        }else{
            printf();
        }
           
    }
    return 0;
}"
C,"#include<stdio.h>
#define compile 0
double func_cal_x(double a, double b, double c, double d, double e, double f);
double func_cal_y(double a, double b, double c, double d, double e, double f);
void func_output(double x, double y);
main()
{
	double a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
	
	while(scanf(, &a, &b, &c, &d, &e, &f) != EOF)
	{
		double x = 0.0, y = 0.0;
		x = func_cal_x(a, b, c, d, e, f);
		y = func_cal_y(a, b, c, d, e, f);
		func_output(x, y);
	}
	return 0;
}
double func_cal_x(double a, double b, double c, double d, double e, double f)
{
	double result = 0.0;
	result = (((b * f) - (c * e)) / ((b * d) - (a * e)));
	if(result == 0)
	{
		result = 0.0;
	}
#if compile == 1
	printf(, result);
#endif
	return result;
}
double func_cal_y(double a, double b, double c, double d, double e, double f)
{
	double result = 0.0;
	result = (((c * d) - (a * f)) / ((b * d) - (a * e)));
	if(result == 0)
	{
		result = 0.0;
	}
#if compile == 1
	printf(, result);
#endif
	return result;
}
void func_output(double x, double y)
{
	printf(, x, y);
}"
C,"#include <stdio.h>
int main(void) {                                                                
    int i, n;                                                                   
    int money = 100000;                                                         
                                                                                
    scanf(, &n);                                                            
    for (i = 0; i < n; i++) {                                                   
        money = money * 1.05;                                                   
        if (money % 1000 != 0) {                                                
            money = ((money / 1000) + 1) * 1000;                                
        }                                                                       
    }                                                                           
    printf(, money);                                                      
                                                                                
    return 0;                                                                   
}"
C,"#include<stdio.h>
 
typedef unsigned char U1;
typedef int S4;
#define NUM_MOUNTAINS	(10) 
#define INVALID_DATA	(-1)
#define NUM_OUTPUTS	(3)
S4 main()
{
	S4 s4_t_i;	
	S4 s4_t_j;	
	S4 s4_tp_height[NUM_MOUNTAINS];
	U1 u1_t_delimiter;
	S4 s4_t_tmp;	
	
	for(s4_t_i = (S4)0; s4_t_i < (S4)NUM_MOUNTAINS; s4_t_i++)
	{
		s4_tp_height[s4_t_i] = (S4)INVALID_DATA;
	}
	
	for(s4_t_i = (S4)0; s4_t_i < (S4)NUM_MOUNTAINS; s4_t_i++)
	{
		(void)scanf(, &s4_tp_height[s4_t_i], &u1_t_delimiter);
	}
	
	for(s4_t_i = (S4)0; s4_t_i < (S4)NUM_MOUNTAINS; s4_t_i++)
	{
		for(s4_t_j = (S4)0; s4_t_j < (S4)NUM_MOUNTAINS - (S4)s4_t_i - (S4)1; s4_t_j++)
		{
			if(s4_tp_height[s4_t_j] < s4_tp_height[s4_t_j + 1])
			{
				s4_t_tmp = s4_tp_height[s4_t_j];
				s4_tp_height[s4_t_j] = s4_tp_height[s4_t_j + 1];
				s4_tp_height[s4_t_j + 1] = s4_t_tmp;
			}
		}
	}
	for(s4_t_i = (S4)0; s4_t_i < (S4)NUM_OUTPUTS; s4_t_i++)
	{
		printf(, s4_tp_height[s4_t_i]);
	}
	return ((S4)0);
}"
C,"#include<stdio.h>
#define compile 0
typedef unsigned long ULONG; 
ULONG func_euclides(ULONG num1, ULONG num2);
void func_output(ULONG num1, ULONG num2);
main()
{
	ULONG input1 = 0, input2 = 0, gcd = 0, lcm = 0; 
	while(scanf(, &input1, &input2) != EOF)
	{
		
		gcd = func_euclides(input1, input2);
		lcm = input1 * (input2 / gcd);
#if compile == 1
		printf(, input1, input2);
		printf(, lcm);
#endif
		func_output(gcd, lcm);
	}
	return 0;
}
ULONG func_euclides(ULONG num1, ULONG num2)
{
	ULONG quot = 0, sur = 0; 
	
	quot = num1 / num2;
	sur = num1 % num2;
	if(sur == 0)
	{
#if compile == 1
		printf(, num2);
#endif
		return num2;
	}
	else if(sur != 0)
	{
#if compile == 1
		printf(, num2, sur);
#endif
		func_euclides(num2, sur);
	}
}
void func_output(ULONG num1, ULONG num2)
{
	printf(, num1, num2);
}"
C,"#include<stdio.h>            
#include<string.h>           
int main(){                  
  char str[21];              
  int i,j;                   
  scanf(,str);           
  i=strlen(str);             
  for(j=i;j>0;j--){          
    printf(,str[j-1]);   
  }                          
  printf();              
  return(0);                 
}                            
                             "
C,"#include <stdio.h>
/*
??´?§?????§???¢
3????????£?????´??°?????\\?????????????????????????????????3?????¨??????????§???¢?????´?§?????§???¢??§????????´????????? YES ??????????????´????????? NO ??¨????????????????????°?????????????????????????????????
Input
?????°?????????????????????????????????????????????1?????????????????????????????°??? N ?????????????????????????¶??????? N ????????\\?????????????????????????????????3????????´??°???1????????????????????§????????????????????????????????????
Constraints
1 ? 1???????????? ? 1,000
N ? 1,000
Output
??????????????????????????¨??????YES ????????? NO ???1??????????????????????????????
*/
int main( void )
{
	int a, b, c, w, num, i;
	
	scanf( , &num );
	
	for ( i = 0 ; i < num ; i++) {
		scanf( , &a, &b, &c );
		if ( a < b ) {
			w = a;
			a = b;
			b = w;
		}
		
		if ( a < c ) {
			w = a;
			a = c;
			c = w;
		}
		
		if ( ( a * a ) == ( ( b * b ) + ( c * c ) ) ) {
			printf(  );
		}
		else {
			printf(  );
		}
	}
	
	return 0;
}"
C,"#include <stdio.h>
#include <string.h>
#define MAX 20
#ifdef DEBUG
#define DBGPRINTF(...) printf(__VA_ARGS__)
#else
#define DBGPRINTF(...)
#endif
int main( int argc, char *argv[] )
{
    int i, j, tmp, m[3], loopcount = 0, datanum, flag;
    char s[MAX];
    scanf( , &datanum );
    if ( datanum > 1000 ) datanum = 1000;
    DBGPRINTF( , datanum );
    while( ( fgets( s, MAX, stdin ) != NULL ) && ( loopcount < datanum ) )
    {
        DBGPRINTF( , s );
        if ( sscanf( s, , &m[0], &m[1], &m[2] ) == 3 )
        {
            DBGPRINTF( , m[0], m[1], m[2] );
            flag = 0;
            if ( ( m[0] >= m[1] ) && ( m[0] >= m[2] ) )
            {
                
                if ( m[0] * m[0] == m[1] * m[1] + m[2] * m[2] ) flag = 1;
                
            }
            else if ( ( m[1] >= m[0] ) && ( m[1] >= m[2] ) )
            {
                
                if ( m[1] * m[1] == m[0] * m[0] + m[2] * m[2] ) flag = 1;
            }
            else if ( ( m[2] >= m[0] ) && ( m[2] >= m[1] ) )
            {
                
                if ( m[2] * m[2] == m[0] * m[0] + m[1] * m[1] ) flag = 1;
            }
            else
            {
                
            }
            if ( flag > 0 ) 
            {
                printf(  );
            }
            else 
            {
                printf(  );
            }
            memset( s, 0, sizeof(s) );
        }
    }
    return 0;
}"
C,"#include<stdio.h>
#define SET_MAX 1024
void matrix_cal(double array[2][3]);
int main(void){
	double a, b, c, d, e, f;
	double array[SET_MAX][2][3];
	int set_cnt, i;
	for(set_cnt = 0;set_cnt < SET_MAX;set_cnt++){
		if(scanf(, &a, &b, &c, &d, &e, &f) == EOF)break;
		array[set_cnt][0][0] = a;
		array[set_cnt][0][1] = b;
		array[set_cnt][0][2] = c;
		array[set_cnt][1][0] = d;
		array[set_cnt][1][1] = e;
		array[set_cnt][1][2] = f;
	}
	for(i = 0;i < set_cnt;i++){
		matrix_cal(array[i]);
		printf(, array[i][0][2], array[i][1][2]);
	}
	return 0;
}
void matrix_cal(double array[2][3]){
	
	array[0][1] /= array[0][0];
	array[0][2] /= array[0][0];
	array[0][0] = 1.0;
	
	array[1][1] -= array[1][0] * array[0][1];
	array[1][2] -= array[1][0] * array[0][2];
	array[1][0] = 0.0;
	
	array[1][2] /= array[1][1];
	array[1][1] = 1.0;
	
	array[0][2] -= array[0][1] * array[1][2];
	array[0][1] = 0.0;
}"
C,"#include <stdio.h>
int gcd(int a, int b) {                                                         
    if (a % b == 0) {                                                           
        return b;                                                               
    } else {                                                                    
        return gcd(b, a % b);                                                   
    }                                                                           
}
int main(void) {                                                                
    int a, b;                                                                   
    int g;                                                                      
    int l;                                                                      
                                                                                
    while (scanf(, &a, &b) != EOF) {                                     
        if (a > b) {                                                            
            g = gcd(a, b);                                                      
        } else {                                                                
            g = gcd(b, a);                                                      
        }                                                                       
        l = (a / g) * b;                                                        
        printf(, g, l);                                                
    }                                                                           
    return 0;                                                                   
}"
C,"#include<stdio.h>
int main(void)
{
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    printf();
    
    return 0;
}"
C,"#include <stdio.h>
#include <stdlib.h>
#define FOR(variable,a,b) for(variable=(a);variable<(b);variable++)
int int_sort(const void* a, const void* b) {
    
    
    if(*(int* )a < *(int* )b) {
        return -1;
    } else {
        if(*(int* )a == *(int* )b) {
             return 0;
        }
    }
  return 1;
}
void intsort(int* target, int count) {
    qsort((void* )target, count, sizeof(target[0]), int_sort);
    return;
}
void reverse(int* target, int count) {
    int i;
    int swap;
    FOR(i, 0, count/2) {
        swap = target[i];
        target[i] = target[(count-1)-i];
        target[count-i] = swap;
    }
    return;
}
int main() {
    
    int i;
    int hight[10];
    
    FOR(i, 0, 10) {
        scanf(, &hight[i]);
    }
    
    intsort(hight, 10);
    reverse(hight, 10);
    FOR(i, 0, 3) {
    
    
        printf(, hight[i]);
    }
    return 0;
}"
C,"#include<stdio.h>
typedef int S4;
typedef unsigned char U1;
#define FALSE (0)
#define TRUE  (1)
#define MAX_INPUT_VALUE (1000) 
#define MAX_LINE_LENGTH	(1000) 
#define MIN_LINE_LENGTH	(1)		
#define NUM_LINE		(3)
static S4 s4_s_isRightTriangle(S4*);
S4 main()
{
	U1 u1_t_isComplete;
	S4 s4_t_dataNum;
	S4 s4_t_i;
	S4 s4_t_lines[NUM_LINE];
	S4 s4_t_result;
	u1_t_isComplete = (U1)FALSE;
	
	(void)scanf(, &s4_t_dataNum);
	if (s4_t_dataNum <= (S4)MAX_INPUT_VALUE)
	{
		for (s4_t_i = (S4)0; s4_t_i < s4_t_dataNum; s4_t_i++)
		{
			(void)scanf(, &s4_t_lines[0], &s4_t_lines[1], &s4_t_lines[2]);
			s4_t_result = s4_s_isRightTriangle(s4_t_lines);
			
			
			if (s4_t_result == (S4)TRUE)
			{
				printf();
			}
			else {
				printf();
			}
		}
	}
	return ((S4)0);
}
static S4 s4_s_isRightTriangle(S4* s4_a_lines)
{
	S4 s4_t_i;
	S4 s4_t_longestLine;
	S4 s4_t_longestLineNum;
	S4 s4_t_sum;
	S4 s4_t_rtn;
	s4_t_rtn = (S4)FALSE;
	
	s4_t_longestLine = s4_a_lines[0];
	s4_t_longestLineNum = (S4)0;
	for (s4_t_i = (S4)1; s4_t_i < (S4)NUM_LINE; s4_t_i++)
	{
		if (s4_t_longestLine < s4_a_lines[s4_t_i])
		{
			s4_t_longestLine = s4_a_lines[s4_t_i];
			s4_t_longestLineNum = s4_t_i;
		}
	}
	
	
	s4_t_longestLine = s4_t_longestLine * s4_t_longestLine;
	
	s4_a_lines[s4_t_longestLineNum] = (S4)0;
	s4_t_sum = s4_a_lines[0] * s4_a_lines[0] + s4_a_lines[1] * s4_a_lines[1] + s4_a_lines[2] * s4_a_lines[2];
	if (s4_t_longestLine == s4_t_sum)
	{
		s4_t_rtn = (S4)TRUE;
	}
	return(s4_t_rtn);
}"
C,"/*
 *  連立方程式
        ax + by = c
        dx + ey = f
    の解、x, y を出力して終了するプログラムを作成して下さい。
    a, b, c, d, e, f はそれぞれ、 -1000 以上 1000 以下の実数とし、連立方程式の解が一意に存在するように与えれれるものとします。
     
    Input
    複数のデータセットが与えられます。入力の最後まで処理して下さい。１つのデータセットが１行に与えられます。
    １つのデータセットに a, b, c, d, e, f が１つのスペースで区切られて与えられます。
     
    Output
    各データセットに対して、x, y を１つのスペースで区切って１行に出力して下さい。
    各値は小数点以下第３位まで出力して下さい。小数点以下第４位を四捨五入して下さい。
     
    x，yは以下の解法で求める
    x = (ce - fb) / (ae -bd)
    y = (cd - fa) / (bd - ae)
 
 */
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
    char buff[1000];
    int a, b, c, d, e, f;
    double x, y;
 
    while(fgets(buff, sizeof(buff), stdin) != NULL){
        if(sscanf(buff,(),
            &a, &b, &c, &d, &e, &f) != 6) exit(-1);
 
        if( a < -1000 || a > 1000 ||
            b < -1000 || b > 1000 ||
            c < -1000 || d > 1000 ||
            d < -1000 || d > 1000 ||
            e < -1000 || e > 1000 ||
            f < -1000 || f > 1000
            ) exit(-1);
 
        x = (double)(c*e - f*b) / (a*e - b*d);
        y = (double)(c*d - f*a) / (b*d - a*e);
 
        printf(,x  + 0.00001,y  + 0.00001);
    }
    return 0;
}"
C,"k;main(a,b){for(;k=~scanf(,&a,&b);printf(,a+b?floor(log10(a+b))+1:1.));}
 
 
 "
C,"#include <stdio.h>
#include <string.h>
#define N 2
int matrix(double **x);
 
int main(void){
	double x[N][N+1];
	double *y[N];
	double su1=0,su2=0;
	int i,j,k,n;
	char str[100],*line;
    
	for( ;fgets(str,sizeof(str),stdin)!=NULL; ){
		for(i=0;i<N;i++){
			for(j=0;j<N+1;j++){
				if(i==0 && j==0)
					line = strtok(str,);
				else
					line = strtok(NULL,);
				sscanf(line,,&n);
				x[i][j]=n;
			}
		}
		for(i=0;i<N;i++)
			y[i]=x[i];
		matrix(y);
		for(i=0;i<N;i++){
			if(i) printf();
			printf(,x[i][N]);
		}
		printf();
	}
	return 0;
}
int matrix(double **x){
	int i,j,k;
	double su1=0,su2=0;
	for(k=0;k<=N-2;k++){
		for(j=k+1;j<=N-1;j++){
			su1=x[k][k];
			su2=x[j][k];
			for(i=0;i<=2;i++){
				x[j][i]=x[j][i]-x[k][i]*su2/su1;
			}
		}
	}	
	for(k=0;k<=N-2;k++){
		for(j=k+1;j<=N-1;j++){
			su1=x[1-k][1-k];
			su2=x[1-j][1-k];
			for(i=0;i<=2;i++){
				x[1-j][i]=x[1-j][i]-x[1-k][i]*su2/su1;
			}
		}
	}
	su1=0;
	for(j=0;j<=N-1;j++){
	su1=x[j][j];
		for(i=0;i<=N;i++){
		x[j][i]=x[j][i]/su1;
		}	
	}
	return 0;
}"
C,"#include<stdio.h>
#define HEN_KAZU 3
int main(void)
{
        int i = 0, j = 0, k = 0;
        int n = 0, memo = 0;
        unsigned int hen[HEN_KAZU] = {0, 0, 0};
        scanf(,&n);
        for(k = 0; k < n; k++)
        {
                scanf(, &hen[0], &hen[1], &hen[2]);
                for(i = 0; i < HEN_KAZU; i++)
                {
                        for(j = i + 1; j < HEN_KAZU ;j++ )
                        {
                                if(hen[i] > hen[j])
                                {
                                        memo =  hen[i];
                                        hen[i] = hen[j];
                                        hen[j] = memo;
                                }
                        }
                }
                if(hen[2]*hen[2] == (hen[1] * hen[1]) + (hen[0] * hen[0]))
                {
                        printf();
                }
                else
                {
                        printf();
                }
        }
        return 0;
}"
C,"k;main(a,b){for(;k=~scanf(,&a,&b);printf(,(int)log10(a+b)+1));}
 
 
 "
C,"#include <stdio.h>
void judge_triangle(int side1, int side2, int side3);
int main(void)
{
    int i, j, number;/*submitすると、""code.c: In function ‘main’:
code.c:10:5: error: ‘for’ loop initial declarations are only allowed in C99 mode
code.c:10:5: note: use option -std=c99 or -std=gnu99 to compile your code
code.c:13:14: error: redefinition of ‘i’
code.c:10:14: note: previous definition of ‘i’ was here
code.c:13:5: error: ‘for’ loop initial declarations are only allowed in C99 mode""
と出るのでfor外でi,　jの宣言をしました。*/
    scanf(, &number);
    int side1[number], side2[number], side3[number];
    for (i = 0; i < number; i++) {
        scanf(, &side1[i], &side2[i], &side3[i]);
    }
    for (j = 0; j < number; j++) {
        judge_triangle(side1[j], side2[j], side3[j]);
    }
    return 0;
}
void judge_triangle(int side1, int side2, int side3)
{
    int shorter1, shorter2, longest;
    if(side1 <= side2) {
        shorter1 = side1;
        shorter2 = side2;
    } else {
        shorter1 = side2;
        shorter2 = side1;
    }
    if(shorter2 <= side3) {
        longest = side3;
    } else {
        longest = shorter2;
        shorter2 = side3;
    }
    if (longest * longest == shorter1 * shorter1 + shorter2 * shorter2) {
        printf();
    } else {
        printf();
    }
    return;
}"
C,"#include<stdio.h>
int main(void){
    int a,i,j,x,y,z,A,A2;
    scanf(,&a);
    for(i=0;i<a;i++){
        scanf(,&x,&y,&z);
        if(x<=y&&y<=z){
            A=z*z;
            A2=x*x+y*y;
            if(A==A2){
                printf();
            }else printf();
        }else if(x<=z&&z<=y){
            A=y*y;
            A2=x*x+z*z;
            if(A==A2){
                printf();
            }else printf();
        }else if(y<=x&&x<=z){
            A=z*z;
            A2=x*x+y*y;
            if(A==A2){
                printf();
            }else printf();
        }else if(y<=z&&z<=x){
            A=x*x;
            A2=z*z+y*y;
            if(A==A2){
                printf();
            }else printf();
        }else if(z<=y&&y<=x){
            A=x*x;
            A2=z*z+y*y;
            if(A==A2){
                printf();
            }else printf();
        }else if(z<=x&&x<=y){
            A=y*y;
            A2=x*x+z*z;
            if(A==A2){
                printf();
            }else printf();
        }
    }
return 0;
}"
C,"/*
10種の山の高さが与えられる。高い順に3つ出力せよ。
山の高さは10000以下とする。
やり方：
	・データを配列に入力する。
		・高さが10000を超えていた場合はやり直す。
	・降順に並べ替える。
	・0番目〜2番目までの3つを出力する。
	
結果：正解。
*/
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
int sort00(int data[],int n);
int maxindex00(int data[], int from, int to);
int main()
{
	int i;
	int data[1000];
	for(i=0; i<10; i++){
		scanf(,&data[i]);
		if(data[i]>10000){
			i--;
		}
	}
	sort00(data,10);
	for(i=0;i<3;i++){
		printf(,data[i]);
	}
	return 0;
}
int sort00(int data[],int n)
{
	int i,work,maxindex;
	for(i=0;i<n;i++){
		maxindex=maxindex00(data,i,n);
		work=data[i];
		data[i]=data[maxindex];
		data[maxindex]=work;
	}
	return;
}
int maxindex00(int data[], int from, int to)
{
	int i;
	int result=from;
	for(i=from;i<to;i++){
		if(data[result]<data[i]){
			result=i;
		}
	}
	return result;
}"
C,"#include<stdio.h>
typedef int S4;
typedef unsigned char U1;
#define FALSE (0)
#define TRUE  (1)
#define MAX_DIGIT (7)    
#define MIN_DIGIT (1)    
#define DIVID_NUM_FOR_LOWER_DIGIT (10) 
#define MAX_INPUT_VALUE (1000000) 
static S4 s4_s_calcDigit(S4 s4_a_inputNum);
S4 main() {
	S4 s4_t_a;
	S4 s4_t_b;
	U1 u1_t_delimiter;
	S4 s4_t_scanfRtn;
	S4 s4_t_sumInput;
	S4 s4_t_digit;
	U1 u1_t_isEnd;
	s4_t_scanfRtn = (S4)0;
	u1_t_isEnd = (U1)FALSE;
	while (u1_t_isEnd != (S4)TRUE)
	{
		s4_t_scanfRtn = scanf(, &s4_t_a, &s4_t_b, &u1_t_delimiter);
		if (s4_t_scanfRtn != (S4)EOF)
		{
			s4_t_sumInput = s4_t_a + s4_t_b;
			s4_t_digit = s4_s_calcDigit(s4_t_sumInput);
			printf(, s4_t_digit);
		}
		else
		{
			u1_t_isEnd = (U1)TRUE;
		}
	}
	return 0;
}
static S4 s4_s_calcDigit(S4 s4_a_inputNum)
{
	S4 s4_t_digit;
	S4 s4_t_maxNumOfDigit;
	U1 u1_t_isFinishCalc;
	u1_t_isFinishCalc = (U1)FALSE;
	s4_t_maxNumOfDigit = (S4)MAX_INPUT_VALUE;
	s4_t_digit = (S4)MAX_DIGIT;
	while ((s4_t_digit > (S4)MIN_DIGIT) &&
		(u1_t_isFinishCalc != (U1)TRUE))
	{
		if (s4_a_inputNum >= s4_t_maxNumOfDigit)
		{
			u1_t_isFinishCalc = (U1)TRUE;
		}
		else
		{
			s4_t_digit--;
			s4_t_maxNumOfDigit /= (S4)DIVID_NUM_FOR_LOWER_DIGIT;
		}
	}
	return (s4_t_digit);
}"
C,"a;main(b){for(;~scanf(,&a,&b);puts(&a))a=log10(a+b)+49;exit(0);}
 
 
 "
C,"#include <stdio.h>
void FuncQuickSortArray(int sample[], int left, int right);
void FuncSwap(int *x, int *y);
void FuncShowArray(int array[], int head, int tail);
void FuncQuickSortArray(int sample[], int left, int right)
{
  int pivot;
  int i, j;
  pivot = sample[(left + right) / 2];
  i = left;
  j = right;
  while (1) {
    while (sample[i] < pivot)
      i++;
    while (sample[j] > pivot)
      j--;
    if (i >= j)
      break;
    FuncSwap(&sample[i], &sample[j]);
    i++;
    j--;
  }
  if (left < (i - 1))
    FuncQuickSortArray(sample, left, i - 1);
  if ((j + 1) < right)
    FuncQuickSortArray(sample, j + 1, right);
}
void FuncSwap(int *x, int *y)
{
  int temp = *x;
  *x = *y;
  *y = temp;
}
void FuncShowArray(int array[], int head, int tail)
{
  int i;
  for (i = head; i <= tail; i++){
    if (i != tail) {
      printf(, array[i]);
    } else {
      printf(, array[i]);
    }
  }
}
int main(void)
{
  int height[10];
  int i;
  for (i = 0; i < 10; i++) {
    scanf(, &height[i]);
  }
  FuncQuickSortArray(height, 0, 10 - 1);
  for (i = 9; i >= 7; i--) {
    printf(, height[i]);
  }
  return 0;
}"
C,"#include<stdio.h>
#include<math.h>
#include<stdlib.h>
int min_yaku(long a, long max ,long b);
int main(void)
{
        unsigned long a = 0, b = 0, min = 0, max = 0;
        unsigned long i = 0 , r = 0, memoa=0,memob=0;
        while(scanf(, &a , &b) != EOF)
        {
                memoa = a;
                memob = b;
                if(a == b)
                {
                        max = a;
                        min = min_yaku(memoa, max, memob);
                        printf(, max, min);
                }
                else if(a != b)
                {
                        while(a != b)
                        {
                                r = abs(a - b);
                                a = b;
                                b = r;
                        }
                        max = a;
                        min = min_yaku(memoa, max, memob);
                        printf(, max, min);
                }
        }
        return 0;
}
int min_yaku(long a ,long max ,long b)
{
        long min=0;
        min = a / max * b;
        return min;
}"
C,"k;main(a,b){for(;k=~scanf(,&a,&b);printf(,a+b?(int)log10(a+b)+1:1));}
 
 
 "
C,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int main(int argc, const char * argv[]){
    int num,num2,num3;
    int count = 1;
    while(scanf(,&num,&num2) != -1){
        num3 = num + num2;
        while((num3 / 10) >= 1){
            num3 =  num3 / 10;
            count++;
        }
        printf(,count);
        count = 1;
    }
    
    return 0;
}"
C,"#include<stdio.h>
int
main(int argc, char *argv[])
{
        int n;
        char buf[5];
        int table[10][10][10][10];
        int i,j,k,l;
        int cnt;
        for (i = 0; i < 10; i++)
                for (j = 0; j < 10; j++)
                        for (k = 0; k < 10; k++)
                                for (l = 0; l < 10; l++)
                                        table[i][j][k][l] = i + j + k + l;
        while (fgets(buf, 5, stdin)) {
                sscanf(buf, , &n);
                if (n > 36) {
                        printf();
                        continue;
                }
                cnt = 0;
                for (i = 0; i < 10; i++)
                        for (j = 0; j < 10; j++)
                                for (k = 0; k < 10; k++)
                                        for (l = 0; l < 10; l++)
                                                if (table[i][j][k][l] == n) cnt++;
                printf(, cnt);
        }
        return 0;
}"
C,"#include<stdio.h>            
#include<string.h>           
int main(){                  
  char str[21];              
  int i,j;                   
  scanf(,str);           
  i=strlen(str);             
  for(j=i;j>0;j--){          
    printf(,str[j-1]);   
  }                          
  printf();              
  return(0);                 
}                            
                             "
C,"#include <stdio.h>
int main ( int argc, char **argv )
{
    char buffer[100];
    int input_size = 0;
    
    while ( fgets(buffer, 100, stdin) != NULL )
    {
        sscanf(buffer, , &input_size);
        int counter = 0;
        while ( counter < input_size )
        {
            int sides[3];
            int swap = 0;
            fgets(buffer, 100, stdin);
            sscanf(buffer, , &sides[0], &sides[1], &sides[2]);
            int x = 0;
            for ( x = 0; x < 3; x++ )
            {
                if ( x + 1 == 3 )
                {
                    break;
                }
                if ( sides[x] > sides [x + 1] )
                {
                    swap = sides[x];
                    sides[x] = sides[x+1];
                    sides[x+1] = swap;
                }
            }
            if ( (sides[0] * sides[0]) + (sides[1] * sides[1]) == (sides[2] * sides[2]) )
            {
                printf();
            }
            else
            {
                printf();
            }
            counter++;
        }
    }
    return 0;
}"
C,"#include <stdio.h>
#include <math.h>
int main(int argc, const char * argv[]) {
    int n, i, j, k;
    int count;
    int l[100000];
    
    while (scanf(, &n) != EOF) {
        count = 0;
        
        if (n >= 2){
            l[count++] = 2;
            
        }
        
        
        if (n >= 3) {
            l[count++] = 3;
            
            
            for (i = 5; i <= n; i+=2) {
                k = 0;
                
                for (j = 1; pow(l[j],2) <= i; j++) {
                    if (i % l[j] == 0) {
                        k = 1;
                        break;
                    }
                }
                
                if (k == 0){
                    l[count++] = i;
                    
                }
            }
        }
        printf(, count);
    }
    return 0;
}"
C,"#include <stdio.h>
#include <math.h>
double round_d(double x) {
    if ( x >= 0.0 ) {
        return floor(x + 0.5);
    } else {
        return -1.0 * floor(fabs(x) + 0.5);
    }
}
int main(){
double num1[10000],num2[10000],num3[10000],num4[10000],num5[10000],num6[10000],x=0.0,y=0.0;
int i,count=0;
for(i=0;i<10000;i++){
if(scanf(,&num1[i],&num2[i],&num3[i],&num4[i],&num5[i],&num6[i])==EOF)break;
count++;
}
for(i=0;i<count;i++){
if((num1[i]==0.0&&num4[i]==0.0)==1||(num2[i]==0.0&&num5[i]==0.0)==1||(num1[i]==0.0&&num2[i]==0.0)==1||(num4[i]==0.0&&num5[i]==0.0)==1||(num2[i]*num4[i]-num1[i]*num5[i])==0.0){}
else{
if(num1[i]==0.0){y=num3[i]/num2[i];x=num6[i]/num4[i]-num3[i]*num5[i]/(num2[i]*num4[i]);}
else if(num2[i]==0.0){x=num3[i]/num1[i];y=num6[i]/num5[i]-num3[i]*num4[i]/(num1[i]*num5[i]);}
else if(num4[i]==0.0){y=num6[i]/num5[i];x=num3[i]/num1[i]-num2[i]*num6[i]/(num1[i]*num5[i]);}
else if(num5[i]==0.0){x=num6[i]/num4[i];y=num3[i]/num2[i]-num1[i]*num6[i]/(num2[i]*num4[i]);}
else{
x=(num2[i]*num6[i]-num3[i]*num5[i])/(num2[i]*num4[i]-num1[i]*num5[i]);
x=round_d(x*1000.0)/1000.0;
y=(num1[i]*num6[i]-num3[i]*num4[i])/(num1[i]*num5[i]-num2[i]*num4[i]);
y=round_d(y*1000.0)/1000.0;
}
printf(,x,y);
}
}
return 0;
}"
C,"#include <stdio.h>
#include <math.h>
/*                                                                              
 *                                                                              
 */
int combi(int n, int x) {                                                       
    int i, count = 0;                                                           
    if (n > x * 9)                                                              
        return 0;                                                               
    if (x == 2) {                                                               
        if (n < 19)                                                             
            return 10 - abs(n - 9);                                             
        else                                                                    
            return 0;                                                           
    }                                                                           
    if (x == 1) {                                                               
        if (n < 9)                                                              
            return 1;                                                           
        else                                                                    
            return 0;                                                           
    }                                                                           
    for (i = 0; i <= n && i < 10 ; i++) {                                       
        count += combi(n - i, x - 1);                                           
    }                                                                           
                                                                                
    return count;                                                               
}
int main(void) {                                                                
    int n;                                                                      
                                                                                
    while(scanf(, &n) != EOF) {                                             
        printf(, combi(n, 4));                                            
    }                                                                           
                                                                                
    return 0;                                                                   
}"
C,"d;main(a,b){for(;d=~scanf(,&a,&b);puts(&d,d=(int)log10(a+b)+49));}
 
 
 "
C,"#include <stdio.h>
int main(int argc, const char * argv[])
{
    int i, j, k, datasets, max;
    int side[3];
    int num[2];
    int a, b, c;
    
    scanf(, &datasets);
    if (datasets > 1000) {
        exit(0);
    }
    for (i = 0; i < datasets; i++) {
        scanf(, &side[0], &side[1], &side[2]);
        if ((1 > side[0] && side[0] > 1000) || (1 > side[1] && side[1] > 1000) || (1 > side[2] && side[2] > 1000)) {
            exit(0);
        }
        
        for (j = 1, max = 0; j < 3; j++) {
            if(side[max] < side[j]) {
                max = j;
            }
        }
        
        k = 0;
        for (j = 0; j < 3; j++) {
            if(side[j] != side[max]) {
                num[k++] = j;
            }
        }
        c = side[max] * side[max];
        a = side[num[0]] * side[num[0]];
        b = side[num[1]] * side[num[1]];
        
        if (c == (a + b)) {
            printf();
        } else {
            printf();
        }
    }
    return 0;
}"
C,"#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define MAX 256
unsigned long euclid(unsigned long m, unsigned long n);
int main(){
    unsigned long a[1000],b[1000],gcd[1000],lcm[1000];
    int i,j,num;
    char str[MAX], *tp;
    
    while (fgets(str,MAX,stdin) != NULL)
    {
        tp = strtok(str, );
        a[i] = atoi(tp);
        tp = strtok(NULL, );
        b[i] = atoi(tp);
        i++;
    }
    
    for(j = 0; j < i; j++)
    {
        if (a[j] >= b[j])
        {
            gcd[j] = euclid(a[j],b[j]);
        }
        else
        {
            gcd[j] = euclid(b[j],a[j]);
        }
    }
    
    for(j = 0; j < i; j++)
    {
        lcm[j] = (a[j] * b[j]) / gcd[j];
    }
    
    for(j = 0; j < i; j++)
    {
        printf(,gcd[j],lcm[j]);
    }
    return 0;
}
unsigned long euclid(unsigned long m, unsigned long n)
{
    unsigned long tmp;
    while (n != 0)
    {
        tmp = n;
        n = m % n;
        m = tmp;
    }
    return m;
}"
C,"#include<stdio.h>
#include<stdlib.h>
int isRightTriangle(int a, int b, int c);
  
int main(){
  int i;
  int N;
  int a,b,c;
  int *ans;
  
  scanf(,&N);
  
  ans = (int *)malloc(sizeof(int) * N);
  
  for(i=0;i<N;i++){
    scanf(,&a, &b, &c);
    ans[i] = isRightTriangle(a, b, c); 
  }
  
  
  for(i=0; i<N; i++){
    if(ans[i] == 1){
      printf();
    }
    else{
      printf();
    }
  }
  free(ans);
  return 0;
}
int isRightTriangle(int n1, int n2, int n3){
  int a,b,c;
  
  if(n1 >= n2 && n1 >= n3){
    c=n1; a=n2; b=n3;
  }
  else if(n2 >= n1 && n2 >= n3){
    c=n2; a=n1; b=n3;
  }
  else{
    c=n3; a=n1; b=n2;
  }
  
  if(c*c == a*a + b*b){ 
    return 1;
  }
  else{                 
    return 0;
  }
}"
C,"#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define MAX 256
int main(){
    int side1[1000],side2[1000],side3[1000];
    int i,j,num;
    char str[MAX], *tp;
    i = 0;
    
    while (fgets(str,MAX,stdin) != NULL)
    {
        if (i == 0)
        {
            num = atoi(str);
            i++;
        }
        else
        {
            tp = strtok(str, );
            side1[i] = atoi(tp);
            tp = strtok(NULL, );
            side2[i] = atoi(tp);
            tp = strtok(NULL, );
            side3[i] = atoi(tp);
            i++;
        }
    }
    
    for(i = 1; i <= num; i++)
    {
        if (side1[i] <= side2[i])
        {
            if (side2[i] <= side3[i])
            {
                if (pow(side3[i],2.0) == pow(side1[i],2.0) + pow(side2[i],2.0))
                {
                    printf();
                }
                else
                {
                    printf();
                }
            }
            else
            {
                if (pow(side2[i],2.0) == pow(side1[i],2.0) + pow(side3[i],2.0))
                {
                    printf();
                }
                else
                {
                    printf();
                }
            }
        }
        else
        {
            if (side1[i] <= side3[i])
            {
                if (pow(side3[i],2.0) == pow(side1[i],2.0) + pow(side2[i],2.0))
                {
                    printf();
                }
                else
                {
                    printf();
                }
            }
            else
            {
                if (pow(side1[i],2.0) == pow(side2[i],2.0) + pow(side3[i],2.0))
                {
                    printf();
                }
                else
                {
                    printf();
                }
            }
        }
    }
    return 0;
}"
C,"#include<stdio.h>
#define N 10000
int* bubbleSort(int* list, int len){
  int i,j,temp;
  for(i=0; i<len; i++){
    for(j=len-1; j>i; j--){
      if(list[j] > list[j-1]){
        temp = list[j];
        list[j] = list[j-1];
        list[j-1] = temp;
      }
    }
  }
  
  
  
  return list;
}
int main(){
  int inputs[N];
  int *result;
  int number=0,i;
  int catchd = 1;
  for(i=0; i<N; i++){
    number = i;
    catchd = scanf(,&inputs[i]);
    if(catchd == EOF) break;
  }
  
  bubbleSort(inputs, number);
  printf(,inputs[0]);
  printf(,inputs[1]);
  printf(,inputs[2]);
  return 0;
}"
C,"#include <stdio.h>	
					
int main(){
	int a,b;
	int m,n;		
	int k;			
	int i;
	int GCD=1,LCM;	
	
	while(scanf(,&a,&b)!=EOF){
		if(b>a){	
			m=b;
			n=a;
		}else{
			m=a;
			n=b;
		}
		
		while(n!=0){	
			k=m%n;		
			m=n;		
			n=k;		
		}
		
		GCD=m;							
		LCM=a*(b/GCD);					
		
		printf(,GCD,LCM);
	}
	
	return 0;
}"
C,"#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define MAX 256
int main(){
    float a[1000],b[1000],c[1000],d[1000],e[1000],f[1000],x[1000],y[1000];
    int i,j,num;
    char str[MAX], *tp;
    i = 0;
    
    while (fgets(str,MAX,stdin) != NULL)
    {
        tp = strtok(str, );
        a[i] = atoi(tp);
        tp = strtok(NULL, );
        b[i] = atoi(tp);
        tp = strtok(NULL, );
        c[i] = atoi(tp);
        tp = strtok(NULL, );
        d[i] = atoi(tp);
        tp = strtok(NULL, );
        e[i] = atoi(tp);
        tp = strtok(NULL, );
        f[i] = atoi(tp);
        i++;
    }
    for (j = 0; j < i; j++)
    {
        if (a[j] >= d[j])
        {
            e[j] = e[j] - (b[j] * (d[j] / a[j]));
            f[j] = f[j] - (c[j] * (d[j] / a[j]));
            y[j] = f[j] / e[j];
            b[j] = b[j] * y[j];
            x[j] = (c[j] - b[j]) / a[j];
            x[j] = (roundf(x[j] * 1000)) / 1000;
            y[j] = (roundf(y[j] * 1000)) / 1000;
        }
        else
        {
            b[j] = b[j] - (e[j] * (a[j] / d[j]));
            c[j] = c[j] - (f[j] * (a[j] / d[j]));
            y[j] = c[j] / b[j];
            e[j] = e[j] * y[j];
            x[j] = (f[j] - e[j]) / d[j];
            x[j] = (roundf(x[j] * 1000)) / 1000;
            y[j] = (roundf(y[j] * 1000)) / 1000;
        }
    }
    
    for(j = 0; j < i; j++)
    {
        printf(,x[j],y[j]);
    }
    return 0;
}"
C,"/*
問題内容：
某国に住んでいる友達がお金に困って、あるヤミ金融業者から 10 万円の借金をしたまま、全く返済していないといいます。
この業者は、一週間ごとに 5% の利子を借金に加え、さらに借金の 1,000 円未満を切り上げます。
n を入力したとき、n 週間後の借金の残高を出力し終了するプログラムを作成して下さい。n は 100 以下とします。
・手順：
・第六回授業で使用したプログラムを再利用。
・変更点は、切り上げの部分。
・なぜか不正解。
*/
#include <stdio.h>
#include <math.h>
double ceil00(double n, int i);
int main()
{
	int n,i;
	double result=100000;
	while(1){
		scanf(,&n);
		if(0<n&&n<=100){			
			break;
		}
	}
	for(i=1; i<=n; i++){
		result+=(result*5/100);			
		result=ceil00(result,-3);
	}
	printf(,(int)result);
    return 0;
}
double ceil00(double n, int i)
{
	if(i==-5){
		n/=100000;
		n=ceil(n);
		n*=100000;
	}
	else if(i==-4){
		n/=10000;
		n=ceil(n);
		n*=10000;
	}
	else if(i==-3){
		n/=1000;
		n=ceil(n);
		n*=1000;
	}
	else if(i==-2){
		n/=100;
		n=ceil(n);
		n*=100;
	}
	else if(i==-1){
		n/=10;
		n=ceil(n);
		n*=10;
	}
	else if(i==1){
		n=ceil(n);
	}
	else if(i==2){
		n*=10;
		n=ceil(n);
		n/=10;
	}
	else if(i==3){
		n*=100;
		n=ceil(n);
		n/=100;
	}
	else if(i==4){
		n*=1000;
		n=ceil(n);
		n/=1000;
	}
	else if(i==5){
		n*=10000;
		n=ceil(n);
		n/=10000;
	}
	return n;
}"
C,"#include <stdio.h>
void ShowData(int x[], int n);
void Swap(int x[], int i, int j);
void QSort(int x[], int left, int right);
void Input(int x[], int n);
int main()
{
	int hight[10] = {0};
	int i;
	Input(hight, 10);
	QSort(hight, 0, 9);
	
	for (i = 9; i >= 7; i--) {
		printf(, hight[i]);
	}
	return 0;
}
void ShowData(int x[], int n)
{
	int i;
	for (i = 0; i < n; i++) {
		printf(, x[i]);
	}
	printf();
}
void Swap(int x[], int i, int j)
{
	int temp;
	temp = x[i];
	x[i] = x[j];
	x[j] = temp;
}
void QSort(int x[], int left, int right)
{
	int i, j;
	int pivot;
	
	i = left;
	j = right;
	pivot = x[(left + right) / 2];
	while (1) {
		while (x[i] < pivot) {
			i++;
		}
		while (x[j] > pivot) {
			j--;
		}
		if (i >= j) {
			break;
		}
		Swap(x, i, j);
		i++;
		j--;
	}
	if (left < i - 1)              
		QSort(x, left, i - 1);     
	if (j + 1 <  right)            
		QSort(x, j + 1, right);    
}
void Input(int x[], int n)
{
	int i;
	for (i = 0; i < n; i++) {
		scanf(, &x[i]);
	}
}"
C,"/* 1.Use the Euclidean algorithm to find GSD
   2.Use GSD to find LCM */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int GCD(int a , int b) 
{
    int i=0; 
    int temp=0; 
    for(i=0 ; (b!=0) ; i++)
    {
        temp = a%b;
        a = b;
        b = temp;
    }
    return a;
}
int LCM(int a ,int b ) 
{
    int gcdvalue=0;
    int factorA=0; 
    int factorB=0; 
    gcdvalue = GCD(a,b);
    factorA = a / gcdvalue;
    factorB = b / gcdvalue;
    return ( gcdvalue * factorA * factorB );
}
int main()
{
    int a=0 , b=0;
    
    while(scanf( ,&a,&b)!=EOF)
    {
     
     printf( ,GCD(a,b));
     
     printf( ,LCM(a,b));
    }
    return 0;
}"
C,"#include <stdio.h>
int main(void)
{
    int N,min,mid,max,l,i,j;
    
    scanf(,&N);
    for(i=0;i<N;i++)
    {
        min=0; mid=0; max=0;
        for(j=0;j<3;j++)
        {
            scanf(,&l);
            if(j==0)
            {
                min=l;
            }
            else if(j==1)
            {
                if(l<min)
                {
                    max=min; min=l;
                }
                else if(l>=min)
                {
                    max=l;
                }
            }
            else if(j==2)
            {
                if(l<min)
                {
                    mid=min; min=l;
                }
                else if(l>=min && l<max)
                {
                    mid=l;
                }
                else if(l>=max)
                {
                    mid=max; max=l;
                }
            }
        }
        if(min*min+mid*mid==max*max) printf();
        else printf();
    }
    
    return 0;
}"
C,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DBG 0
#define BUFSIZE 40
static short h[6];
int getSimEq() {
  char buf[BUFSIZE] = {0};
  char *p;
  int i, j;
  if (NULL == fgets(buf, BUFSIZE, stdin)) {
    if (DBG) {
      fprintf (stderr, );
    }
    return 0;
  }
  buf[strlen(buf)-1] = 0;
  if (DBG) {
    fprintf(stderr, , buf);
  }
  for (i=0, j=0, p = buf; j<6; j++, p = p+strlen(p)+1) {
    for (; buf[i] != ' ' && i<BUFSIZE; i++);
    buf[i] = 0;
    h[j] = atoi(p);
  }
  if (DBG) {
    fprintf(stderr, , h[0], h[1], h[2], h[3], h[4], h[5]);
  }
  return 1;
}
int main (void) {
  float x, y, detr;
  while (getSimEq()) {
    
    
    
    
    
    
    detr = 1.0/(h[0]*h[4]-h[1]*h[3]);
    x = detr * ( h[4]*h[2] - h[1]*h[5]);
    y = detr * (-h[3]*h[2] + h[0]*h[5]);
    
    if (x == 0) x = 0;
    if (y == 0) y = 0;
    printf (, x, y);
    if (DBG) {
      fprintf (stderr, , x, y);
    }
  }
  return 0;
}"
C,"/***************************************************************************************
 * There is a data which provides heights (in meter) of mountains.
 * The data is only for ten mountains.
 *
 * Write a program which prints heights of the top three mountains in descending order.
 ***************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DATA_SIZE   (10)
#define SEARCH_CNT  (3)
#define TOP3        (3)
static int* allocateInputData(size_t size);
static int* findTop3OfHeight(size_t size, const int *data);
static void putsData(const int *data);
static int cmp( const void *p, const void *q );
int main(void)
{
    int *vec = NULL;
    int *top3 = NULL;
    vec = allocateInputData(DATA_SIZE);
    top3 = findTop3OfHeight(TOP3, vec);
    putsData(top3);
    free(vec);
    free(top3);
    return 0;
}
static int* allocateInputData(size_t size)
{
    int i = 0;
    int *arr = (int *) malloc(size * sizeof(int));
    if ( NULL != arr ) {
        for (i = 0; i < DATA_SIZE; i++) {
            scanf(, &arr[i]);
        }
    }
    return arr;
}
static int* findTop3OfHeight(size_t size, const int *data)
{
    int i = 0;
    int *t = NULL;
    int *arr = NULL;
    if ( NULL != data) {
        t = (int *) malloc( DATA_SIZE * sizeof(int));
        for ( i = 0; i < DATA_SIZE; i++ ) {
            t[i] = data[i];
        }
        qsort(t, DATA_SIZE, sizeof(int), cmp);
        arr = (int *) malloc( size * sizeof(int));
        if ( NULL != arr ) {
            for ( i = 0; i < SEARCH_CNT; i++ ) {
                memcpy(&arr[i], &t[i], sizeof(int));
            }
        }
        free(t);
    }
    return arr;
}
static void putsData(const int *data)
{
    int i = 0;
    for ( i = 0; i < TOP3; i++ ) {
        printf( , data[i]);
    }
}
static int cmp( const void *p, const void *q )
{
    return *(int*)q - *(int*)p;
}"
C,"#include <stdio.h>
int main(){
        int a,b,c,i,j,k,x,N;
        int tri[3];
        scanf(, &N);
        for(i = 0; i < N; i++){
                scanf(, &tri[0], &tri[1], &tri[2]);
                                if(tri[0] > tri [1]){
                                        x = tri[0];
                                        tri[0] = tri[1];
                                        tri[1] = x;
                                }
                                if(tri[1] > tri[2]){
                                        x = tri[1];
                                        tri[1] = tri[2];
                                        tri[2] = x;
                                }
                                if(tri[0] > tri [1]){
                                        x = tri[0];
                                        tri[0] = tri[1];
                                        tri[1] = x;
                                }
                if(tri[0]*tri[0] + tri[1]*tri[1] == tri[2]*tri[2]){
                        printf();
                }else{
                        printf();
                }
        }
return 0;
}"
C,"#include <stdio.h>
#include <string.h>
/*                                                                              
int main(void) {                                                                
    char str[21];                                                               
    int i;                                                                      
                                                                                
    scanf(, str);                                                           
    for (i = strlen(str) - 1; i >= 0; i--) {                                    
        putchar(str[i]);                                                        
    }                                                                           
    putchar('\\n');                                                              
    return 0;                                                                   
}                                                                               
*/
int reverse() {                                                                 
    int c;                                                                      
    if ((c = getchar()) == '\\n')                                                
        return;                                                                 
    reverse();                                                                  
    putchar(c);                                                                 
}
int main(void) {                                                                
    reverse();                                                                  
    putchar('\\n');                                                              
    return 0;                                                                   }"
C,"#include <stdio.h>
unsigned long gcd(unsigned long a, unsigned long b);
unsigned long lcm(unsigned long a, unsigned long b, unsigned long g);
void swap(unsigned long *x, unsigned long *y)
{
  unsigned long tmp;
  tmp = *x;
  *x = *y;
  *y = tmp;
}
int main(void)
{
  unsigned long a[50], b[50];
  int i = 0;
  int n = 0;
  unsigned long gc[50], lc[50];
  while((scanf(, &a[i], &b[i])) != EOF){
    if((0 < a[i], b[i]) && (a[i], b[i] <= 2000000000)){
       i++;
       n++;
    }
    if(i > 50) break;
  }
  for(i = 0; i < n; i++){
    if(a[i] < b[i]) swap(&a[i], &b[i]);
    gc[i] = gcd(a[i], b[i]);
    lc[i] = lcm(a[i], b[i], gc[i]);
  }
  for(i = 0; i < n; i++){
    printf(, gc[i], lc[i]);
  }
    return 0;
}
unsigned long gcd(unsigned long a, unsigned long b)
{
  unsigned long r;
  if(a == b) return a;
  r = a%b;
  while(r != 0){
    a = b;
    b = r;
    r = a%b;
  }
  return b;
}
unsigned long lcm(unsigned long a, unsigned long b, unsigned long g)
{
  unsigned long l;
  l = (a*b)/g;
  return l;
}"
C,"#include<stdio.h>
int gcd(int x, int y);
int lcm(int x, int y, int g);
int main()
{
    int g,l,x,y;
    while (scanf(,&x,&y) != EOF){
    g=gcd(x,y);
    l=lcm(x,y,g);
    
    printf(,g,l);
    }
    return 0;
}
int gcd(int x, int y)
{
    int a,b,c,GCD;
    if(x > y){
            a=x;
            b=y;
            for(;;){
                c = a % b;
                if(a % b == 0){
                    GCD=b;
                    break;
                }
                a=b;
                b=c;
            }
        }
        else if(x < y){
            a=y;
            b=x;
            for(;;){
                c = a % b;
                if(a % b == 0){
                    GCD=b;
                    break;
                }
                a=b;
                b=c;
            }
        }
        else if(x == y){
            GCD=x;
        }
        return GCD;
}
int lcm(int x, int y, int g)
{
    int LCM;
    LCM=(x/g)*(y/g)*g;
    return LCM;
}"
C,"k;main(a,b){for(;k=~scanf(,&a,&b);printf(,(int)log10(a+b)+1));}
 
 
 "
C,"#include<stdio.h>
int main() {
  int N;       
  int a, b, c; 
  int san;     
  int i;
  
  scanf(, &N);
  for (i = 0; i < N; i ++) {
    
    scanf(, &a, &b, &c);
    
    if (a > 1000 || b > 1000 || c > 1000) {
      break;
    }
    
    san = 0;
    if (a * a == b * b + c * c) {
      san = 1;
      
      
    }
    if (b * b == c * c + a * a) {
      san = 1;
      
      
    }
    if (c * c == a * a + b * b) {
      san = 1;
      
      
    }
    
    if (san == 1) {
      printf();
    }
    else {
      printf();
    }
  }
  
  return 0;
}"
C,"#include <stdio.h>
#include <math.h>
int combi(int n, int x) {                                                                                                       
    int i, count = 0;                                                                                                           
    if (n > x * 9)                                                                                                              
        return 0;                                                                                                               
    if (x == 2) {                                                                                                               
        if (n < 19)                                                                                                             
            return 10 - abs(n - 9);                                                                                             
        else                                                                                                                    
            return 0;                                                                                                           
    }                                                                                                                           
                                                                                                                                
    for (i = 0; i <= n && i < 10 ; i++) {                                                                                       
        count += combi(n - i, x - 1);                                                                                           
    }                                                                                                                           
                                                                                                                                
    return count;                                                                                                               
}
int main(void) {                                                                                                                
    int n;                                                                                                                      
                                                                                                                                
    while(scanf(, &n) != EOF) {                                                                                             
        printf(, combi(n, 4));                                                                                            
    }                                                                                                                           
                                                                                                                                
    return 0;                                                                                                                   
}"
C,"#include<stdio.h>            
#include<string.h>           
int main(){                  
  char str[21];              
  int i,j;                   
  scanf(,str);           
  i=strlen(str);             
  for(j=i;j>0;j--){          
    printf(,str[j-1]);   
  }                          
  printf();              
  return(0);                 
}                            
                             "
C,"#include <stdio.h>
#include <string.h>
#define MAX 20
#ifdef DEBUG
#define DBGPRINTF(...) printf(__VA_ARGS__)
#else
#define DBGPRINTF(...)
#endif
int main( int argc, char *argv[] )
{
    int i, j, tmp, m[2], loopcount = 0, tencount;
    char s[MAX];
    {
        while( ( fgets( s, MAX, stdin ) != NULL ) && ( loopcount < 200 ) )
        {
            DBGPRINTF( , s );
            if ( sscanf( s, , &m[0], &m[1] ) == 2 )
            {
                DBGPRINTF( , m[0], m[1], m[0]+m[1] );
                tmp = m[0] + m[1];
                tencount = 0;
                for ( ; ; )
                {
                    tmp /= 10;
                    if ( tmp == 0 )
                    {
                        break;
                    }
                    else
                    {
                        tencount++;
                    }
                }
                printf( , tencount + 1 );
                loopcount++;
                memset( s, 0, sizeof(s) );
            }
        }
    }
    return 0;
}"
C,"d;main(a,b){for(;d=~scanf(,&a,&b);puts(&d,d=log10(a+b)+49));}
 
 
 "
C,"#include<stdio.h>
#include<math.h>
int main (void)
{
    int sets;
    scanf(,&sets);
    int a[1000][3];
    int b[1000][3] = {};
    int i;
    for(i = 0; i < sets; i++){
        scanf(,&a[i][0] ,&a[i][1] ,&a[i][2]);
        if((a[i][0] > a[i][1]) && (a[i][0] > a[i][2])){
            b[i][0] = 1;
        }else if((a[i][1] > a[i][0]) && (a[i][1] > a[i][2])){
            b[i][1] = 1;
        }else if((a[i][2] > a[i][0]) && (a[i][2] > a[i][1])){
            b[i][2] = 1;
        }
    }
    for(i = 0; i < sets; i++){
        
        if((b[i][0] == 1) && (a[i][0] * a[i][0] == a[i][1] * a[i][1] + a[i][2] * a[i][2]))
            printf();
        else if((b[i][1] == 1) && (a[i][1] * a[i][1] == a[i][0] * a[i][0] + a[i][2] * a[i][2]))
            printf();
        else if((b[i][2] == 1) && (a[i][2] * a[i][2] == a[i][0] * a[i][0] + a[i][1] * a[i][1]))
            printf();
        else
            printf();
    }
    return 0;
}"
C,"#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define U1 unsigned char
#define S1 char
#define	S4 int
#define S8 long
#define TRUE					(1)
#define FALSE					(0)
#define RATE_OF_INTEREST        (105)    
#define PERCENT                 (100)    
#define ROUNDUP_THRESHOLD       (1000)   
#define AMOUNT_OF_DEBT          (100000) 
S4 main(void)
{
	S4 s4_t_balance;	
	S4 s4_t_week;		
	S4 s4_t_cnt;		
	S4 s4_t_mod;		
	U1 u1_t_delimiter;	
	
	(void)scanf(, &s4_t_week, &u1_t_delimiter);
	
	s4_t_balance = (S4)AMOUNT_OF_DEBT;
	
	for (s4_t_cnt = (S4)0; s4_t_cnt < s4_t_week; s4_t_cnt++)
	{
		
		s4_t_balance = s4_t_balance * (S4)RATE_OF_INTEREST / (S4)PERCENT;
		
		s4_t_mod = s4_t_balance % (S4)ROUNDUP_THRESHOLD;
		if (s4_t_mod > (S4)0)
		{
			s4_t_balance = ((s4_t_balance / (S4)ROUNDUP_THRESHOLD) + (S4)1) * (S4)ROUNDUP_THRESHOLD;
		}
	}
	
	printf(, s4_t_balance);
	return((S4)0);
}"
C,"#include<stdio.h>
void qsort(int a[],int left,int right);
int partition(int a[],int left,int right);
void exchange(int *num1,int *num2);
int main(){
    int i;
   int size=10;
   int heigh[size];
   
   for(i=0;i<size;i++){
                       scanf(,&heigh[i]);
   }
   qsort(heigh,0,size-1);
   
   for(i=0;i<3;i++){
                       printf(,heigh[i]);
   }         getchar();getchar();
   
   return 0;
} 
void qsort(int a[],int left,int right){
     if(left<right){
                    int q;
                    q=partition(a,left,right);
                    qsort(a,left,q-1);
                    qsort(a,q+1,right);
     }
}
int partition(int a[],int left,int right){
    int x=a[right];
    int index=left-1;
    int i;
    
    for(i=left;i<right;i++){
                           if(a[i]>x)exchange(&a[++index],&a[i]);
    }
    
    exchange(&a[++index],&a[right]);
    
    return index;
}
void exchange(int *num1,int *num2){
     int t;
     t=*num1;
     *num1=*num2;
     *num2=t;
}"
C,"#include<stdio.h>            
#include<string.h>           
int main(){                  
  char str[21];              
  int i,j;                   
  scanf(,str);           
  i=strlen(str);             
  for(j=i;j>0;j--){          
    printf(,str[j-1]);   
  }                          
  printf();              
  return(0);                 
}                            
                             "
C,"#include<stdio.h>
#include<string.h>
struct LENGTH
{
	int length1;
	int length2;
	int length3;
};
int main()
{
	struct LENGTH length[1000];
	int count,set,change;
	scanf(,&set);
	for(count = 0;count<set;count++)
	{
		scanf(, &length[count].length1, &length[count].length2, &length[count].length3);
		if(length[count].length1<length[count].length3)
		{
			change = length[count].length1;
			length[count].length1 = length[count].length3;
			length[count].length3 = change;
		}
		if(length[count].length1<length[count].length2)
		{
			change = length[count].length1;
			length[count].length1 = length[count].length2;
			length[count].length2 = change;
		}
		if(length[count].length2<length[count].length3)
		{
			change = length[count].length2;
			length[count].length2 = length[count].length3;
			length[count].length3 = change;
		}
	}
	for(count=0;count<set;count++)
	{
		if((length[count].length1 * length[count].length1) == ((length[count].length2 * length[count].length2) + (length[count].length3 * length[count].length3)))
		{
			printf();
		}
		else
		{
			printf();
		}
	}
	return 0;
}"
C,"/*
1000 以下の３つの正の整数を入力し、
それぞれの長さを３辺とする三角形が直角三角形である場合には YES を、
違う場合には NO と出力して終了するプログラムを作成して下さい。
手順：
・データセット数nを入力
・x,y,rを入力
	・x,y,rのいずれかが1以上1000以下の範囲になければ、その入力はカウントしない。（i--）
・r^2==(x^2+y^2)なら、YES
	そうでなければ、NOを表示する。
・データセット数（n）回繰り返して終了。
・結果：Wrong answer
なぜか不正解。
3つの入力の内、x,y,rを切り替えられるようにしてみたが、やはり不正解。（x^2==(y^2+r^2)とか、y^2==(x^2+r^2)とか。)
*/
#include <stdio.h>
int main()
{
	int x[1000],y[1000],r[1000];
	int i,count=0;
	int n;
	while(1){
		scanf(,&n);
		if(n<=1000){
			break;
		}
	}
	for(i=0; i<n; i++){
		scanf(,&x[i],&y[i],&r[i]);
		if(x[i]<1||x[i]>1000||y[i]<1||y[i]>1000||r[i]<1||r[i]>1000){
			i--;
		}
	}
	for(i=0; i<n; i++){
		if(r[i]*r[i]==(x[i]*x[i])+(y[i]*y[i])){
			printf();
		}
		else if(x[i]*x[i]==(y[i]*y[i])+(r[i]*r[i])){
			printf();
		}
		else if(y[i]*y[i]==(x[i]*x[i])+(r[i]*r[i])){
			printf();
		}
		
		else{
			printf();
		}
	}
    return 0;
}"
C,"#include<stdio.h>
int main(){
  double a, b, c, d, e, f;
  double x,y;
  double ABSx, ABSy, tmp;
  while(scanf(,&a, &b, &c, &d, &e, &f) != EOF){
    /*
    if(b != 0.0){
      if(b*d-a*e != 0.0){
	x = (b*f-c*e)/(b*d-a*e);
	y = (c-a*x)/b;
      }
      else{
	
	return -1;
      }
    }
    
    else{
      if(a != 0.0){
	x = c/a;
	if(e != 0.0){
	  y = (f-d*x)/e;
	}
	else{
	  
	}
      }
      
      else{
	
	return -1;
      }
    }
    */
    y = (a*f-c*d)/(a*e-b*d);
    x = (c-b*y)/a;
    if(x > -0.0005 && x < 0) x = 0.0;
    if(y > -0.0005 && y < 0) y = 0.0;
    /*四捨五入
    ABSx = (x < 0)? -x : x;
    tmp = (ABSx - (double)(int)ABSx) * 1000;
    tmp = (double)(int)(tmp + 0.5); tmp = tmp/1000;
    x = (x < 0) ? -(double)(int)ABSx + tmp : (double)(int)ABSx + tmp;  
    ABSy = (y < 0)? -y : y;
    tmp = (ABSy - (double)(int)ABSy) * 1000;
    tmp = (double)(int)(tmp + 0.5); tmp = tmp/1000;
    y = (y < 0) ? -(double)(int)ABSy + tmp : (double)(int)ABSy + tmp;    
    */
    
    printf(,x ,y);
  }
  return 0;
}"
C,"#include <stdio.h>
#define MIN(a,b) (((a)>(b))?(b):(a))
#define MAX(a,b) (((a)>(b))?(a):(b))
int main(void)
{
    
    FILE *fin, *fout;
#ifdef DEBUG
    fin=fopen(,);
    fout=fopen(,);
#else
    fin=stdin; fout=stdout;
#endif
    
    while(feof(fin)==0){
        int a,b;
        fscanf(fin,,&a,&b);
        int i;
        
        int gcd=1;
        
        if(MAX(a,b)%MIN(a,b)==0){
            gcd=MIN(a,b);
        }
        
        else{
            for(i=MIN(a,b)/2;i>=1;i--){
                
                if(a%i==0 && b%i==0){ 
                    gcd=i;
                    break;
                }
            }
        }
        
        long long int lcm=gcd*(a/gcd)*(b/gcd);
        
        fprintf(fout,,gcd,lcm);
    }
    return 0;
}"
C,"#include <stdio.h>
int main(){
    
    int a,b,c,d,e,f,g,h,i,j;
    int n1,n2,n3;
    
    scanf(,&a);
    scanf(,&b);
    
    if(b > a){
        
        n1 = b;
        n2 = a;
        
    }else{
        
        n1 = a;
        n2 = b;
        
    }
    
    scanf(,&c);
    
    if(c > n1){
        
        n2 = n1;
        n1 = c;
        
    }else if(c > n2){
        
        n3 = n2;
        n2 = c;
        
    }else{
        
        n3 = c;
        
    }
    
    scanf(,&d);
    
    if(d > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = d;
        
    }else if(d > n2){
        
        n3 = n2;
        n2 = d;
        
    }else if(d > n3){
        
        n3 = d;
        
    }
    
    scanf(,&e);
    
    if(e > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = e;
        
    }else if(e > n2){
        
        n3 = n2;
        n2 = e;
        
    }else if(e > n3){
        
        n3 = e;
        
    }
    
    scanf(,&f);
    
    if(f > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = f;
           
    }else if(f > n2){
        
        n3 = n2;
        n2 = f;
        
    }else if(f > n3){
        
        n3 = f;
        
    }
    
    scanf(,&g);
    
    if(g > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = g;
        
    }else if(g > n2){
        
        n3 = n2;
        n2 = g;
        
    }else if(g > n3){
        
        n3 = g;
        
    }
    
    scanf(,&h);
    
 if(h > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = h;
        
    }else if(h > n2){
        
        n3 = n2;
        n2 = h;
        
    }else if(h > n3){
        
        n3 = h;
        
    }
    scanf(,&i);
    
     if(i > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = i;
        
    }else if(i > n2){
        
        n3 = n2;
        n2 = i;
        
    }else if(i > n3){
        
        n3 = i;
        
    }
    
    
    scanf(,&j);
    
     if(j > n1){
        
        n3 = n2;
        n2 = n1;
        n1 = j;
        
    }else if(j > n2){
        
        n3 = n2;
        n2 = j;
        
    }else if(j > n3){
        
        n3 = j;
        
    }
    
    
    printf(,n1);
    printf(,n2);
    printf(,n3);
    
    return 0;   
}"
C,"#include <stdio.h>
/*
?????°
???????????????2????????´??° a ??¨ b ??????????????°???????????????????????°?????????????????????????????????
Input
?????°????????????????????????????????????????????????????????????????????? 1 ???????????????????????????????????????????????????2????????´??° a ??¨ b ???1????????????????????§??????????????????????????????????????\\????????????????????§????????????????????????
Constraints
0 ? a, b ? 1,000,000
???????????????????????° ? 200
Output
??????????????????????????¨??????a+b ????????°???????????????????????????
*/
int digitNumber( int num )
{
	if ( num < 10 ) {
		return 1;
	}
	else if ( num < 100 ) {
		return 2;
	}
	else if ( num < 1000 ) {
		return 3;
	}
	else if ( num < 10000 ) {
		return 4;
	}
	else if ( num < 100000 ) {
		return 5;
	}
	else if ( num < 1000000 ) {
		return 6;
	}
	else {
		return 7;
	}
}
int main( void )
{
	int a, b;
	
	while(scanf(, &a, &b) != EOF) {
	
		printf( , digitNumber( a + b ) );
	}
	
	return 0;
}"
C,"#include <stdio.h>
/*
??£???????¨????
ax+by=c
dx+ey=f
????§£???x, y ???????????????????????°?????????????????????????????????a, b, c, d, e, f ??????
???????????? -1,000 ??\\??? 1,000 ??\\???????????°??¨????????£???????¨????????§£?????????????????¨
??????????????????????????????????????¨????????????
Input
?????°???????????????????????????????????????????????\\?????????????????§????????????????????????1??????
?????????????????????1???????????????????????????1??????????????????????????? a, b, c, d, e, f 
???1????????????????????§????????????????????????????????????
Output
????????????????????????????????????x, y ???1????????????????????§????????£???1?????????????????????
???????????????????°???°?????\\????¬¬3????????§?????????????????????????°???°?????\\????¬¬4???????????¨???
??\\??????????????????
*/
int main( void )
{
	int a, b, c, d, e, f;
	
	double x, y;
	
	while ( scanf( , &a, &b, &c, &d, &e, &f ) != EOF ) {
		
		x = ( double )( c * e - b * f ) / ( double )( a * e - b * d );
		y = ( double )( f * a - c * d ) / ( double )( a * e - d * b );
		
		if ( x == 0 ) {
			x = 0;
		}
		if ( y == 0 ) {
			y = 0;
		}
		
		printf( , x, y );
	
	}
	
	return 0;
}"
C,"#include<stdio.h>
int main() {
  double a, b, c; 
  double d, e, f; 
  
  while ((scanf(, &a, &b, &c, &d, &e, &f)) != EOF) {
    
    if (a < -1000 && a > 1000) break;
    if (b < -1000 && b > 1000) break;
    if (c < -1000 && c > 1000) break;
    if (d < -1000 && d > 1000) break;
    if (e < -1000 && e > 1000) break;
    if (f < -1000 && f > 1000) break;
    
    
    b = b / a;
    c = c / a;
    a = a / a; 
    
    
    
    
    e = e - b * d;
    f = f - c * d;
    d = d - a * d; 
    
    
    
    
    d = d / e;
    f = f / e;
    e = e / e; 
    
    
    
    
    a = a - d * b;
    c = c - f * b;
    b = b - e * b; 
    
    
    
    
    printf(, c, f);
  }
			
  
  return 0;
}"
C,"#include <stdio.h>
#include <stdlib.h>
typedef struct _digits{
    int a,b;
    struct _digits* next;
}digits_t;
digits_t* init_d(a,b)
{
    digits_t* d;
    d=(digits_t*)malloc(sizeof(digits_t));
    d->a=a; d->b=b;
    d->next=NULL;
    return d;
}
int get_digit(int x)
{
    int cnt=0;
    while(x){
        cnt++;
        x=x/10;
    }
    return cnt;
}
#ifdef __DEBUG_MODE__
#define dbg(fmt, ...)\\
    printf( fmt, __VA_ARGS__)
#else
#define dbg(fmt, ...) 
#endif
int main(void)
{
    int a,b;
    int cnt;
#ifndef __DEBUG_MODE__
    FILE* fp=stdin;
#else
    FILE* fp;
    fp=fopen(,);
#endif
    digits_t *start,*crnt;
    start=crnt=init_d(0,0);  
    while(feof(fp)==0){
        fscanf(fp,,&a,&b);
        crnt=crnt->next=init_d(a,b);
        dbg(,a,b);
        dbg(,ftell(fp));
    }
    for(crnt=start->next;crnt!=NULL;crnt=crnt->next){
        printf(,get_digit(crnt->a+crnt->b));
    }
    return 0;
}
               
    
    "
C,"#include <stdio.h>
int m1;
int m2;
int m3;
int m4;
int m5;
int m6;
int m7;
int m8;
int m9;
int m10;
int big=0;
int flag=0;
int main(void){
	
	scanf(,&m1);
	scanf(,&m2);
	scanf(,&m3);
	scanf(,&m4);
	scanf(,&m5);
	scanf(,&m6);
	scanf(,&m7);
	scanf(,&m8);
	scanf(,&m9);
	scanf(,&m10);
	for(;;){
		flag=0;
		if (m1<m2){
			big=m2;
			m2=m1;
			m1=big;
			flag=1;
					}
		if (m2<m3){
			big=m3;
			m3=m2;
			m2=big;
			flag=1;
					}
		if (m3<m4){
			big=m4;
			m4=m3;
			m3=big;
			flag=1;
					}
		if (m4<m5){
			big=m5;
			m5=m4;
			m4=big;
			flag=1;
					}
		if (m5<m6){
			big=m6;
			m6=m5;
			m5=big;
			flag=1;
					}
		if (m6<m7){
			big=m7;
			m7=m6;
			m6=big;
			flag=1;
					}
		if (m7<m8){
			big=m8;
			m8=m7;
			m7=big;
			flag=1;
					}
		if (m8<m9){
			big=m9;
			m9=m8;
			m8=big;
			flag=1;
					}
		if (m9<m10){
			big=m10;
			m10=m9;
			m9=big;
			flag=1;
					}
		if (flag==0)
			break;
		
				}
	printf(,m1);
	printf(,m2);
	printf(,m3);
	return 0;
}"
C,"#include <stdio.h>
#define MAX 10
#ifdef DEBUG
#define DBGPRINTF(...) printf(__VA_ARGS__)
#else
#define DBGPRINTF(...)
#endif
int main( int argc, char *argv[] )
{
    int i, j, tmp;
    int m[MAX] = { 0 };
    DBGPRINTF( , argc );
    {
        DBGPRINTF(  );
#if 0
        for ( i = 0; i < argc - 1; i++ )
        {
            DBGPRINTF(, argv[i + 1] );
            sscanf( argv[i + 1], , &m[i] );
            DBGPRINTF(, m[i] );
            DBGPRINTF(, argv[i + 1] );
        }
#else
        for ( i = 0; i < MAX; i++ )
        {
            scanf( , &m[i] );
        }
#endif
        DBGPRINTF(  );
        for ( i = 0; i < MAX - 1; i++ )
        {
            for ( j = 1; j < MAX; j++ )
            {
                DBGPRINTF( , j-1, m[j-1], j, m[j] );
                if ( m[ j - 1 ] < m[ j ] )
                {
                    tmp = m[ j - 1 ];
                    m[ j - 1 ] = m[ j ];
                    m[ j ] = tmp;
                }
            }
            DBGPRINTF(  );
            for ( j = 0; j < MAX; j++ )
            {
                DBGPRINTF(, m[ j ] );
            }
            DBGPRINTF(  );
        }
        DBGPRINTF(  );
        for ( i = 0; i < MAX; i++ )
        {
            DBGPRINTF( , m[ i ] );
        }
        DBGPRINTF(  );
        for ( i = 0; i < 3; i++ )
        {
            printf( , m[ i ] );
        }
        
    }
    return 0;
}"
C,"#include <stdio.h>
#include <string.h>
#define N 2
int matrix(double **x);
 
int main(void){
	double x[N][N+1];
	double *y[N];
	double su1=0,su2=0;
	int i,j,k,n;
	char str[100],*line;
    
	for( ;fgets(str,sizeof(str),stdin)!=NULL; ){
		for(i=0;i<(N+1)*N;i++){
			if(i==0)
				line = strtok(str,);
			else
				line = strtok(NULL,);
			sscanf(line,,&n);
			x[i/(N+1)][i%(N+1)]=n;
			
		}
		for(i=0;i<N;i++)
			y[i]=x[i];
		matrix(y);
		for(i=0;i<N;i++){
			if(i) printf();
			printf(,x[i][N]);
		}
		printf();
	}
	return 0;
}
int matrix(double **x){
	int i,j,k;
	double su1=0,su2=0;
	for(k=0;k<=N-2;k++){
		for(j=k+1;j<=N-1;j++){
			su1=x[k][k];
			su2=x[j][k];
			for(i=0;i<=N;i++){
				x[j][i]=x[j][i]-x[k][i]*su2/su1;
			}
		}
	}	
	for(k=0;k<=N-2;k++){
		for(j=k+1;j<=N-1;j++){
			su1=x[N-1-k][N-1-k];
			su2=x[N-1-j][N-1-k];
			for(i=0;i<=N;i++){
				x[N-1-j][i]=x[N-1-j][i]-x[N-1-k][i]*su2/su1;
			}
		}
	}
	su1=0;
	for(j=0;j<=N-1;j++){
	su1=x[j][j];
		for(i=0;i<=N;i++){
		x[j][i]=x[j][i]/su1;
		}	
	}
	return 0;
}"
C,"#include <stdio.h>
#include <math.h>
#define D(fmt,...) 
#define P(fmt,...) fprintf(stdout, fmt, ##__VA_ARGS__)
int gcd (int a, int b) {
  int small = a < b ? a : b;
  int big = a < b ? b : a;
  int gcd  = 1;
  int i = 1;
  for (i = 2; i < small; i++) {
    int countA = 0;
    while (small % i == 0) {
      countA++;
      small /= i;
    }
    int countB = 0;
    while (big % i == 0) {
      countB++;
      big /= i;
    }
    if (countA != 0 && countB != 0) {
      int count = countA < countB ? countA:countB;
      D(, i, count, floor(pow(i, count)));
      gcd *= floor(pow(i,count));
    }
    D(, i);
  }
  return gcd;
}
int lcm (int a, int b, int g) {
  int lcm = 0;
  int min = a < b ? a : b;
  int x = a / g;
  int y = b / g;
  return g * x * y;
}
		      
int main (int ac, char **av)
{
  while(feof(stdin) == 0) {
    int a, b = 0;
    fscanf(stdin, , &a, &b);
    int g = gcd(a, b);
    P(, g, lcm(a, b, g));
  }
  return 0;
}"
C,"#include<stdio.h>
#include<malloc.h>
void sweap(int *a,int *b){
    int t;
    t=*a,*a=*b,*b=t;
}
int main(){
    int *a,*b,*c,*n;
    a=(int *)malloc(sizeof(int));
    b=(int *)malloc(sizeof(int));
    c=(int *)malloc(sizeof(int));
    n=(int *)malloc(sizeof(int));
    scanf(,a,b,c,n);
    if(*a<*b)sweap(a,b);
    if(*b<*c)sweap(b,c);
    if(*c<*n)sweap(c,n);
    if(*a<*b)sweap(a,b);
    if(*b<*c)sweap(b,c);
    if(*a<*b)sweap(a,b);
    scanf(,n);
    if(*a<*n)sweap(a,n);
    if(*b<*n)sweap(b,n);
    if(*c<*n)sweap(c,n);
    scanf(,n);
    if(*a<*n)sweap(a,n);
    if(*b<*n)sweap(b,n);
    if(*c<*n)sweap(c,n);
    scanf(,n);
    if(*a<*n)sweap(a,n);
    if(*b<*n)sweap(b,n);
    if(*c<*n)sweap(c,n);
    scanf(,n);
    if(*a<*n)sweap(a,n);
    if(*b<*n)sweap(b,n);
    if(*c<*n)sweap(c,n);
    scanf(,n);
    if(*a<*n)sweap(a,n);
    if(*b<*n)sweap(b,n);
    if(*c<*n)sweap(c,n);
    scanf(,n);
    if(*a<*n)sweap(a,n);
    if(*b<*n)sweap(b,n);
    if(*c<*n)sweap(c,n);
    printf(,*a,*b,*c);
    return 0;
}"
C,"#include <stdio.h>                                                                     
#include <stdlib.h> 
 
void* smalloc ( size_t size ) 
{ 
    void* pntr = malloc( size );  
    if ( pntr == NULL ) 
    {   
        fputs( , stderr );  
        exit( EXIT_FAILURE );  
    }   
    return pntr; 
} 
 
void sorter ( int* data, int elements ) 
{ 
    int i, j, cmp, key; 
 
    for ( i = 0; i < elements; i++ ) 
    {   
        key = data[i]; 
 
        for ( j = i; j > 0; j-- ) 
        {   
            cmp = data[j - 1]; 
            if ( key < cmp ) 
            {   
                break; 
            }   
            else 
            {   
                data[j] = cmp; 
            }   
        }   
 
        data[j] = key; 
    }   
} 
 
int main ( void ) 
{ 
    int i; 
    int* data = (int*)smalloc( sizeof(int) * 10 ); 
 
    for ( i = 0; i < 10; i++ ) 
    { 
        scanf(, data + i); 
    } 
 
    sorter(data, 10); 
 
    for ( i = 0; i < 3; i++ ) 
    { 
        printf(, data[i]); 
    } 
 
    free(data); 
 
    return 0; 
}                                                                                      "
C,"k;main(a,b){for(;k=~scanf(,&a,&b);printf(,a+b?(int)log10(a+b)+1:14347389));}
 
 
 "
C,"#include <stdio.h>
int Maxcheck(int *p,int *q,int *r)
{
  int a,b,c;
  a=*p;b=*q;c=*r;
  int Max,m1,m2;
  if (a>b & a>c)
    {
      Max=a;m1=b;m2=c;
    }
  else if (b>c & b>a)
    {
      Max=b;m1=c;m2=a;
    }
  else if (c>a & c>b)
    {
      Max=c;m1=a;m2=b;
    }
  else if (a==b & b==c)
    {
      Max=a;m1=b;m2=c;
    }
  else if (a==b)
    {
      if (a>c)
        {
          Max=a;m1=b;m2=c;
        }
      else
        {
          Max=c;m1=a;m2=b;
        }
    }
  else if(b==c)
    if (a>b)
      {
        Max=a;m1=b;m2=c;
      }
    else
      {
        Max=c;m1=a;m2=b;
      }
  else if(c==a)
    if (a>b)
      {
        Max=a;m1=b;m2=c;
      }
    else
      {
        Max=b;m1=a;m2=b;
      }
  *p=Max;*q=m1;*r=m2;
}
int main(void)
{
  int n,i,p,q,r;
  scanf(,&n);
  for(i=0;i!=n;i++)
    {
      scanf(,&p,&q,&r);
      Maxcheck(&p,&q,&r);
      if (p*p==q*q+r*r)
        {
          printf();
        }
      else
        {
          printf();
        }
    }
  return 0;
}"
C,"#include<stdio.h>
#include<string.h>
int main(void)
{
  int i, j, k;
  double tmp;
  double a[2][3];
  double x[2];
  memset(a,0,sizeof(a));
  memset(x,0,sizeof(x));
  while(1){
	for (i = 0;i < 2;i++){
	  for (j = 0;j < 3;j++){
		if (scanf(, &a[i][j]) == EOF){
		  return 0;   
		}
	  }
	}
	for (i = 0;i < 2;i++){
	  if (a[i][i] == 0){
		for (j = i + 1;j < 2;j++){
		  if (a[j][i] != 0){
			for (k = 0;k < 2;k++){
			  tmp = a[i][k];
			  a[i][k] = a[j][k];
			  a[j][k] = tmp;
			}
			break;
		  }
		}
	  }
	}
	for (i = 0;i < 2;i++){
	  for (j = i + 1;j < 2;j++){
		tmp = a[j][i] / a[i][i];
		for (k = i;k < 3;k++){
		  a[j][k] -= a[i][k] * tmp;
		}
	  }
	}
	for (i = 2 - 1;i >= 0;i--){
	  for (j = 2;j > i + 1;j--){
		a[i][j-1] = a[i][j] - (x[j-1] * a[i][j-1]);
	  }
	  x[i] = a[i][i+1] / a[i][i];
	}
	for (i = 0;i < 2;i++){
	  if (i == 0){
		 printf(, x[i]);
	  }
	  else if (i == 1){
		printf(, x[i]);
	  }
	}
	printf();
	memset(a,0,sizeof(a));
	memset(x,0,sizeof(x));
  }
  return 0;
}"
C,"#include<stdio.h>
#include<stdlib.h>
void* cmalloc(int size, char* em){
	
	
	
	void* ob = malloc(size);
	if(ob == NULL){
		printf(, em);
		exit(0);
	}
    return ob;
}
void* crealloc(void* ob, int size, char* em){
	
	
	
	
	
	void* ret = realloc(ob, size);
	if(ret == NULL){
		printf(, em);
		exit(0);
	}
	return ret;
}
typedef struct {
	int* arp;
	int size;
	int stack_size;
}vector_i;
int* vector_i_at(const vector_i* ob, int idx){
	
	if(ob->size <= idx){
		printf();
		exit(0);
	}
	return (ob->arp + idx);
}
void vector_i_private_increase(vector_i* ob, int size){
	while(ob->stack_size < size)ob->stack_size *= 2;
}
void vector_i_constructor(vector_i* ob, int size){
	
	ob->size = size;
	ob->stack_size = 1;
	vector_i_private_increase(ob, size);
	ob->arp = cmalloc(sizeof(int) * ob->stack_size, );
	
	for(int i = 0; i < ob->size; i++){
		ob->arp[i] = 0;
	}
}
void vector_i_destructor(vector_i* ob){
	ob->size = 0;
	ob->stack_size = 0;
	free(ob->arp);
}
void vector_i_resize(vector_i* ob, int size){
	if(ob->size < size){
		ob->arp = crealloc(ob->arp, size, );
		
		for(int i = ob->size; i < size; i++){
			*(ob->arp + i) = 0;
		}
	}else {
		for(int i = size; i < ob->size; i++){
			*(ob->arp + i) = 0;
		}
	}
	ob->size = size;
}
int* vector_i_begin(vector_i* ob){
	return ob->arp;
}
int* vector_i_end(vector_i* ob){
	return (ob->arp + ob->size);
}
void vector_i_push_back(vector_i* ob, int val){
	if(ob->size == ob->stack_size){
		vector_i_private_increase(ob, ob->size + 1);
		ob->arp = crealloc(ob->arp, sizeof(int) * ob->stack_size, );
	}
	*(ob->arp + ob->size) = val;
	ob->size++;
}
int vector_i_pop_back(vector_i * ob){
	if(ob->size == 0){
		printf();
		exit(1);
	}
	ob->size--;
	int ret = ob->arp[ob->size];
	ob->arp[ob->size] = 0;
	return ret;
}
int comp(const int* a, const int* b){
	return *a - *b;
}
int main(){
	vector_i vi;
	vector_i_constructor(&vi, 0);
	
	for(int i = 0; i < 10; i++){
		int tmp;
		scanf(, &tmp);
		vector_i_push_back(&vi, tmp);
	}
	
	qsort(vector_i_begin(&vi), vi.size, sizeof(int), comp);
	
	for(int i = 9; i >= 7; i--)printf(, *vector_i_at(&vi, i));
	
	vector_i_destructor(&vi);
	return 0;
}"
D,"import std.stdio,std.string,std.conv,std.math;
immutable MIN = -1000;
immutable MAX = 1000;
int main(string[] argv)
{
    char[] buf;
	string[] ans;
	while(stdin.readln(buf)){
		if(checkSeak(buf)){
			double[] num;
			foreach(string str;buf.to!string().chomp().split()){
				num ~= str.to!double();
			}
			double x = (num[2] * num[4] - num[1] * num[5]) / (num[0] * num[4] - num[1] * num[3]);
			double y = (num[5] * num[0] - num[2] * num[3]) / (num[0] * num[4] - num[3] * num[1]);
			x = roundD(x,4);
			y = roundD(y,4);
			ans ~= format(,x,y).to!string(); 
		}
	}
	foreach(string str;ans){
		writeln(str);
	}
    return 0;
}
 
private bool checkLength(char[] c){
	if(c.split().length == 6){
		return true;
	}
	return false;
}
private bool checkRange(char[] c){
	try{
		foreach(string str;c.to!string().chomp().split()){
			double tmp = str.to!double();
			if (MIN <= tmp && tmp <= MAX){
			}else{
				return false;
			}
		}
	}
	catch(Exception ex){
		
		return false;
	}
	return true;
}
private bool checkSeak(char[] c){
	if(checkLength(c)){
		
	}else{
		return false;
	}
	if(checkRange(c)){
		
	}else{
		return false;
	}
	return true;
}
private double roundD(double d,uint i){
	double result = round(d * pow(10,i-1))/pow(10,i-1);
	if (result == -0) {
		return 0;
	}
	return result;
}"
D,"import std.stdio;
import std.ascii;
import std.range;
import std.array;
import std.functional;
import std.algorithm;
import std.conv;
import std.container;
import std.math;
import std.numeric;
import std.string;
import std.c.string;
import std.random;
import std.regex;
import std.typecons;
/* MInt : 閾ェ蜍輔〒MOD繧偵→繧区紛謨ー.
 *   菴ソ縺?→縺阪?邨先ァ矩?縺?ョ壽焚縺御ケ励ｋ縺薙→縺ォ縺ェ繧九?縺ァ豕ィ諢? */
const long MOD = long.max / 2;
struct MInt {
    long v;
    this(long v) {
        if (v < 0) v += ((-v) / MOD + 1) * MOD;
        if (v >= MOD) v %= MOD;
        this.v = v;
    }
    bool opEquals()(long x) const { return this.v == x; }
    bool opEquals()(auto ref const MInt x) const { return this.v == x.v; }
    long opCast(string type)() const { static if (type == ) { return v; } }
    
    
    string toString() const { return to!string(v); }
    MInt opAssign(long x) { this.v = MInt(x).v; return this; }
    MInt opAssign(in MInt x) { this.v = x.v; return this; }
    MInt opOpAssign(string op)(in MInt x) {
        static if (op == ) { this.v = (this.v + x.v) % MOD; return this; }
        else if (op == ) { this.v = (this.v + MOD - x.v) % MOD; return this; }
        else if (op == ) { this.v = (this.v * x.v) % MOD; return this; }
    }
    MInt opUnary(string op)() const {
        static if (op == ) { return MInt(MOD - this.v); }
    }
    MInt opBinary(string op)(long x) const {
        return mixin( ~ op ~ );
    }
    MInt opBinary(string op)(in MInt x) const {
        static if (op == ) {
            return MInt(this.v + x.v);
        } else if (op == ) {
            return this + (-x);
        } else if (op == ) {
            return MInt(this.v * x.v);
        } else if (op == ) {
            return this * x.inverse;
        }
    }
    static long extgcd(long a, long b, ref long x, ref long y) {
        long g = a; x = 1; y = 0;
        if (b != 0) {
            g = extgcd(b, a % b, y, x);
            y -= (a / b) * x;
        }
        return g;
    }
    MInt inverse() const {
        long x, y;
        if (extgcd(this.v, MOD, x, y) == 1) return MInt(x + MOD);
        return MInt(0);
    }
}
MInt fact(MInt x) {
    if (x == 0) return MInt(1);
    return x * fact(x - 1);
}
void main() {
    long N; scanf(, &N);
    writeln(fact(MInt(N)));
}"
D,"import std.stdio;
import std.conv;
import std.cstream;
import std.string;
import std.algorithm;
int Map[20][20];
int ms,wp;
int[] dx3 = [0,1,2,1,1,0,0,0,0,-1,-2,-1,-1];
int[] dy3 = [0,0,0,-1,1,-1,-2,1,2,0,0,1,-1];
int[] dx2 = [0,-1,-1,0,1,1,1,0,-1];
int[] dy2 = [0,0,-1,-1,-1,0,1,1,1];
int[] dx = [0,0,1,0,-1];
int[] dy = [0,1,0,-1,0];
void main(){
int x,y,size;
for(int i;i<20;i++)for(int j;j<20;j++)Map[i][j]=0;
wp = 100;
while(scanf(,&x,&y,&size) != EOF){
/+
x = to!(int)(op[0])-'0';
y = to!(int)(op[2])-'0';
size = to!(int)(op[4])-'0';
/+printf(,x,y,size);+/
+/
transaction(x,y,size);
}
/+
for(int i;i<10;i++){
for(int j;j<10;j++){
printf(,Map[i][j]);
}
printf();
}
+/
printf(,wp,ms);
}
void transaction(int x,int y,int size){
if(size == 3){
for(int i;i<dx3.length;i++){
if(0<=y+dy3[i] && y+dy3[i]<10 && 0<=x+dx3[i] && x+dx3[i] < 10){
if(Map[y+dy3[i]][x+dx3[i]] == 0)wp--;
Map[y+dy3[i]][x+dx3[i]]+=1;
if(ms < Map[y+dy3[i]][x+dx3[i]])ms = Map[y+dy3[i]][x+dx3[i]];
}
}
}
else if(size == 2){
for(int i;i<dx2.length;i++){
if(0<=y+dy2[i] && y+dy2[i]<10 && 0<=x+dx2[i] && x+dx2[i] < 10){
if(Map[y+dy2[i]][x+dx2[i]] == 0)wp--;
Map[y+dy2[i]][x+dx2[i]]+=1;
if(ms < Map[y+dy2[i]][x+dx2[i]])ms = Map[y+dy2[i]][x+dx2[i]];
}
}
}else{
for(int i;i<dx.length;i++){
if(0<=y+dy[i] && y+dy[i]<10 && 0<=x+dx[i] && x+dx[i] < 10){
if(Map[y+dy[i]][x+dx[i]] == 0)wp--;
Map[y+dy[i]][x+dx[i]]+=1;
if(ms < Map[y+dy[i]][x+dx[i]])ms = Map[y+dy[i]][x+dx[i]];
}
}
}
}"
D,"import std.stdio : write, writeln;
import std.array;
import std.range;
void main(){
	string[] str = readln.chomp.split();
	string ans;
	foreach(s; str){
		auto wd = s.split();
		foreach(w; wd){
			auto res = w.split();
			foreach(r; res){
				auto l = r.length;
				if(3<=l && l<=6){
					if(ans == ans.init){
						ans = r;
					}else{
						ans ~=  ~ r;
					}
				}
			}
		}
	}
	
	writeln = ans;
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio,std.conv,std.string;
void main(){
    bool[9][9] m;
    foreach(y;0..8){
        foreach(x,c;readln.chomp){
            m[y*2][1+x*2]=c=='1';
        }
        foreach(x,c;readln.chomp){
            m[y*2+1][x*2]=c=='1';
        }
    }
    int x,y,dir=6;
    while(true){
        final switch(dir){
            case 2:
                if(x!=8&&m[y][x+1]){
                    x+=2;
                    dir=6;
                    dir.p;
                }else if(y!=8&&m[y+1][x]){
                    y+=2;
                    dir.p;
                }else{
                    dir=4;
                }
                break;
            case 4:
                if(y!=8&&m[y+1][x]){
                    y+=2;
                    dir=2;
                    dir.p;
                }else if(x!=0&&m[y][x-1]){
                    x-=2;
                    dir.p;
                }else{
                    dir=8;
                }
                break;
            case 6:
                if(y!=0&&m[y-1][x]){
                    y-=2;
                    dir=8;
                    dir.p;
                }else if(x!=8&&m[y][x+1]){
                    x+=2;
                    dir.p;
                }else{
                    dir=2;
                }
                break;
            case 8:
                if(x!=0&&m[y][x-1]){
                    x-=2;
                    dir=4;
                    dir.p;
                }else if(y!=0&&m[y-1][x]){
                    y-=2;
                    dir.p;
                }else{
                    dir=6;
                }
        }
        if(!x&&!y)break;
    }
    writeln;
}
void p(int dir){
    final switch(dir){
        case 2:'D'.write;break;
        case 4:'L'.write;break;
        case 6:'R'.write;break;
        case 8:'U'.write;break;
    }
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
void main()
{
    foreach(s;stdin.byLine())
    {
        string i;
        foreach(c;s)
        {
            switch(c)
            {
            case ' ': i~=;break;
            case'\\'': i~=;break;
            case ',': i~=;break;
            case '-': i~=;break;
            case '.': i~=;break;
            case '?': i~=;break;
            case 'A': i~=;break;
            case 'B': i~=;break;
            case 'C': i~=;break;
            case 'D': i~=;break;
            case 'E': i~=;break;
            case 'F': i~=;break;
            case 'G': i~=;break;
            case 'H': i~=;break;
            case 'I': i~=;break;
            case 'J': i~=;break;
            case 'K': i~=;break;
            case 'L': i~=;break;
            case 'M': i~=;break;
            case 'N': i~=;break;
            case 'O': i~=;break;
            case 'P': i~=;break;
            case 'Q': i~=;break;
            case 'R': i~=;break;
            case 'S': i~=;break;
            case 'T': i~=;break;
            case 'U': i~=;break;
            case 'V': i~=;break;
            case 'W': i~=;break;
            case 'X': i~=;break;
            case 'Y': i~=;break;
            case 'Z': i~=;break;
            default: assert(false);break;
            }
        }
        i~='0'.repeat().take((5-i.length%5)%5).array();
        string t;
        foreach(c;0..i.length/5)
        {
            int v=0;
            foreach(b;i[c*5..(c+1)*5]) v=(v<<1)+(b-'0');
            t~=[v];
        }
        writeln(t);
    }
}"
D,"import std.stdio,std.string,std.conv;
int main()
{
	string[char] ID;
	ID[' '] = ;
	ID['\\''] = ;
	ID[','] = ;
	ID['-'] = ;
	ID['.'] = ;
	ID['?'] = ;
	ID['A'] = ;
	ID['B'] = ;
	ID['C'] = ;
	ID['D'] = ;
	ID['E'] = ;
	ID['F'] = ;
	ID['G'] = ;
	ID['H'] = ;
	ID['I'] = ;
	ID['J'] = ;
	ID['K'] = ;
	ID['L'] = ;
	ID['M'] = ;
	ID['N'] = ;
	ID['O'] = ;
	ID['P'] = ;
	ID['Q'] = ;
	ID['R'] = ;
	ID['S'] = ;
	ID['T'] = ;
	ID['U'] = ;
	ID['V'] = ;
	ID['W'] = ;
	ID['X'] = ;
	ID['Y'] = ;
	ID['Z'] = ;
	string[string] Id;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	Id[] = ;
	string s;
	string str = ;
	while((s = readln.chomp).length != 0)
	{
		foreach(i;0..s.length)
		{
			str ~= ID[s[i]];
		}
		while(str.length % 5 != 0)
		{
			str ~= ;
		}
		string ans = ;
		while(str.length != 0)
		{
			string temp = str[0..5];
			ans ~= Id[temp];
			str = str[5..$];
		}
		ans.writeln;
	}
	return 0;
}"
D,"import std.stdio : write, writeln;
import std.array;
import std.range;
import std.algorithm : filter;
int bs(int[] arr, int trg){
	int l = 0;
	int r = cast(int)(arr.length-1);
	
	while(true){
		int idx = (l+r)/2;
		
		if(trg<arr[idx]){
			r = idx-1;
		}else if(arr[idx]<trg){
			l = idx+1;
		}else{
			return idx;
		}
		
		if(r<l){ return -1; }
	}
}
void main(){
	while(true){
		int n = next!int();
		int m = next!int();
		
		if((n | m) == 0x00){
			return;
		}
		
		bool[int] set;
		foreach(i; n.iota){
			set[i] = true;
		}
		
		int buf=0;
		int trg=m-1;
		while(set.length>1){
			int[] d = set.keys;
			int idx = bs(d.sort, trg);
			assert(idx!=-1);
			int nei = d[(idx+1)%d.length];
			set.remove(trg);
			
			d = set.keys;
			idx = bs(d.sort, nei);
			idx+=m-1;
			idx%=d.length;
			
			debug(1){
				dbg(d[idx]+1, trg+1, set.keys.sort);
				readln;
			}
			
			trg = d[idx];
		}
		
		(set.keys[0]+1).writeln;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"module AOJ_Volume0026;
import std.stdio,std.string,std.conv,std.algorithm;
int f[10][10];
bool checkf(int x,int y)
{
	if(0 <= x && x < 10 && 0 <= y && y < 10)
	{
		return true;
	}
	else
	{
		return false;
	}
}
void dropInk(int x,int y,int size)
{
	if(size == 1)
	{
		f[x][y]++;
		if(checkf(x+1,y)) f[x+1][y]++;
		if(checkf(x-1,y)) f[x-1][y]++;
		if(checkf(x,y+1)) f[x][y+1]++;
		if(checkf(x,y-1)) f[x][y-1]++;
	}
	else if(size == 2)
	{
		foreach(i;-1..2)
		{
			foreach(j;-1..2)
			{
				if(checkf(x+i,y+j)) f[x+i][y+j]++;
			}
		}
	}
	else if(size == 3)
	{
		foreach(i;-1..2)
		{
			foreach(j;-1..2)
			{
				if(checkf(x+i,y+j)) f[x+i][y+j]++;
			}
		}
		if(checkf(x+2,y)) f[x+2][y]++;
		if(checkf(x-2,y)) f[x-2][y]++;
		if(checkf(x,y+2)) f[x][y+2]++;
		if(checkf(x,y-2)) f[x][y-2]++;
	}
}
int main()
{
	foreach(i;0..10)
	{
		foreach(j;0..10)
		{
			f[i][j] = 0;
		}
	}
	string s;
	while((s = readln.chomp).length != 0)
	{
		string[] _s = s.split();
		int x = _s[0].to!int;
		int y = _s[1].to!int;
		int size = _s[2].to!int;
		
		dropInk(y,x,size);
	}
	
	int count = 0;
	int ans = 0;
	foreach(i;0..10)
	{
		foreach(j;0..10)
		{
			if(f[i][j] == 0)
			{
				count++;
			}
			ans = max(ans,f[i][j]);
		}
	}
	
	writeln(count);
	writeln(ans);
	return 0;
}"
D,"import std.stdio, std.string, std.conv, std.algorithm;
void main()
{
	while(true) {
		auto input = readln.chomp.split();
		int[] hand;
		foreach(e; input)
			hand ~= e.to!int;
		if(!hand.length)
			break;
		hand.sort();
		(new PokerHand(hand)).hand.writeln;
	}
}
class PokerHand
{
	int[] cards;
	string hand;
	this(int[] cards)
	in
	{
		assert(cards.length == 5);
		assert(cards.isSorted);
	}
	body
	{
		this.cards = cards.dup;
		hand = getHandName();
	}
	private string getHandName()
	{
		if(isFourCard)
			return ;
		else if(isFullHouse)
			return ;
		else if(isStraight)
			return ;
		else if(isThreeCard)
			return ;
		else if(isTwoPair)
			return ;
		else if(isOnePair)
			return ;
		else
			return ;
	}
	private bool isFourCard()
	{
		return maxNumOfSameCards == 4;
	}
	private bool isFullHouse()
	{
		return isThreeCard && isOnePair;
	}
	private bool isStraight()
	{
		static immutable bloadway = [1, 10, 11, 12, 13];
		bool _isStraight()
		{
			bool f = true;
			for(int i = 0; i < cards.length - 1 && f; i++)
				f = cards[i + 1] - cards[i] == 1;
			return f;
		}
		return _isStraight() || cards == bloadway;
	}
	private bool isThreeCard()
	{
		return maxNumOfSameCards == 3;
	}
	private bool isTwoPair()
	{
		return numOfPairs == 2;
	}
	
	private bool isOnePair()
	{
		return numOfPairs == 1;
	}
	private int numOfPairs()
	{
		int[14] nums;
		foreach(card; cards)
			nums[card]++;
		auto cnt = 0;
		foreach(num; nums)
			if(num == 2)
				cnt++;
		return cnt;
	}
	private int maxNumOfSameCards()
	{
		int[14] nums;
		foreach(card; cards)
			nums[card]++;
		return max(nums);
	}
	private int max(int[] arr...)
	{
		int max = 0;
		foreach(v; arr)
			max = v > max ? v : max;
		return max;
	}
}"
D,"import std.stdio;
import std.array;
import std.conv;
import std.string;
import std.algorithm;
void main()
{
    while (true) {
        auto cards = readln.chomp.split().map!(to!int).array;
        
        if(!cards.length) break;
        cards.sort.hand.writeln;
    }
}
string hand(int[] cards){
    if(cards[0] == cards[1] && cards[1] == cards[2] && cards[2] == cards[3] ||
       cards[1] == cards[2] && cards[2] == cards[3] && cards[3] == cards[4]) {
        return ;
    }else if(cards[0] == cards[1] && cards[1] == cards[2] && cards[3] == cards[4] ||
             cards[0] == cards[1] && cards[2] == cards[3] && cards[3] == cards[4]){
        return ;
    }else if(cards[0] == 1 && cards[1] == 10 && cards[2] == 11 && cards[3] == 12 && cards[4] == 13 ||
             cards[1] == cards[0] + 1 && cards[2] == cards[0] + 2 && cards[3] == cards[0] + 3 && cards[4] == cards[0] + 4) {
        return ;
    }else if(cards[0] == cards[1] && cards[1] == cards[2] ||
             cards[1] == cards[2] && cards[2] == cards[3] ||
             cards[2] == cards[3] && cards[3] == cards[4]) {
        return ;
    }else if(cards[0] == cards[1] && cards[2] == cards[3] ||
             cards[0] == cards[1] && cards[3] == cards[4] ||
             cards[1] == cards[2] && cards[3] == cards[4]) {
        return ;
    }else if(cards[0] == cards[1] ||
             cards[1] == cards[2] ||
             cards[2] == cards[3] ||
             cards[3] == cards[4]) {
        return ;
    }else{
        return ;
    }
}"
D,"import std.stdio,
       std.string,
       std.conv,
       std.algorithm;
void main() {
    auto flag = true;
    int[][] a, b;
    while(!stdin.eof) {
        auto input = readln.chomp;
        if(input.length) {
            auto arr = function int[](string s) {
                    int[] ret;
                    foreach(c; s) {
                        ret ~= c.to!int - 48;
                    }
                    return ret;
                }(input);
            if(flag)
                a ~= arr, flag = !flag;
            else
                b ~= arr, flag = !flag;
        }
    }
    long h = b.length, w = a[0].length;
    long x = 0, y = 0;
    auto d = 'R';
    while(1) {
        switch(d) {
            case 'R':
                if(y - 1 >= 0 && b[y - 1][x])
                    y--, d = 'U';
                else if(x < w && a[y][x]) {
                    x++;
                }
                else if(y < h && b[y][x])
                    y++, d = 'D';
                else
                    x--, d = 'L';
                break;
            case 'U':
                if(x - 1 >= 0 && a[y][x - 1])
                    x--, d = 'L';
                else if(y - 1 >= 0 && b[y - 1][x])
                    y--;
                else if(x < w && a[y][x])
                    x++, d = 'R';
                else
                    y++, d = 'D';
                break;
            case 'L':
                if(y < h && b[y][x])
                    y++, d = 'D';
                else if(x - 1 >= 0 && a[y][x - 1])
                    x--;
                else if(y - 1 >= 0 && b[y - 1][x])
                    y--, d = 'U';
                else
                    x++, d = 'R';
                break;
            case 'D':
                if(x < w && a[y][x])
                    x++, d = 'R';
                else if(y < h && b[y][x])
                    y++;
                else if(x - 1 >= 0 && a[y][x - 1])
                    x--, d = 'L';
                else
                    y--, d = 'U';
                break;
            default:
                return;
        }
        d.write;
        if(x == 0 && y == 0)
            break;
    }
    writeln;
}"
D,"import std.stdio : writeln, writefln;
import std.array;
import std.range;
import std.algorithm : filter;
import std.math : sqrt;
void main(){
	double[2][1000+1] LUT;
	LUT[2][0] = 1.00;
	LUT[2][1] = 1.00;
	for(int i=3; i<=1000; ++i){
		double x = LUT[i-1][0];
		double y = LUT[i-1][1];
		double[2] v = [-y, x];				
		double r = 1.0/sqrt(v[0]*v[0] + v[1]*v[1]);	
		
		LUT[i][0] = r*v[0] + x;
		LUT[i][1] = r*v[1] + y;
	}
	debug(1){
	for(int i=2; i<=6; ++i){
		writefln(, LUT[i][0], LUT[i][1]);
	}
	}
	
	while(true){
		int n = next!int();
		if(n==-1){ break; }
		
		writefln(, LUT[n][0]);
		writefln(, LUT[n][1]);
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio : writefln;
import std.array;
import std.range;
import std.algorithm : filter;
void main(){
	while(true){
		int h = next!int();
		int m = next!int();
		int s = next!int();
		if(filter!(a => a == -1)([h, m, s]).array.length == 3){ break; }
		
		int rest = 2*60*60 - (h*60*60 + m*60 + s);
		writefln(, rest/(60*60), (rest%(60*60))/60, ((rest%(60*60))%60));
		
		rest = 2*60*60*3 - (h*60*60 + m*60 + s)*3;
		writefln(, rest/(60*60), (rest%(60*60))/60, ((rest%(60*60))%60));
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.typecons;
import std.algorithm;
import std.conv;
import std.math;
import std.string;
import std.array;
struct Point {
  double x, y;
  double dot(Point a) {return x * a.x + y * a.y;}
  double cross(Point a) {return x * a.y - y * a.x;}
  Point opBinary(string s)(Point p) if (s == ) {p.x += x; p.y += y; return p;}
  Point opBinary(string s)(Point p) if (s == ) {
    p.x = x - p.x;
    p.y = y - p.y;
    return p;
  }
}
double ccw(Point p1, Point p2, Point p3) {
  return - (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p3.x - p1.x);
}
Point[] max_convex_full(Point[] points) {
  Point[] res = new Point[](points.length * 2);
  sort!((a, b) {
      if (a.x != b.x)  return a.x < b.x;
      return a.y < b.y;
    })(points);
  uint k = 0;
  
  for(int i = 0; i < points.length; i++) {
    while(k >= 2 && ccw(res[k - 2], res[k - 1], points[i]) <= 0) k--;
    res[k++] = points[i];
  }
  
  for(int i = cast(int)points.length - 2, t = k + 1; i >= 0; i--) {
    while(k >= t && ccw(res[k - 2], res[k - 1], points[i]) <= 0) k--;
    res[k++] = points[i];
  }
  res.length = k - 1;
  return res;
}
void main() {
  while(true) {
    int n = readln.chomp.to!(int);
    if (n == 0) break;
    Point[] points;
    foreach(t; 0..n) {
      auto line = readln.chomp.split().map!(to!(double)).array;
      points ~= Point(line[0], line[1]);
    }
    (points.length - points.max_convex_full.length).writeln;
  }
}"
D,"import std.stdio, std.array, std.conv, std.string;
void main()
{
	string[] input;
	solve: while(!stdin.eof()) {
		input = readln.split();
		if(input.length != 8) return;
		auto inx = new double[](4);
		auto iny = new double[](4);
		for(int i = 0; i < 4; i++)
		{
			inx[i] = input[2 * i].chomp.to!double;
			iny[i] = input[2 * i + 1].chomp.to!double;
		}
		for(int xi = 0; xi < 4; xi++)
		{
			double[] x;
			double[] y;
			double xp, yp;
			for(int i = 0; i < 4; i++)
			{
				if(i == xi)
				{
					xp = inx[i];
					yp = iny[i];
					continue;
				}
					
				x ~= inx[i];
				y ~= iny[i];
			}
			bool l;
			bool r;
			l = r = false;
		
			x ~= x[0];
			y ~= y[0];
		
			bool isConvex = false;
			for(int i = 0; i < 3; i++) {
				double ax = x[i+1] - x[i];
				double ay = y[i+1] - y[i];
				double px = xp - x[i];
				double py = yp - y[i];
				if(ax*py - ay*px < 0)
					r = true;
				else
					l = true;
			}
			if(l != r)
			{
				.writeln;
				continue solve;
			}
				
		}
		.writeln;
		
    }
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
int calc(int x, char op, int y)
{
    switch(op)
    {
    case '+': return x+y;
    case '-': return x-y;
    case '*':
    default:  return x*y;
    }
}
string solve(int[] a, int[] b)
{
    if(b is null)
    {
        string c = ;
        foreach(c1;c)
            foreach(c2;c)
                foreach(c3;c)
                {
                    auto w = a.map!(to!string).array();
                    if(10==calc(a[0],c1,calc(a[1],c2,calc(a[2],c3,a[3]))))
                        return w[0]~[c1]~~w[1]~[c2]~~w[2]~[c3]~w[3]~;
                    if(10==calc(a[0],c1,calc(calc(a[1],c2,a[2]),c3,a[3])))
                        return w[0]~[c1]~~w[1]~[c2]~w[2]~~[c3]~w[3]~;
                    if(10==calc(calc(a[0],c1,a[1]),c2,calc(a[2],c3,a[3])))
                        return ~w[0]~[c1]~w[1]~~[c2]~~w[2]~[c3]~w[3]~;
                    if(10==calc(calc(calc(a[0],c1,a[1]),c2,a[2]),c3,a[3]))
                        return ~w[0]~[c1]~w[1]~~[c2]~w[2]~~[c3]~w[3];
                    if(10==calc(calc(a[0],c1,calc(a[1],c2,a[2])),c3,a[3]))
                        return ~w[0]~[c1]~~w[1]~[c2]~w[2]~~[c3]~w[3];
                }
        return [];
    }
    foreach(i;0..b.length)
    {
        auto r = solve(a~b[i],b[0..i]~b[i+1..$]);
        if(r !is null)
            return r;
    }
    return [];
}
void main()
{
    foreach(vs;stdin.byLine().map!(s=>s.split().map!(to!int).array())())
    {
        if(vs.all!()) break;
        auto r = solve([],vs);
        writeln(r is null?:r);
    }
}"
D,"import std.stdio : writeln, write;
import std.array;
import std.range;
int n;
int m;
int star;
int d;
bool[][] map;
int[] dir = [-1, 0];
int[] solve(){
	int[] foot;
	int a = m;
	for(int i=0; i<d; ++i){
		if(map[i][a]){
			++a;
		}else if(map[i][a-1]){
			--a;
		}
		foot ~= a;
	}
	if(a == star) return [0];
	
	debug{foot.dbg;}
	
	bool[][] tmp = map.clone;
	
	a = m;
	for(int i=0; i<d; ++i){
		if(a==foot[i]){
			debug {(i+1).dbg;}
			for(int j=0; j<2; ++j){
				map = tmp.clone;
				map[i][dir[j]+a] = true;
				debug{map[i].dbg;}
				
				bool f = false;
				f |= map[i][0];
				for(int k=1; k<n; ++k){
					f |= map[i][k] && map[i][k+1];
				}
				f |= map[i][n];
				if(!f){
					int ptr = a;
					debug{ dbg(, ptr, , dir[j]); }
					if(j==0){
						--ptr;
					}else{
						++ptr;
					}
					for(int k=i+1; k<d; ++k){
						debug{ dbg(, ptr); }
						if(map[k][ptr]){
							++ptr;
						}else if(map[k][ptr-1]){
							--ptr;
						}
					}
					debug{ dbg(, ptr); }
					
					if(ptr == star){
						return [i+1, a+dir[j]];
					}else{
						debug {dbg(, i+1, a+dir[j]);}
					}
				}else{
					debug {dbg();}
				}
			}
		}else{
			a=foot[i];
		}
	}
	return [1];
}
void main(){
	while(true){
		n.next;
	
		if(n==0)break;
		m.next;
		star.next;
		d.next;
		
		for(int i=0; i<d; ++i) map.nmap;
		
		debug{ map.dbg; }
		
		auto ans = solve;
		for(int i=0; i<ans.length; ++i){
			write = ans[i];
			if(i+1<ans.length){
				write = ;
			}
		}
		writeln;
		
		map = map.init;
	}
}
void nmap(ref bool[][] m){
	string str = readln.chomp;
	bool[] m_;
	m_ ~= false;
	foreach(c; str){
		m_ ~= c=='1';
	}
	m_ ~= false;
	m ~= m_;
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	if(input.length==0){
		input ~= readln.chomp.split(delim);
	}
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.string;
import std.conv;
import std.typecons;
import std.algorithm;
import std.functional;
import std.bigint;
import std.numeric;
import std.array;
import std.math;
import std.range;
import std.container;
struct Pos{int x, y;}
void main() {
    int size = 8;
    int N = readln.chomp.to!int;
    foreach(i; 0..N) {
        writeln(~(i+1).to!string~);
        readln;
        int[][] grid = new int[][](size, size);
        foreach(j; 0..size) {
            grid[j] = readln.chomp.map!(a => a=='0' ? 0:1).array;
        }
        Pos s;
        s.x = readln.chomp.to!int-1;
        s.y = readln.chomp.to!int-1;
        grid[s.y][s.x] = 0;
        auto list = DList!Pos(s);
        int[] dx = [1,2,3,-1,-2,-3,0,0,0,0,0,0];
        int[] dy = [0,0,0,0,0,0,1,2,3,-1,-2,-3];
        while (!list.empty) {
            Pos p = list.front;
            list.removeFront;
            foreach(j; 0..dx.length) {
                Pos _p = Pos(p.x+dx[j], p.y+dy[j]);
                if (0<=_p.x && _p.x<size && 0<=_p.y && _p.y<size) {
                    if (grid[_p.y][_p.x] == 1) {
                        grid[_p.y][_p.x] = 0;
                        list.insertBack(_p);
                    }
                }
            }
        }
        grid.map!(a => reduce!((b,c)=>b~c.to!string)(, a)).each!writeln;
    }
}"
D,"import std.stdio;
import std.string;
import std.conv;
import std.algorithm;
import std.array;
const int[] type_small  = [0, 9, 10, 11, 20];
const int[] type_middle = [0, 1, 2, 10, 11, 12, 20, 21, 22];
const int[] type_big    = [0, 9, 10, 11, 18, 19, 20, 21, 22, 29, 30, 31, 40];
const int[] center = [10, 11, 20];
const int[] type_max = [20, 22, 40];
bool search_pos(int[] field, int start, ref int[][] pos, int drops) {
  foreach(i; start..100) {
    if (field[i] >= 1) {
      foreach(int index, type; [type_small, type_middle, type_big]) {
        
        if ((type_max[index] + i) < field.length && find!((x) => field[i + x] == 0)(type).array == []) {
          auto new_pos = pos ~ [index, center[index] + i];
          foreach(ref k; type) field[k + i] -= 1;
          bool result = search_pos(field, i, new_pos, drops);
          if (result && new_pos.length == drops) {
            pos = new_pos;
            return true;
          }
          foreach(ref k; type) field[k + i] += 1;
        }
      }
      return false;
    }
  }
  return true;
}
void main() {
  int drops = readln.chomp.to!(int);
  int[] field;
  foreach(i; 0..10) {
    field ~= readln.chomp.split().map!(to!(int)).array;
  }
  int[][] pos;
  if (!search_pos(field, 0, pos, drops)) throw new Exception();
  foreach(p; pos) {
    writefln(, p[1] % 10, p[1] / 10, p[0] + 1);
  }
}"
D,"import std.stdio,std.string,std.conv,std.array;
void main(){
	int[4][] data;
	for(int i=0;;i++){
		auto rd = readln().chomp();
		if(rd){
			data.length = i+1;
			auto abcd = split(rd);
			data[i][0] = to!int(abcd[0]);
			data[i][1] = to!int(abcd[1]);
			data[i][2] = to!int(abcd[2]);
			data[i][3] = to!int(abcd[3]);
		}else{
			break;
		}
	}
	for( int i=0;i<data.length;i+=2 ){
		int hit=0;
		if( data[i][0] == data[i+1][0] ){	hit+=1;	}
		if( data[i][1] == data[i+1][1] ){	hit+=1;	}
		if( data[i][2] == data[i+1][2] ){	hit+=1;	}
		if( data[i][3] == data[i+1][3] ){	hit+=1;	}
		write( hit ,  );
		int blow=0;
		if( data[i][0] == data[i+1][1] ){	blow+=1;	}
		if( data[i][0] == data[i+1][2] ){	blow+=1;	}
		if( data[i][0] == data[i+1][3] ){	blow+=1;	}
		
		if( data[i][1] == data[i+1][0] ){	blow+=1;	}
		if( data[i][1] == data[i+1][2] ){	blow+=1;	}
		if( data[i][1] == data[i+1][3] ){	blow+=1;	}
		if( data[i][2] == data[i+1][0] ){	blow+=1;	}
		if( data[i][2] == data[i+1][1] ){	blow+=1;	}
		if( data[i][2] == data[i+1][3] ){	blow+=1;	}
		
		if( data[i][3] == data[i+1][0] ){	blow+=1;	}
		if( data[i][3] == data[i+1][1] ){	blow+=1;	}
		if( data[i][3] == data[i+1][2] ){	blow+=1;	}
		writeln( blow );
	}
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
int calc(int x, char op, int y)
{
    switch(op)
    {
    case '+': return x+y;
    case '-': return x-y;
    case '*':
    default:  return x*y;
    }
}
string dfs(int[] vs, string[] e)
{
    if(vs.length==1) return vs[0]==10?e[0]:[];
    foreach(i;1..vs.length)
        foreach(op;)
        {
            auto r = dfs(vs[0..i-1]~[calc(vs[i-1],op,vs[i])]~vs[i+1..$],
                         e[0..i-1]~[~e[i-1]~[op]~e[i]~]~e[i+1..$]);
            if(r !is null) return r;
        }
    return [];
}
string solve(int[] a, int[] b)
{
    if(b is null)
        return dfs(a,a.map!(to!string).array());
    foreach(i;0..b.length)
    {
        auto r = solve(a~b[i],b[0..i]~b[i+1..$]);
        if(r !is null)
            return r;
    }
    return [];
}
void main()
{
    foreach(vs;stdin.byLine().map!(s=>s.split().map!(to!int).array())())
    {
        if(vs.all!()) break;
        auto r = solve([],vs);
        writeln(r is null?:r);
    }
}"
D,"import std.stdio : writeln, writefln;
import std.array;
import std.range;
import std.math : fabs;
void swap(T)(ref T a, ref T b){
	T tmp = a;
	a = b;
	b = tmp;
}
void main(){
	while(true){
		int q = next!int();
		if(q==-1) break;
		
		double x = q/2.;
		while(true){
			if(fabs(x*x*x -q) < q*0.00001){
				break;
			}
			x = x - (x*x*x -q)/(3.*x*x);
		}
		writefln(, x);
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.conv;
import std.range;
import std.array;
import std.string;
import std.algorithm;
bool is_correct(uint[] nums, bool comb2, uint index, uint rest) {
  if (rest == 0) {
    if (comb2) return true;
    else return false;
  }
  if (nums[index] == 0)
    return is_correct(nums, comb2, index + 1, rest);
  if (nums[index] == 3) {
    nums[index] -= 3;
    if (is_correct(nums, comb2, index, rest - 3)) return true;
    nums[index] += 3;
  }
  if (nums[index] == 2) {
    if (!comb2) {
      nums[index] -= 2;
      if (is_correct(nums, true, index, rest - 2)) return true;
      nums[index] += 2;
    }
  }
  if (index + 2 < nums.length && nums[index] >= 1 && nums[index + 1] >= 1 && nums[index + 2] >= 1) {
    nums[index..(index + 3)] = nums[index..(index + 3)].map!((x) => x - 1).array;
    if (is_correct(nums, comb2, index, rest - 3)) return true;
    nums[index..(index + 3)] = nums[index..(index + 3)].map!((x) => x + 1).array;
  }
  return false;  
}
void main() {
  while(true) {
    string line = readln.chomp;
    if (stdin.eof) break;
    auto nums = line.dup.map!((x) => x.to!(uint) - '0').array;
    uint[] table = new uint[](9);
    uint[] ans = [];
    foreach(n; nums) table[n - 1]++;
    foreach(i; 0..9) {
      table[i]++;
      if (reduce!((max, x) => (max > x) ? max : x)(0, table) > 4) {
        table[i]--;
        continue;
      }
      else if (is_correct(table.dup, false, 0, 14)) ans ~= i;
      table[i]--;
    }
    if (ans == []) writeln(0);
    else ans.map!((x) => (x + 1).to!(string)).join().writeln;
  }
}"
D,"import std.stdio : write, writeln;
import std.array;
import std.range;
void main(){
	const heisei = 19890108;
	const showa = 19261225;
	const taisho = 19120730;
	const meiji = 18680908;
	while(hasNext){
		string y = next!string();
		string m = next!string();
		string d = next!string();
		
		if(m.length<2){
			m =  ~ m;
		}
		if(d.length<2){
			d =  ~ d;
		}
		
		int a = (y ~ m ~ d).to!int;
		
		if(heisei <= a){
			writeln = heisei.stringof ~  ~ (y.to!int - heisei.to!string.take(4).array.to!int + 1).to!string ~  ~ m.to!int.to!string ~  ~ d.to!int.to!string;
		}else if(showa <= a){
			writeln = showa.stringof ~  ~ (y.to!int - showa.to!string.take(4).array.to!int + 1).to!string ~  ~ m.to!int.to!string ~  ~ d.to!int.to!string;
		}else if(taisho <= a){
			writeln = taisho.stringof ~  ~ (y.to!int - taisho.to!string.take(4).array.to!int + 1).to!string ~  ~ m.to!int.to!string ~  ~ d.to!int.to!string;
		}else if(meiji <= a){
			writeln = meiji.stringof ~  ~ (y.to!int - meiji.to!string.take(4).array.to!int + 1).to!string ~  ~ m.to!int.to!string ~  ~ d.to!int.to!string;
		}else{
			writeln = ;
		}
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio : write, writeln;
import std.array;
import std.range;
const int INF = 1<<28;
void swap(T)(ref T a, ref T b){
	T tmp = a;
	a = b;
	b = tmp;
}
void main(){
	while(hasNext){
		int[8] p;
		foreach(ref v; p){
			v.next;
		}
		
		int[] c = [1, 4, 1, 4, 1, 2, 1, 2];
		int[8] best;
		int min_ = INF;
		for(int i=0; i<8; ++i){
			int sum = 0;
			for(int j=0; j<8; ++j){
				int v = p[j]-c[j];
				if(v>0){
					sum += v;
				}
			}
			
			if(sum < min_){
				min_ = sum;
				best = c;
			}else if(sum == min_){
				int a, b;
				for(int j=0; j<8; ++j){
					a += a*10 + best[j];
				}
				for(int j=0; j<8; ++j){
					b += b*10 + c[j];
				}
				if(b<a){
					best = c;
				}
			}
			c ~= c.front;
			c.popFront;
		}
		for(int i=0; i<8; ++i){
			write = best[i];
			if(i+1<8){
				write = ;
			}
		}
		write = ;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"/+ dub.sdl:
    name 
    dependency  version=
+/
import std.stdio, std.algorithm, std.range, std.conv;
bool solve() {
    alias P = Point2D!double;
    P[] pol = new P[3];
    P p;
    foreach (i; 0..3) {
        double x, y;
        if (sc.read(x, y) != 2) return false;
        pol[i] = P(x, y);
    }
    double x, y;
    sc.read(x, y);
    p = P(x, y);
    if (contains(pol, p) == 2) {
        writeln();
    } else {
        writeln();
    }
    return true;
}
int main() {
    EPS!double = 1e-10;
    while (solve()) {}
    return 0;
}
Scanner sc;
static this() {
    sc = new Scanner(stdin);
}
 
class Scanner {
    import std.stdio : File;
    import std.conv : to;
    import std.range : front, popFront, array, ElementType;
    import std.array : split;
    import std.traits : isSomeChar, isStaticArray, isArray; 
    import std.algorithm : map;
    File f;
    this(File f) {
        this.f = f;
    }
    char[512] lineBuf;
    char[] line;
    private bool succW() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (!line.empty && line.front.isWhite) {
            line.popFront;
        }
        return !line.empty;
    }
    private bool succ() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (true) {
            while (!line.empty && line.front.isWhite) {
                line.popFront;
            }
            if (!line.empty) break;
            line = lineBuf[];
            f.readln(line);
            if (!line.length) return false;
        }
        return true;
    }
    private bool readSingle(T)(ref T x) {
        import std.algorithm : findSplitBefore;
        import std.string : strip;
        import std.conv : parse;
        if (!succ()) return false;
        static if (isArray!T) {
            alias E = ElementType!T;
            static if (isSomeChar!E) {
                 
                 
                auto r = line.findSplitBefore();
                x = r[0].strip.dup;
                line = r[1];
            } else static if (isStaticArray!T) {
                foreach (i; 0..T.length) {
                    bool f = succW();
                    assert(f);
                    x[i] = line.parse!E;
                }
            } else {
                FastAppender!(E[]) buf;
                while (succW()) {
                    buf ~= line.parse!E;
                }
                x = buf.data;
            }
        } else {
            x = line.parse!T;
        }
        return true;
    }
    int read(T, Args...)(ref T x, auto ref Args args) {
        if (!readSingle(x)) return 0;
        static if (args.length == 0) {
            return 1;
        } else {
            return 1 + read(args);
        }
    }
}
 
 
 
 
T[N] fixed(T, size_t N)(T[N] a) {return a;}
 
 
 
struct FastAppender(A, size_t MIN = 4) {
    import std.algorithm : max;
    import std.conv;
    import std.range.primitives : ElementEncodingType;
    import core.stdc.string : memcpy;
    private alias T = ElementEncodingType!A;
    private T* _data;
    private uint len, cap;
     
    @property size_t length() const {return len;}
    bool empty() const { return len == 0; }
     
    void reserve(size_t nlen) {
        import core.memory : GC;
        if (nlen <= cap) return;
        
        void* nx = GC.malloc(nlen * T.sizeof);
        cap = nlen.to!uint;
        if (len) memcpy(nx, _data, len * T.sizeof);
        _data = cast(T*)(nx);
    }
    void free() {
        import core.memory : GC;
        GC.free(_data);
    }
     
    void opOpAssign(string op : )(T item) {
        if (len == cap) {
            reserve(max(MIN, cap*2));
        }
        _data[len++] = item;
    }
     
    void insertBack(T item) {
        this ~= item;
    }
     
    void removeBack() {
        len--;
    }
     
    void clear() {
        len = 0;
    }
    ref inout(T) back() inout { assert(len); return _data[len-1]; }
    ref inout(T) opIndex(size_t i) inout { return _data[i]; }
     
    T[] data() {
        return (_data) ? _data[0..len] : null;
    }
}
 
 
 
static if (__VERSION__ <= 2070) {
    /*
    Copied by https:
    Copyright: Andrei Alexandrescu 2008-.
    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
    */
    template fold(fun...) if (fun.length >= 1) {
        auto fold(R, S...)(R r, S seed) {
            import std.algorithm : reduce;
            static if (S.length < 2) {
                return reduce!fun(seed, r);
            } else {
                import std.typecons : tuple;
                return reduce!fun(tuple(seed), r);
            }
        }
    }
     
}
import core.bitop : popcnt;
static if (!__traits(compiles, popcnt(ulong.max))) {
    public import core.bitop : popcnt;
    int popcnt(ulong v) {
        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));
    }
}
bool poppar(ulong v) {
    v^=v>>1;
    v^=v>>2;
    v&=0x1111111111111111UL;
    v*=0x1111111111111111UL;
    return ((v>>60) & 1) != 0;
}
import std.traits;
template EPS(R) {
    R EPS;
}
int sgn(R)(R a) {
    if (a < -EPS!R) return -1;
    if (a > EPS!R) return 1;
    return 0;
}
struct Point2D(T) {
    T[2] d;
    this(T x, T y) {this.d = [x, y];}
    this(T[2] d) {this.d = d;}
    @property ref inout(T) x() inout {return d[0];}
    @property ref inout(T) y() inout {return d[1];}
    ref inout(T) opIndex(size_t i) inout {return d[i];}
    auto opBinary(string op:)(Point2D r) const {return Point2D(x+r.x, y+r.y);}
    auto opBinary(string op:)(Point2D r) const {return Point2D(x-r.x, y-r.y);}
    static if (isFloatingPoint!T) {
        T abs() {
            import std.math : sqrt;
            return (x*x+y*y).sqrt;
        }
        T arg() {
            import std.math : atan2;
            return atan2(y, x);
        }
    }
}
bool near(T)(Point2D!T a, Point2D!T b) {
    return !sgn((a-b).abs);
}
T dot(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*l[0] + l[1]*r[1];
}
T cross(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*r[1] - l[1]*r[0];
}
int ccw(R)(Point2D!R a, Point2D!R b, Point2D!R c) {
    assert(!near(a, b));
    if (near(a, c) || near(b, c)) return 0;
    int s = sgn(cross(b-a, c-a));
    if (s) return s;
    if (dot(b-a, c-a) < 0) return 2;
    if (dot(a-b, c-b) < 0) return -2;
    return 0;
}
 
 
int contains(R)(Point2D!R[] pol, Point2D!R p) {
    import std.algorithm : swap;
    int res = -1;
    foreach (i; 0..pol.length) {
        auto a = pol[i] - p, b = pol[(i+1)<pol.length?i+1:0] - p;
        if (ccw(a, b, Point2D!R(0, 0)) == 0) return 1;
        if (a.y > b.y) swap(a, b);
        if (a.y <= 0 && 0 < b.y) {
            if (cross(a, b) < 0) res *= -1;
        }
    }
    return res+1;
}
 
 
int argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {
    int sgn(Point2D!T p) {
        if (p[1] < 0) return -1;
        if (p[1] > 0) return 1;
        if (p[0] < 0) return 2;
        return 0;
    }
    int lsgn = sgn(l);
    int rsgn = sgn(r);
    if (lsgn < rsgn) return -1;
    if (lsgn > rsgn) return 1;
    T x = cross(l, r);
    if (x > 0) return -1;
    if (x < 0) return 1;
    return 0;
}
 
/*
This source code generated by dcomp and include dcomp's source code.
dcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https:
dcomp's License: MIT License(https:
*/"
D,"import std.stdio;
import std.conv;
import std.algorithm;
import std.string;
import std.file;
import std.math;
 
int main() {
        string l;
        readln();
        while((l = readln(), l.length)){
                l = l.split()[0];
                float x1, y1, x2, y2, x3, y3;
                x1 = to!float(l.split[0]), y1 = to!float(l.split[1]);
                x2 = to!float(l.split[2]), y2 = to!float(l.split[3]);
                x3 = to!float(l.split[4]), y3 = to!float(l.split[5]);
                float a, b, c, d, e, f;
                a = 2 * (x1 - x2), b = 2 * (y1 - y2), c = (x1 + x2) * (x1 - x2) + (y1 + y2) * (y1 - y2);
                d = 2 * (x1 - x3), e = 2 * (y1 - y3), f = (x1 + x3) * (x1 - x3) + (y1 + y3) * (y1 - y3);                
                float px, py, r;
                px = c / (a - d * b / e) - f / (a * e / b - d), py = c / (b - e * a / d) - f / (b * d / a - e);
                r = sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py));
/*              px = to!float(to!int(px * 1000)) / 1000, py = to!float(to!int(py * 1000)) / 1000;
                r = to!float(to!int(r * 1000)) / 1000;
*/              printf(, px, py, r);
                }
        return 0;
        }
 "
D,"import std.stdio : write, writeln, writefln, stdin;
import std.array;
import std.range;
void main(){
	string[char] en = [
		' '	: ,
		'\\''	: ,
		','	: ,
		'-'	: ,
		'.'	: ,
		'?'	: ,
		'A'	: ,
		'B'	: ,
		'C'	: ,
		'D'	: ,
		'E'	: ,
		'F'	: ,
		'G'	: ,
		'H'	: ,
		'I'	: ,
		'J'	: ,
		'K'	: ,
		'L'	: ,
		'M'	: ,
		'N'	: ,
		'O'	: ,
		'P'	: ,
		'Q'	: ,
		'R'	: ,
		'S'	: ,
		'T'	: ,
		'U'	: ,
		'V'	: ,
		'W'	: ,
		'X'	: ,
		'Y'	: ,
		'Z'	: ,
	];
	char[string] de = [
		 : 'A',
		 : 'B',
		 : 'C',
		 : 'D',
		 : 'E',
		 : 'F',
		 : 'G',
		 : 'H',
		 : 'I',
		 : 'J',
		 : 'K',
		 : 'L',
		 : 'M',
		 : 'N',
		 : 'O',
		 : 'P',
		 : 'Q',
		 : 'R',
		 : 'S',
		 : 'T',
		 : 'U',
		 : 'V',
		 : 'W',
		 : 'X',
		 : 'Y',
		 : 'Z',
		 : ' ',
		 : '.',
		 : ',',
		 : '-',
		 : '\\'',
		 : '?',
	];
	
	while(true){
		string str = readln.chomp;
		if(stdin.eof) break;
		string p;
		foreach(c; str){
			p~=en[c];
		}
		string[] q;
		while(p.length>0){
			if(p.length < 5){
				q ~= p.take(p.length).array.to!string ~ repeat('0').take(5-p.length).array.to!string;
				for(auto l=p.length; 0<l; --l){
					p.popFront;
				}
			}else{
				q ~= p.take(5).array.to!string;
				foreach(i; 5.iota){
					p.popFront;
				}
			}
		}
		
		string ans;
		foreach(ite; q){
			ans ~= de[ite];
		}
		
		ans.writeln;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.string;
import std.conv;
import std.array;
import std.algorithm;
void main() {
    
    auto prevTradeList = inputTradeList();
    
    auto tradeList = inputTradeList();
    foreach (trade; tradeList.keys.sort()) {
        if (trade in prevTradeList) {
            writeln(join([trade.to!string, (prevTradeList[trade] + tradeList[trade]).to!string], ));
        }
    }
}
/*
 * 標準入力から取引のデータを取り込み、リストに登録する。
 * 入力の長さが0の場合、終了と見なす。
 */
int[int] inputTradeList() {
    int[int] tradeList;
    foreach (input; stdin.byLine) {
        if (input.length == 0) break;
        auto trade = input.split().map!(to!int);
        tradeList = addTradeList(trade[0], tradeList);
    }
    return tradeList;
}
/*
 * 取引履歴を走査し、同じ取引が
 * 1. あれば、その取引のcountをインクリメント
 * 2. なければ、取引履歴に追加
 */
int[int] addTradeList(int tradeId, int[int] prevTradeList) {
    if (tradeId in prevTradeList) {
        prevTradeList[tradeId]++;
    } else {
        prevTradeList[tradeId] = 1;
    }
    return prevTradeList;
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
immutable int[2][][3] D =
[
    [[1,0],[0,0],[2,0],[1,1],[1,-1]],
    [[1,1],[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]],
    [[2,0],[0,0],[1,-1],[1,0],[1,1],[2,-2],[2,-1],[2,1],[2,2],[3,-1],[3,0],[3,1],[4,0]],
];
void main()
{
    immutable N = 10;
    immutable M = readln().chomp().to!int();
    auto m = iota(N).map!(_=>readln().split().map!(to!int).array()).array();
    int[3][] r;
    bool check(int x, int y)
    {
        return 0<=x && x<N && 0<=y && y<N && m[y][x]>0;
    }
    bool dfs(int x, int y)
    {
        if(y>=N) return false;
        if(x>=N) return dfs(0,y+1);
        if(m[y][x]==0) return dfs(x+1,y);
        foreach_reverse(i,d;D)
        {
            bool f=true;
            foreach(v;d)
                if(!check(x+v[1],y+v[0]))
                {
                    f=false;break;
                }
            if(!f) continue;
            foreach(v;d) --m[y+v[0]][x+v[1]];
            r~=[x+d[0][1],y+d[0][0],i.to!int()+1];
            if(r.length<M)
            {
                if(dfs(x,y)) return true;
            }
            else
            {
                if(m.map!(a=>a.reduce!()).reduce!()==0)
                    return true;
            }
            r.popBack();
            foreach(v;d) ++m[y+v[0]][x+v[1]];
        }
        return false;
    }
    dfs(0,0);
    foreach(a;r)
        a.to!(int[]).map!(to!string).join().writeln();
}"
D,"import std.stdio, std.string, std.conv, std.array, std.algorithm;
void main() {
  int[][] field;
  int[][] dp;
  string line;
  while (true) {
    line = readln.chomp;
    if (stdin.eof) break;
    field ~= line.split().map!(to!(int)).array;
  }
  foreach(int i, f; field) dp ~= new int[](f.length);
  int half = (field.length / 2).to!(int);
  for(int i = 1; i < field.length; i++) {
    for(int j = 0; j < field[i].length; j++) {
      if (half >= i) {
        if (j == field[i].length - 1) {
          field[i][j] += field[i - 1][j - 1];
        }
        else if (j == 0) {
          field[i][j] += field[i - 1][j];
        }        
        else {
          field[i][j] +=
            max(field[i - 1][j], field[i - 1][j - 1]);
        }
      }
      else if (half < i) {
        if (field[i].length / 2 <= i) {
          field[i][j] += max(field[i - 1][j], field[i - 1][j + 1]);
        }
        else {
          field[i][j] +=
            max(field[i - 1][j], field[i - 1][j]);
        }
      }
    }
  }
  writeln(field[$ - 1][0]);
}"
D,"import std.string;
import std.stdio;
import std.range;
import std.algorithm;
import std.array;
import std.conv;
void bfs(ref int[] table, int curr) {
  
  int[] directions = [1, 14, -1, -14];
  int[] que;
  que ~= curr;
  while(que != null) {
    auto point = que.front;
    que.popFront;    
    foreach(d; directions) {
      if (point + d < table.length && table[point + d] == 1) {
        que ~= point + d;
        table[point + d] = 0;
      }
    } 
  }
}
void main() {
  while(true) {
    int[] table;
    int count = 0;
    table ~= repeat(0).take(14).array;
    foreach(t; 0..12) {
      string line = readln.chomp;
      table ~= [0] ~ line.array.map!((x) => x.to!(int) - '0').array ~ [0];
    }
    table ~= repeat(0).take(14).array;
    foreach(i; 1..13) {
      foreach(j; 1..13) {
        int num = j + i * 14;
        if (table[num] == 1) {
          bfs(table, num);
          ++count;
        }
      }
    }
    writeln(count);
    readln;
    if (stdin.eof) goto end;
  }
 end:;
}"
D,"import std.stdio;
import std.conv;
import std.string;
import std.algorithm;
import std.array;
int read_number() {return readln.chomp.to!(int);}
bool is_correct(int[][] lot, int start, int finish) {
  uint curr = start;
  foreach(col; lot) {
    
    if (col[curr - 1] == 1) curr--;
    else if (col[curr] == 1) curr++;
  }
  return curr == finish;
}
void main() {
  while(true) {
    int width = (read_number - 1);
    if (width == -1) break;
    int start = read_number;
    int finish = read_number;
    int height = read_number;
    int[][] lot = [];
    int[][] empty = [];           
    foreach(int i; 0..height) {
      lot ~= [0] ~ readln.chomp.dup.map!((x) => to!(int)(x - '0')).array ~ [0];
      foreach(int j; 0..width) {
        if (lot[i][j + 1] == 0 && lot[i][j + 2] == 0 && lot[i][j] == 0)
          empty ~= [i, j + 1];
      }
    }
    if (is_correct(lot, start, finish)) writeln(0);
    else {
      int[] ans = [];
      foreach(data; empty) {
        lot[data[0]][data[1]] = 1;
        if (is_correct(lot, start, finish)) {ans = data; break;}
        else {
          lot[data[0]][data[1]] = 0;
        }
      }
      if (ans == []) writeln(1);
      else writefln(, ans[0] + 1, ans[1]);
    }
  }
}"
D,"import std.stdio, std.string, std.conv;
void main()
{
    loop:
    do
    {
        bool[8][8] map;
        foreach(y; 0..8) foreach(x, c; readln.chomp)
        {
            map[y][x] = c == '1';
        }
        foreach(y; 0 .. 7) foreach(x; 0 .. 7)
        {
            if(map[y][x] && map[y + 1][x] && map[y][x + 1] && map[y + 1][x + 1])
            {
                .writeln;
                continue loop;
            }
        }
        foreach(y; 0 .. 5) foreach(x; 0 .. 8)
        {
            if(map[y][x] && map[y + 1][x] && map[y + 2][x] && map[y + 3][x])
            {
                .writeln;
                continue loop;
            }
        }
        foreach(y; 0 .. 8) foreach(x; 0 .. 5)
        {
            if(map[y][x] && map[y][x + 1] && map[y][x + 2] && map[y][x + 3])
            {
                .writeln;
                continue loop;
            }
        }
        foreach(y; 0 .. 6) foreach(x; 0 .. 7)
        {
            if(map[y][x + 1] && map[y + 1][x] && map[y + 1][x + 1] && map[y + 2][x])
            {
                .writeln;
                continue loop;
            }
        }
        foreach(y; 0 .. 7) foreach(x; 0 .. 6)
        {
            if(map[y][x] && map[y][x + 1] && map[y + 1][x + 1] && map[y + 1][x + 2])
            {
                .writeln;
                continue loop;
            }
        }
        foreach(y; 0 .. 6) foreach(x; 0 .. 7)
        {
            if(map[y][x] && map[y + 1][x] && map[y + 1][x + 1] && map[y + 2][x + 1])
            {
                .writeln;
                continue loop;
            }
        }
        foreach(y; 0 .. 7) foreach(x; 0 .. 6)
        {
            if(map[y + 1][x] && map[y + 1][x + 1] && map[y][x + 1] && map[y][x + 2])
            {
                .writeln;
                continue loop;
            }
        }
    } while (readln !is null);
}"
D,"import std.stdio;
import std.conv;
import std.algorithm;
import std.string;
import std.file;
import std.math;
int main() {
	char[] digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
	
	string l1, l2;
	readln();
	while((l1 = readln(), l1.length)){
		bool overflow = false;
		
		l2 = readln();
		if(!l1.split.length || !l2.split.length) break;
		
		char[] a, b, c;
		for(int i=0; i<80; i++) c ~= '0';
		
		a = cast(char[]) l1.split()[0];
		if(a.length > 80) overflow = true;
		a = c ~ a;
		a = a[$ - 80 .. $];
		
		b = cast(char[]) l2.split()[0];
		if(b.length > 80) overflow = true;
		b = c ~ b;
		b = b[$ - 80 .. $];
		
		for(int i = 79; i >= 0; i--){
			int t = (c[i] - '0') + (a[i] - '0') + (b[i] - '0');
			if(t >= 10){
				if(i == 0) overflow = true, t = 0;
				else while(t >= 10) c[i-1] += 1, t -= 10;
				}
			c[i] = digits[t];
			}
		if(overflow) printf();
		else{
			int i;
			for(i = 0; i < 79; i++){
				if(c[i] != '0') break;
				}
			c = c[i .. $];
			write(c ~ '\\n');
			}
		}
	return 0;
	}"
D,"import std.stdio;
import std.conv;
import std.cstream;
import std.string;
import std.algorithm;
int Map[20][20];
int ms,wp;
int[] dx3 = [0,1,2,1,1,0,0,0,0,-1,-2,-1,-1];
int[] dy3 = [0,0,0,-1,1,-1,-2,1,2,0,0,1,-1];
int[] dx2 = [0,-1,-1,0,1,1,1,0,-1];
int[] dy2 = [0,0,-1,-1,-1,0,1,1,1];
int[] dx = [0,0,1,0,-1];
int[] dy = [0,1,0,-1,0];
void main(){
int x,y,size;
for(int i;i<20;i++)for(int j;j<20;j++)Map[i][j]=0;
wp = 100;
while(scanf(,&x,&y,&size) != EOF)transaction(x,y,size);
printf(,wp,ms);
}
void transaction(int x,int y,int size){
if(size == 3){
  for(int i;i<dx3.length;i++){
    if(0<=y+dy3[i] && y+dy3[i]<10 && 0<=x+dx3[i] && x+dx3[i] < 10){
      if(Map[y+dy3[i]][x+dx3[i]] == 0)wp--;
      Map[y+dy3[i]][x+dx3[i]]+=1;
      if(ms < Map[y+dy3[i]][x+dx3[i]])ms = Map[y+dy3[i]][x+dx3[i]];
    }
  }
}
else if(size == 2){
  for(int i;i<dx2.length;i++){
    if(0<=y+dy2[i] && y+dy2[i]<10 && 0<=x+dx2[i] && x+dx2[i] < 10){
      if(Map[y+dy2[i]][x+dx2[i]] == 0)wp--;
      Map[y+dy2[i]][x+dx2[i]]+=1;
      if(ms < Map[y+dy2[i]][x+dx2[i]])ms = Map[y+dy2[i]][x+dx2[i]];
    }
  }
}else{
  for(int i;i<dx.length;i++){
    if(0<=y+dy[i] && y+dy[i]<10 && 0<=x+dx[i] && x+dx[i] < 10){
      if(Map[y+dy[i]][x+dx[i]] == 0)wp--;
      Map[y+dy[i]][x+dx[i]]+=1;
      if(ms < Map[y+dy[i]][x+dx[i]])ms = Map[y+dy[i]][x+dx[i]];
    }
  }
}
}"
D,"import std.algorithm;
import std.array;
import std.conv;
import std.math;
import std.range;
import std.stdio;
import std.string;
import std.typecons;
T read(T)() { return readln.chomp.to!T; }
T[] reads(T)() { return readln.split.to!(T[]); }
alias readint = read!int;
alias readints = reads!int;
int calc(int n, int s) {
    int ans = 0;
    foreach (e; combinations!int(iota(10).array, n)) {
        if (e.sum == s)
            ans++;
    }
    return ans;
}
void main() {
    while (true) {
        auto xs = readints;
        int n = xs[0], s = xs[1];
        if (n == 0 && s == 0) break;
        writeln(calc(n, s));
    }
}
struct combinations(T) {
    private T[] _source;
    private int _n;
    private T[][] _q;
    private int _state;
    this(T[] source, int n) {
        _source = source.dup;
        _n = n;
        _state = 0;
        pushNext();
    }
    @property T[] front() {
        return _q[0];
    }
    void popFront() {
        _q = _q[1..$];
        pushNext();
    }
    bool empty() {
        return _q.length == 0;
    }
    private void pushNext() {
        int len = cast(int)_source.length;
        while (_state < (1 << len)) {
            int[] buf;
            for (int j = 0; j < len; j++) {
                if (_state & (1 << j)) {
                    buf ~= _source[j];
                    if (buf.length > _n) break;
                }
            }
            _state++;
            if (buf.length == _n) {
                _q ~= buf;
                return;
            }
        }
    }
}"
D,"import std.stdio, std.string, std.conv, std.algorithm, std.array, std.typecons, std.range, std.functional;
bool nextPermutation(alias less=, BidirectionalRange)
                    (ref BidirectionalRange range)
{
    
    if (range.empty) return false;
    auto i = retro(range);
    auto last = i.save;
    
    size_t n = 1;
    for (i.popFront(); !i.empty; i.popFront(), last.popFront(), n++)
    {
        if (binaryFun!less(i.front, last.front))
            break;
    }
    if (i.empty) {
        
        
        range.reverse();
        return false;
    }
    
    auto j = find!((a) => binaryFun!less(i.front, a))(
                   takeExactly(retro(range), n));
    assert(!j.empty);   
    swap(i.front, j.front);
    reverse(takeExactly(retro(range), n));
    return true;
}
void main()
{
    int[3] ops = [cast(int)'+', cast(int)'-', cast(int)'*'];
    loop:while(true)
    {
        int[] input = readln.split.map!(to!int).array;
        if(input[0] == 0) break;
        foreach(a; ops) foreach(b; ops) foreach(c; ops)
        {
            int[] sorted = (input ~ [a, b, c]).sort;
            while(sorted.nextPermutation)
            {
                if(string exp = sorted.calc)
                {
                    exp.writeln;
                    continue loop;
                }
            }
        }
        0.writeln;
    }
}
string calc(int[] input)
{
    auto op = [
        '+': (int a, int b) => a + b,
        '-': (int a, int b) => a - b,
        '*': (int a, int b) => a * b,
    ];
    int[7] calcStack;
    string[7] expStack;
    int stackLen;
    foreach(num; input)
    {
        switch(num)
        {
            case '+':
            case '-':
            case '*':
                if(stackLen < 2) return null;
                calcStack[stackLen - 2] = op[cast(char)num](calcStack[stackLen - 2] ,calcStack[stackLen - 1]);
                expStack[stackLen - 2] =  ~ expStack[stackLen - 2] ~ cast(char)num ~ expStack[stackLen - 1] ~ ;
                --stackLen;
                break;
            default:
                calcStack[stackLen] = num;
                expStack[stackLen] = num.to!string;
                ++stackLen;
        }
    }
    return calcStack[0] == 10 ? expStack[0] : null;
}"
D,"import std.stdio;
import std.array;
import std.conv;
void main()
{
    auto op = ['+', '-', '*'];
    
    while (true) {
        auto flag = false;
        auto num = readln.split.to!(int[]);
        if (num[] == [0, 0, 0, 0]) break;
        
    loop:
        foreach (i; 0..3) {
            foreach (j; 0..3) {
                foreach (k; 0..3) {
                    foreach (a; 0..4) {
                        foreach (b; 0..4) {
                            if (b == a) continue;
                            foreach (c; 0..4) {
                                if (c == a || c == b) continue;
                                foreach (d; 0..4) {
                                    if (d == a || d == b || d == c) continue;
                                    if (cal(k, cal(j, cal(i, num[a], num[b]), num[c]), num[d]) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(k, cal(i, num[a], cal(j, num[b], num[c])), num[d]) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(i, num[a], cal(j, num[b], cal(k, num[c], num[d]))) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(i, num[a], cal(k, cal(j, num[b], num[c]), num[d])) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(j, cal(i, num[a], num[b]), cal(k, num[c], num[d])) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!flag) writeln(0);
    }
}
int cal(const int op, const int n1, const int n2)
{
    switch (op) {
    case 0:
        return n1 + n2;
        break;
    case 1:
        return n1 - n2;
        break;
    case 2:
        return n1 * n2;
        break;
    default:
        writeln();
        return 0;
        break;
    }
}"
D,"import std.stdio : writeln, writefln;
import std.array;
import std.range;
import std.math : sqrt, acos, PI;
const int INF = 1<<28;
double d(double[2] a){
	return sqrt(a[0]*a[0] + a[1]*a[1]);
}
double ep(double[2] a, double[2] b){
	return a[0]*b[1] - a[1]*b[0];
}
double g(double[2] a, double[2] b){
	double cos_ = (a[0]*b[0] + a[1]*b[1])/(a.d*b.d);
	double theta = acos(cos_);
	if(ep(a, b)>0){
		theta+=PI;
	}
	
	return theta;
}
void swap(T)(ref T a, ref T b){
	T tmp = a;
	a = b;
	b = tmp;
}
void main(){
	double[2][] list;
	
	
	delim = ;
	double min_ = INF;
	while(hasNext){
		double[2] v_ = [next!double(), next!double()];
		if(v_[0] < min_){
			list = [v_] ~ list;
			min_ = v_[0];
		}else{
			list = list ~ [v_];
		}
	}
	
	int[] sorted;
	sorted ~= 0;
	
	auto n = list.length;
	double[2] v = [0.,1.];
	double[2] node = list[0];
	while(true){
		min_ = INF;
		int min_idx;
		for(int i=0; i<n; ++i){
			double[2] v_ = list[i];
			v_[] -= node[];
			double theta = g(v, v_);
			
			if(theta<min_){
				min_ = theta;
				min_idx = i;
			}
		}
		
		if(min_idx==0) break;
		
		sorted ~= min_idx;
		
		double[2] v_ = list[min_idx];
		v_[] -= node[];
		
		node = list[min_idx];
		v = v_;
	}
	
	double S=0.;
	for(int i=1; i<sorted.length-1; ++i){
		double[2] a = list[sorted[i]];
		double[2] b = list[sorted[i+1]];
		
		a[]-=list[sorted[0]][];
		b[]-=list[sorted[0]][];
		
		double value = ep(a, b);
		value = sqrt(value*value)/2.;
		
		S += value;
	}
	
	writefln(, S);
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.string;
import std.math;
import std.conv;
import std.algorithm;
import std.bigint;
void main(){
    int[10][10] map;
    while(true){
	auto s = split(chomp(readln()),',');
	if(stdin.eof()) break;
	int x,y,size;
	x = to!int(s[0]);
	y = to!int(s[1]);
	size = to!int(s[2]);
	if(size >0){
	    auto d = [1,0,-1,0 ,0];
	    auto d1 = [0,1,0,-1,0];
	    for(int i=0;i<5;i++){
		if(0 <= d[i] + x &&  d[i] + x < 10 && 0 <= d1[i] + y &&  d1[i] + y < 10){
		    map[d[i] + x][d1[i] + y]++;
		}
	    }
	}
	size--;
	if(size>0){
	    auto d = [ 1,-1];
	    for(int i=0;i<2;i++){
		for(int j=0;j<2;j++){
		    if(0 <= d[i] + x &&  d[i] + x < 10 && 0 <= d[j] + y &&  d[j] + y < 10){
			map[d[i] + x][d[j] + y]++;
		    }
		}
	    }
	}
	size--;
	if(size>0){
	    auto d = [2,0,-2,0,0];
	    auto d1 = [0,2,0,-2,0];
	    for(int i=0;i<5;i++){
		if(0 <= d[i] + x &&  d[i] + x < 10 && 0 <= d1[i] + y &&  d1[i] + y < 10){
		    map[d[i] + x][d1[i] + y]++;
		}
	    }
	}
    }
    int ans1 = 0,ans2=0;
    for(int i=0;i<10;i++){
	for(int j=0;j<10;j++){
	    if(map[i][j] == 0) ans1++;
	    ans2 = max(map[i][j] , ans2);
	}
    }
    writeln(ans1);
    writeln(ans2);
}"
D,"import std.stdio;
import std.algorithm;
import std.string;
import std.functional;
import std.array;
import std.conv;
import std.math;
import std.typecons;
import std.regex;
import std.range;
void main(){
    while(true){
	int n = readln().chomp().to!int;
	if(n==0)break;
	int m = readln().chomp().to!int;
	int p = readln().chomp().to!int;
	int d = readln().chomp().to!int;
	string[] s;
	int[11] h;
	for(int i=0;i<11;i++) h[i] = i;
	for(int i=0;i<d;i++){
	    s ~= readln().chomp();
	    for(int j=0;j<n-1;j++){
		if(s[i][j] == '1'){
		    swap(h[j+1],h[j+2]);
		}
	    }
	}
	bool flg = false;
	if(h[p] == m) {
	    writeln(0);
	    flg = true;
	}
	else{
	    for(int i=0;i<d;i++){
		for(int j=0;j<n-1;j++){
		    if(j<n-2 && s[i][j+1] == '1' ) continue;
		    if(j>0 && s[i][j-1] == '1' ) continue;
		    int[11] h1;
		    for(int i1=0;i1<11;i1++) h1[i1] = i1;
		    for(int k=0;k<d;k++){
			for(int l=0;l<n-1;l++){
			    if(s[k][l] == '1' ||(k==i&&l==j)){
				swap(h1[l+1],h1[l+2]);
			    }
			}
		    }
		    if(h1[p]==m){
			flg = true;
			writeln(i+1,,j+1);
			break;
		    }
		}
		if(flg) break;
	    }
	}
	if(!flg) writeln(1);
    }
}"
D,"import std.stdio : readln, writeln, chomp, stdin;
import std.conv : to;
import std.algorithm : min;
int[] solve(int[13] d)
{
	int[] ans;
	int[9] map = 0;			
	foreach(v; d){
		++map[v-1];
	}
	foreach(i; 0..9){
		int[9] arr = map.dup;
		++arr[i];
		
		bool flag = false;
		foreach(ite; arr){
			flag |= 4<ite;
		}
		if(flag)continue;
		if(search(arr.idup, 0)){
			ans ~= (i+1);
		}
	}
	
	return ans;
}
bool search(immutable int[] map, int index)
{
	
	auto arr = map.dup;
	bool[(9-3)+1] list = arr.renew;
	if(index>=list.length){
		auto tmp = arr.dup;
		foreach(ref ite; tmp){
			ite %= 3;
		}
		foreach(ref ite; tmp){
			if(ite==2){
				ite=0;
				break;
			}
		}
		bool flag = true;
		foreach(ite; tmp){
			flag &= ite==0;
		}
		return flag;
	}
	if(list[index]){
		bool flag = false;
		flag |= search(arr.idup, index+1);
		auto tmp = arr.dup;
		
		while(list[index]){
			for(int i=0; i<3; ++i){
				--tmp[index+i];
			}
			list = tmp.renew;
			
			flag |= search(tmp.idup, index+1);
		}
		return flag;
	}else{
		return search(arr.idup, index+1);
	}
}
bool[(9-3)+1] renew(int[] arr)
{
	bool[(9-3)+1] list = true;
	for(int j=0; j<=9-3; ++j){
		for(int k=0; k<3; ++k){
			list[j] &= arr[j+k]>0;
		}
	}
	return list;
}
/+
int getMin(int[] arr, int index)
{
	int[3] f = 0;
	for(int k=0; k<3; ++k){
		f[k] = arr[index+k];
	}
	return min(f[0], f[1], f[2]);
}
+/
void main()
{
	io();
}
void io()
{
	while(true){
		string str = readln.chomp;
		if(stdin.eof())break;
		int[13] d;
		foreach(i, c; str){
			d[i] = c-'0';
		}
		int[] ans = d.solve;
		if(ans.length>0){
			string _ans = ;
			for(int i=0; i<ans.length; ++i){
				_ans ~= ans[i].to!string;
				if(i+1<ans.length){
					_ans ~= ;
				}
			}
			_ans.writeln;
		}else{
			writeln = 0;
		}
	}
}"
D,"import std.stdio, std.conv, std.algorithm;
import std.range, std.array, std.math;
void dump(int[][] field, int n) {
  for(int i = 0; i <= n + 1; i++) {
    for(int j = 0; j <= n + 1; j++) {
      writef(, field[i][j], j == (n + 1) ?  : );
    }
  }
}
void main() {
  int edge;
  while(readf(, &edge), edge != 0) {
    int[][] field = new int[][](edge + 2, edge + 2);
    for(int i = 0; i <= (edge + 1); i++) {
      field[0][i] = -1;
      field[i][0] = -1;
      field[edge + 1][i] = -1;
      field[i][edge + 1] = -1;
    }
    for(int i = 1; i <= edge; i++) {
      string s;
      readf(, &s);
      for(int j = 0; j < edge; j++) {
        switch(s[j]) {
        case '*':
          field[i][j + 1] = -1;
          break;
        case '.':
          field[i][j + 1] = 1;
          break;
        default:
          throw new Exception();
        }
      }
    }
    int square = 0;
    for(int i = edge; i >= 1; i--) {
      for(int j = edge; j >= 1; j--) {
        if (field[i][j] == -1) continue;
        if (field[i + 1][j] != -1 &&
            field[i][j + 1] != -1 &&
            field[i + 1][j + 1] != -1) {
          field[i][j] =
            min(field[i][j + 1], field[i + 1][j], field[i + 1][j + 1]) + 1;
        }
        square = max(square, field[i][j]);
      }
    }
    writeln(square);
  }
}"
D,"import std.stdio : writeln, write, stdin;
import std.array;
import std.range;
import std.algorithm : max;
int n;
int s;
int[10] min_LUT;
int[10] max_LUT;
int solve(int N, int S, int mask){
	if(N==0){
		return S==0 ? 1 : 0;
	}
	if(S < min_LUT[N-1]){
		return -1;
	}
	if(max_LUT[N-1] < S){
		return -1;
	}
	
	debug{
		import std.stdio : writefln;
		dbg(N, S);
		writefln(, mask);
	}
	if(S>=0){
		int count = 0;
		for(int i=9; 0<=i; --i){
			if(((mask>>i)&0x01) == 0x00){
				debug { dbg(, i); }
				debug { readln; }
				auto val = solve(N-1, S-i*N, mask | 0x01<<i);
				if(val==-1){
					continue;
				}
				count += val;
			}
		}
		
		return count;
	}else{
		debug{ .dbg; }
		return -1;
	}
}
void main(){
	for(int i=0; i<10; ++i){
		min_LUT[i] = int.init;
		for(int j=i+1; 0<j; --j){
			min_LUT[i] += j*(i+1-j);
		}
	}
	debug{ min_LUT.dbg; }
	for(int i=0; i<10; ++i){
		max_LUT[i] = int.init;
		for(int j=0; j<=i; ++j){
			max_LUT[i] += (i+1-j)*(10-1-j);
		}
	}
	debug{ max_LUT.dbg; }
	
	while(hasNext()){
		n.next;
		s.next;
		
		if(1<=n && n<=10){
			auto val = solve(n, s, 0x00);
			val = max(val, 0);
			val.writeln;
		}else{
			writeln(0);
		}
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"/+ dub.sdl:
    name 
    dependency  version=
+/
import std.stdio, std.algorithm, std.range, std.conv;
void solve() {
    alias P = Point2D!double;
    P [4] p;
    foreach (i; 0..4) {
        double x, y;
        sc.read(x, y);
        p[i] = P(x, y);
    }
    if (!sgn(cross(p[0]-p[1], p[2]-p[3]))) {
        writeln();
    } else {
        writeln();
    }
}
int main() {
    EPS!double = 1e-10;
    int n;
    sc.read(n);
    foreach (i; 0..n) solve();
    return 0;
}
Scanner sc;
static this() {
    sc = new Scanner(stdin);
}
 
class Scanner {
    import std.stdio : File;
    import std.conv : to;
    import std.range : front, popFront, array, ElementType;
    import std.array : split;
    import std.traits : isSomeChar, isStaticArray, isArray; 
    import std.algorithm : map;
    File f;
    this(File f) {
        this.f = f;
    }
    char[512] lineBuf;
    char[] line;
    private bool succW() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (!line.empty && line.front.isWhite) {
            line.popFront;
        }
        return !line.empty;
    }
    private bool succ() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (true) {
            while (!line.empty && line.front.isWhite) {
                line.popFront;
            }
            if (!line.empty) break;
            line = lineBuf[];
            f.readln(line);
            if (!line.length) return false;
        }
        return true;
    }
    private bool readSingle(T)(ref T x) {
        import std.algorithm : findSplitBefore;
        import std.string : strip;
        import std.conv : parse;
        if (!succ()) return false;
        static if (isArray!T) {
            alias E = ElementType!T;
            static if (isSomeChar!E) {
                 
                 
                auto r = line.findSplitBefore();
                x = r[0].strip.dup;
                line = r[1];
            } else static if (isStaticArray!T) {
                foreach (i; 0..T.length) {
                    bool f = succW();
                    assert(f);
                    x[i] = line.parse!E;
                }
            } else {
                FastAppender!(E[]) buf;
                while (succW()) {
                    buf ~= line.parse!E;
                }
                x = buf.data;
            }
        } else {
            x = line.parse!T;
        }
        return true;
    }
    int read(T, Args...)(ref T x, auto ref Args args) {
        if (!readSingle(x)) return 0;
        static if (args.length == 0) {
            return 1;
        } else {
            return 1 + read(args);
        }
    }
}
 
 
 
 
T[N] fixed(T, size_t N)(T[N] a) {return a;}
 
 
 
struct FastAppender(A, size_t MIN = 4) {
    import std.algorithm : max;
    import std.conv;
    import std.range.primitives : ElementEncodingType;
    import core.stdc.string : memcpy;
    private alias T = ElementEncodingType!A;
    private T* _data;
    private uint len, cap;
     
    @property size_t length() const {return len;}
    bool empty() const { return len == 0; }
     
    void reserve(size_t nlen) {
        import core.memory : GC;
        if (nlen <= cap) return;
        
        void* nx = GC.malloc(nlen * T.sizeof);
        cap = nlen.to!uint;
        if (len) memcpy(nx, _data, len * T.sizeof);
        _data = cast(T*)(nx);
    }
    void free() {
        import core.memory : GC;
        GC.free(_data);
    }
     
    void opOpAssign(string op : )(T item) {
        if (len == cap) {
            reserve(max(MIN, cap*2));
        }
        _data[len++] = item;
    }
     
    void insertBack(T item) {
        this ~= item;
    }
     
    void removeBack() {
        len--;
    }
     
    void clear() {
        len = 0;
    }
    ref inout(T) back() inout { assert(len); return _data[len-1]; }
    ref inout(T) opIndex(size_t i) inout { return _data[i]; }
     
    T[] data() {
        return (_data) ? _data[0..len] : null;
    }
}
 
 
 
static if (__VERSION__ <= 2070) {
    /*
    Copied by https:
    Copyright: Andrei Alexandrescu 2008-.
    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
    */
    template fold(fun...) if (fun.length >= 1) {
        auto fold(R, S...)(R r, S seed) {
            import std.algorithm : reduce;
            static if (S.length < 2) {
                return reduce!fun(seed, r);
            } else {
                import std.typecons : tuple;
                return reduce!fun(tuple(seed), r);
            }
        }
    }
     
}
import core.bitop : popcnt;
static if (!__traits(compiles, popcnt(ulong.max))) {
    public import core.bitop : popcnt;
    int popcnt(ulong v) {
        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));
    }
}
bool poppar(ulong v) {
    v^=v>>1;
    v^=v>>2;
    v&=0x1111111111111111UL;
    v*=0x1111111111111111UL;
    return ((v>>60) & 1) != 0;
}
import std.traits;
template EPS(R) {
    R EPS;
}
int sgn(R)(R a) {
    if (a < -EPS!R) return -1;
    if (a > EPS!R) return 1;
    return 0;
}
struct Point2D(T) {
    T[2] d;
    this(T x, T y) {this.d = [x, y];}
    this(T[2] d) {this.d = d;}
    @property ref inout(T) x() inout {return d[0];}
    @property ref inout(T) y() inout {return d[1];}
    ref inout(T) opIndex(size_t i) inout {return d[i];}
    auto opBinary(string op:)(Point2D r) const {return Point2D(x+r.x, y+r.y);}
    auto opBinary(string op:)(Point2D r) const {return Point2D(x-r.x, y-r.y);}
    static if (isFloatingPoint!T) {
        T abs() {
            import std.math : sqrt;
            return (x*x+y*y).sqrt;
        }
        T arg() {
            import std.math : atan2;
            return atan2(y, x);
        }
    }
}
bool near(T)(Point2D!T a, Point2D!T b) {
    return !sgn(abs(a-b));
}
T dot(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*l[0] + l[1]*r[1];
}
T cross(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*r[1] - l[1]*r[0];
}
 
 
 
int argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {
    int sgn(Point2D!T p) {
        if (p[1] < 0) return -1;
        if (p[1] > 0) return 1;
        if (p[0] < 0) return 2;
        return 0;
    }
    int lsgn = sgn(l);
    int rsgn = sgn(r);
    if (lsgn < rsgn) return -1;
    if (lsgn > rsgn) return 1;
    T x = cross(l, r);
    if (x > 0) return -1;
    if (x < 0) return 1;
    return 0;
}
 
/*
This source code generated by dcomp and include dcomp's source code.
dcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https:
dcomp's License: MIT License(https:
*/"
D,"/+ dub.sdl:
    name 
    dependency  version=
+/
import std.stdio, std.algorithm, std.range, std.conv, std.math;
int main() {
    EPS!double = 1e-10;
    alias P = Point2D!double;
    P[] pol;
    while (true) {
        string s;
        if (sc.read(s) != 1) break;
        auto l = s.split();
        double x = l[0].to!double;
        double y = l[1].to!double;
        pol ~= P(x, y);
    }
    writefln(, pol.area2.abs / 2);
    return 0;
}
Scanner sc;
static this() {
    sc = new Scanner(stdin);
}
 
class Scanner {
    import std.stdio : File;
    import std.conv : to;
    import std.range : front, popFront, array, ElementType;
    import std.array : split;
    import std.traits : isSomeChar, isStaticArray, isArray; 
    import std.algorithm : map;
    File f;
    this(File f) {
        this.f = f;
    }
    char[512] lineBuf;
    char[] line;
    private bool succW() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (!line.empty && line.front.isWhite) {
            line.popFront;
        }
        return !line.empty;
    }
    private bool succ() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (true) {
            while (!line.empty && line.front.isWhite) {
                line.popFront;
            }
            if (!line.empty) break;
            line = lineBuf[];
            f.readln(line);
            if (!line.length) return false;
        }
        return true;
    }
    private bool readSingle(T)(ref T x) {
        import std.algorithm : findSplitBefore;
        import std.string : strip;
        import std.conv : parse;
        if (!succ()) return false;
        static if (isArray!T) {
            alias E = ElementType!T;
            static if (isSomeChar!E) {
                 
                 
                auto r = line.findSplitBefore();
                x = r[0].strip.dup;
                line = r[1];
            } else static if (isStaticArray!T) {
                foreach (i; 0..T.length) {
                    bool f = succW();
                    assert(f);
                    x[i] = line.parse!E;
                }
            } else {
                FastAppender!(E[]) buf;
                while (succW()) {
                    buf ~= line.parse!E;
                }
                x = buf.data;
            }
        } else {
            x = line.parse!T;
        }
        return true;
    }
    int read(T, Args...)(ref T x, auto ref Args args) {
        if (!readSingle(x)) return 0;
        static if (args.length == 0) {
            return 1;
        } else {
            return 1 + read(args);
        }
    }
}
 
 
 
 
T[N] fixed(T, size_t N)(T[N] a) {return a;}
 
 
 
struct FastAppender(A, size_t MIN = 4) {
    import std.algorithm : max;
    import std.conv;
    import std.range.primitives : ElementEncodingType;
    import core.stdc.string : memcpy;
    private alias T = ElementEncodingType!A;
    private T* _data;
    private uint len, cap;
     
    @property size_t length() const {return len;}
    bool empty() const { return len == 0; }
     
    void reserve(size_t nlen) {
        import core.memory : GC;
        if (nlen <= cap) return;
        
        void* nx = GC.malloc(nlen * T.sizeof);
        cap = nlen.to!uint;
        if (len) memcpy(nx, _data, len * T.sizeof);
        _data = cast(T*)(nx);
    }
    void free() {
        import core.memory : GC;
        GC.free(_data);
    }
     
    void opOpAssign(string op : )(T item) {
        if (len == cap) {
            reserve(max(MIN, cap*2));
        }
        _data[len++] = item;
    }
     
    void insertBack(T item) {
        this ~= item;
    }
     
    void removeBack() {
        len--;
    }
     
    void clear() {
        len = 0;
    }
    ref inout(T) back() inout { assert(len); return _data[len-1]; }
    ref inout(T) opIndex(size_t i) inout { return _data[i]; }
     
    T[] data() {
        return (_data) ? _data[0..len] : null;
    }
}
 
 
 
static if (__VERSION__ <= 2070) {
    /*
    Copied by https:
    Copyright: Andrei Alexandrescu 2008-.
    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
    */
    template fold(fun...) if (fun.length >= 1) {
        auto fold(R, S...)(R r, S seed) {
            import std.algorithm : reduce;
            static if (S.length < 2) {
                return reduce!fun(seed, r);
            } else {
                import std.typecons : tuple;
                return reduce!fun(tuple(seed), r);
            }
        }
    }
     
}
import core.bitop : popcnt;
static if (!__traits(compiles, popcnt(ulong.max))) {
    public import core.bitop : popcnt;
    int popcnt(ulong v) {
        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));
    }
}
bool poppar(ulong v) {
    v^=v>>1;
    v^=v>>2;
    v&=0x1111111111111111UL;
    v*=0x1111111111111111UL;
    return ((v>>60) & 1) != 0;
}
import std.traits;
template EPS(R) {
    R EPS;
}
int sgn(R)(R a) {
    if (a < -EPS!R) return -1;
    if (a > EPS!R) return 1;
    return 0;
}
struct Point2D(T) {
    T[2] d;
    this(T x, T y) {this.d = [x, y];}
    this(T[2] d) {this.d = d;}
    @property ref inout(T) x() inout {return d[0];}
    @property ref inout(T) y() inout {return d[1];}
    ref inout(T) opIndex(size_t i) inout {return d[i];}
    auto opOpAssign(string op)(in Point2D r) {
        return mixin(~op~);
    }
    auto opBinary(string op:)(in Point2D r) const {return Point2D(x+r.x, y+r.y);}
    auto opBinary(string op:)(in Point2D r) const {return Point2D(x-r.x, y-r.y);}
    static if (isFloatingPoint!T) {
        T abs() {
            import std.math : sqrt;
            return (x*x+y*y).sqrt;
        }
        T arg() {
            import std.math : atan2;
            return atan2(y, x);
        }
        Point2D rot(T ar) {
            import std.math : cos, sin;
            auto cosAr = cos(ar), sinAr = sin(ar);
            return Point2D(x*cosAr - y*sinAr, x*sinAr + y*cosAr);
        }
    }
}
bool near(T)(Point2D!T a, Point2D!T b) if (isIntegral!T) {
    return a == b;
}
bool near(T)(Point2D!T a, Point2D!T b) if (isFloatingPoint!T) {
    return !sgn((a-b).abs);
}
T dot(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*r[0] + l[1]*r[1];
}
T cross(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*r[1] - l[1]*r[0];
}
 
int ccw(R)(Point2D!R a, Point2D!R b, Point2D!R c) {
    assert(!near(a, b));
    if (near(a, c) || near(b, c)) return 0;
    int s = sgn(cross(b-a, c-a));
    if (s) return s;
    if (dot(b-a, c-a) < 0) return 2;
    if (dot(a-b, c-b) < 0) return -2;
    return 0;
}
inout(Point2D!R) at(R)(inout Point2D!R[] pol, size_t i) {
    return pol[i<pol.length?i:i-pol.length];
}
 
int contains(R)(Point2D!R[] pol, Point2D!R p) {
    import std.algorithm : swap;
    int res = -1;
    foreach (i; 0..pol.length) {
        auto a = pol.at(i) - p, b = pol.at(i+1) - p;
        if (ccw(a, b, Point2D!R(0, 0)) == 0) return 1;
        if (a.y > b.y) swap(a, b);
        if (a.y <= 0 && 0 < b.y) {
            if (cross(a, b) < 0) res *= -1;
        }
    }
    return res+1;
}
 
R area2(R)(Point2D!R[] pol) {
    R u = 0;
    foreach (i; 0..pol.length) {
        auto a = pol.at(i), b = pol.at(i+1);
        u += cross(a, b);
    }
    return u;
}
 
 
 
int argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {
    int sgn(Point2D!T p) {
        if (p[1] < 0) return -1;
        if (p[1] > 0) return 1;
        if (p[0] < 0) return 2;
        return 0;
    }
    int lsgn = sgn(l);
    int rsgn = sgn(r);
    if (lsgn < rsgn) return -1;
    if (lsgn > rsgn) return 1;
    T x = cross(l, r);
    if (x > 0) return -1;
    if (x < 0) return 1;
    return 0;
}
 
/*
This source code generated by dcomp and include dcomp's source code.
dcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https:
dcomp's License: MIT License(https:
*/"
D,"import std.stdio, std.conv, std.range, std.array;
void main() {
  immutable string[char] tb =
    [' ': ,
     '\\'': ,
     ',': ,
     '-': ,
     '.': ,
     '?': ,
     'A': ,
     'B': ,
     'C': ,
     'D': ,
     'E': ,
     'F': ,
     'G': ,
     'H': ,
     'I': ,
     'J': ,
     'K': ,
     'L': ,
     'M': ,
     'N': ,
     'O': ,
     'P': ,
     'Q': ,
     'R': ,
     'S': ,
     'T': ,
     'U': ,
     'V': ,
     'W': ,
     'X': ,
     'Y': ,
     'Z': ];
  immutable char[string] rev_tb =
    [: 'A',
     : 'B',
     : 'C',
     : 'D',
     : 'E',
     : 'F',
     : 'G',
     : 'H',
     : 'I',
     : 'J',
     : 'K',
     : 'L',
     : 'M',
     : 'N',
     : 'O',
     : 'P',
     : 'Q',
     : 'R',
     : 'S',
     : 'T',
     : 'U',
     : 'V',
     : 'W',
     : 'X',
     : 'Y',
     : 'Z',
     : ' ',
     : '.',
     : ',',
     : '-',
     : '\\'',
     : '?'];
  for(string line; readf(, &line);) {
    char[] content = line.to!(char[]);
    char[] in_stream, out_stream;
    foreach(c; content)
      in_stream ~= tb[c];
    size_t s = in_stream.length % 5;
    if (s != 0) in_stream ~= repeat('0').take(5 - s).array;    
    for(int i = 0; i < in_stream.length; i += 5) {
      out_stream ~= rev_tb[in_stream[i..(i + 5)]];
    }
    writeln(out_stream);
  }
}"
D,"import std.stdio;
import std.algorithm;
import std.string;
import std.range;
import std.array;
import std.conv;
import std.complex;
import std.math;
bool canS(int[10][] a, int x, int y) {
	if(0 < x && x < 9 && 0 < y && y < 9) {
		for(int i = -1; i <= 1; i += 2) {
			if(a[x+i][y] == 0 || a[x][y+i] == 0)
				return false;
		}
		return true;
	}
	return false;
}
bool canM(int[10][] a, int x, int y) {
	if(0 < x && x < 9 && 0 < y && y < 9) {
		for(int i = -1; i <= 1; ++i){
			for(int j = -1; j <= 1; ++j) {
				if(a[x+i][y+j] == 0)
					return false;
			}
		}
		return true;
	}
	return false;
}
bool canL(int[10][] a, int x, int y){
	return canS(a, x-1, y) && canS(a, x, y-1) && canS(a, x+1, y) && canS(a, x, y+1);
}
int[][] S = [[0,1,0],[1,1,1],[0,1,0]];
int[][] M = [[1,1,1],[1,1,1],[1,1,1]];
int[][] L = [[0,0,1,0,0],[0,1,1,1,0],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0]];
void apply(int[10][] a, int[][] b, int x, int y) {
	auto x_ = b.length/2;
	auto y_ = b.length/2;
	for(int i; i < b.length; ++i) {
		for(int j; j < b.length; ++j){
			a[x+i-x_][y+j-y_] -= b[i][j];
		}
	}
}
void unapply(int[10][] a, int[][] b, int x, int y) {
	auto x_ = b.length/2;
	auto y_ = b.length/2;
	for(int i; i < b.length; ++i) {
		for(int j; j < b.length; ++j){
			a[x+i-x_][y+j-y_] += b[i][j];
		}
	}
}
string dfs(int n, int[10][] a, int x, int y, int m) {
	if(n == 0) {
		if(m == 0)
			return ;
		else
			return null;
	}
	if(m > n*13) {
		return null;
	}
	while(y < 10) {
		if(2 < y && a[x][y-3] > 0)
			return null;
		if(a[x][y] > 0){
			if(canL(a, x, y)) {
				apply(a, L, x, y);
				auto ret = dfs(n-1, a, x, y, m-13);
				if(ret !is null) {
					return ret ~ to!string(x) ~  ~ to!string(y) ~ ;
				}
				unapply(a, L, x, y);
			}
			if(canM(a, x, y)) {
				apply(a, M, x, y);
				auto ret = dfs(n-1, a, x, y, m-9);
				if(ret !is null) {
					return ret ~ to!string(x) ~  ~ to!string(y) ~ ;
				}
				unapply(a, M, x, y);
			}
			if(canS(a, x, y)) {
				apply(a, S, x, y);
				auto ret = dfs(n-1, a, x, y, m-5);
				if(ret !is null) {
					return ret ~ to!string(x) ~  ~ to!string(y) ~ ;
				}
				unapply(a, S, x, y);
			}
		}
		++x;
		if(x == 10) {
			x = 0;
			++y;
		}
	}
	return null;
}
void main() {
	auto n = to!int(readln().strip());
	int[10][10] a;
	int m;
	for(int i; i < 10; ++i){
		auto s = readln().strip().split();
		for(int j; j < 10; ++j){
			a[j][i] = to!int(s[j]);
			m += a[j][i];
		}
	}
	write(dfs(n, a, 0, 0, m));
}"
D,"import std.stdio, std.conv, std.string, std.algorithm, std.array, std.format;
void main()
{
    for( int iii=1; ; ++iii ){
        const w = readln.chomp.to!int;
        if ( w == 0 )
           break;
        const n = readln.chomp.to!int;
        int[][1001] item;
        item[0] = [0, 0];
        foreach( i; 0..n ) {
                        
            item[i+1] = readln.chomp.split().map!(to!int).array;
        }
        
        int dp[1002][1002];
        foreach( i; 0..w+1 )
            dp[i][0] = 0;
        foreach( i; 0..n+1 )
            dp[0][i] = 0;
        
        int max_v = 0;
        int max_w = 0;
        foreach( ni; 1..n+1 ) {
            foreach( wi; 1..w+1 ) {
                auto bw = wi - item[ni][1];
                auto bi = ni - 1;
                if ( bw >= 0 ) {
                    auto cand = dp[bw][bi] + item[ni][0];  
                    dp[wi][ni] = max( cand, dp[wi][bi] );
                } else {  
                    dp[wi][ni] = dp[wi][bi];
                }
                if ( dp[wi][ni] > max_v || ( dp[wi][ni] == max_v && wi < max_w ) ) {
                   max_v = dp[wi][ni];
                   max_w = wi;
                }
            }
        }
        printf( , iii );
        max_v.writeln;
        max_w.writeln;
    }
}"
D,"import std.stdio;
import std.ascii;
import std.range;
import std.array;
import std.functional;
import std.algorithm;
import std.conv;
import std.container;
import std.math;
import std.numeric;
import std.string;
import std.c.string;
import std.random;
import std.regex;
import std.typecons;
struct P {
    int id, score;
}
void main() {
    auto map = redBlackTree!(, false, Tuple!(int, int));
    string s;
    P[] ps;
    while (true) {
        s = readln.chomp;
        if (s == ) break;
        auto t = s.split().map!(to!int);
        int id = t[0],
            score = t[1];
        ps ~= P(id, score);
    }
    ps.sort!;
    int prev_score = ps[0].score;
    int cur_rank = 1;
    for (int i = 0; i < ps.length; i++) {
        if (prev_score == ps[i].score) {
            map.insert(tuple(ps[i].id, cur_rank));
        } else {
            cur_rank++;
            map.insert(tuple(ps[i].id, cur_rank));
            prev_score = ps[i].score;
        }
    }
    while (true) {
        s = readln.chomp;
        if (stdin.eof) break;
        int x = s.to!int;
        writeln(map.equalRange(tuple(x, -1)).front[1]);
    }
}"
D,"module Main;
import std.stdio;
import std.string;
import std.conv;
import std.array;
import std.range;
import std.algorithm;
alias map!(to!string) stringize;
void main() {
    string input;
    while ((input = readln.chomp).length != 0) {
        int[] tehai = new int[](9);
        int[] yama = new int[](9);
        int[] ans;
        fill(yama, 4);
        foreach (i; 0..13) {
            int index = (input[i] - '0').to!int;
            tehai[index-1]++;
            yama[index-1]--;
        }
        ans = agari(tehai, yama);
        if (ans.length == 0) {
            writeln(0);
        } else {
            writeln(ans.stringize.join());
        }
    }
}
int[] agari(int[] tehai, int[] yama) {
    int[] ans;
    foreach (i; 0..tehai.length) {
        if (yama[i] == 0) continue;
        tehai[i]++;
        foreach (j; 0..tehai.length) {
            if (tehai[j] < 2) continue;
            tehai[j] -= 2;
            if (yaku(tehai, 0)) ans ~= (i + 1).to!int;
            tehai[j] += 2;
        }
        tehai[i]--;
    }
    return ans;
}
bool yaku(int[] haipai, int num_yaku) {
    if (num_yaku >= 4) return true;
    int[] tehai;
    foreach (i; 0..haipai.length) {
        
        if (i >= 2 && haipai[i - 2] > 0 && haipai[i - 1] > 0 && haipai[i] > 0) {
            tehai = haipai.dup;
            tehai[i - 2]--;
            tehai[i - 1]--;
            tehai[i]--;
            return yaku(tehai, ++num_yaku);
        }
        
        if (haipai[i] >= 3) {
            tehai = haipai.dup;
            tehai[i] -= 3;
            return yaku(tehai, ++num_yaku);
        }
    }
    return false;
}"
D,"import std.stdio;
import std.string;
import std.conv;
import std.array;
import std.typecons;
import std.algorithm;
void main() {
    
    auto prevTradeList = inputTradeList();
    
    auto tradeList = inputTradeList();
    foreach (trade; tradeList.keys.sort()) {
        if (trade in prevTradeList) {
            writeln(join([trade.to!string, (prevTradeList[trade] + tradeList[trade]).to!string], ));
        }
    }
}
/*
 * 標準入力から取引のデータを取り込み、リストに登録する。
 * 入力の長さが0の場合、終了と見なす。
 */
int[int] inputTradeList() {
    int[int] tradeList;
    foreach (input; stdin.byLine) {
        if (input.length == 0) break;
        auto trade = input.split().map!(to!int);
        tradeList = addTradeList(trade[0], tradeList);
    }
    return tradeList;
}
/*
 * 取引履歴を走査し、同じ取引が
 * 1. あれば、その取引のcountをインクリメント
 * 2. なければ、取引履歴に追加
 */
int[int] addTradeList(int tradeId, int[int] prevTradeList) {
    if (tradeId in prevTradeList) {
        prevTradeList[tradeId]++;
    } else {
        prevTradeList[tradeId] = 1;
    }
    return prevTradeList;
}"
D,"import std.stdio;
import std.string;
import std.conv;
void main() {
    
    string[][100] str;
    int line = 0;
    
    
    for(int i=0; ; ++i) {
        
        if(stdin.eof) {
            break;
        }
        
        str[i] = readln().split;
        
        ++line;
    }
    
    for(int i=0; i<line; ++i) {
        
        double[100] arr;
        int len;
        
        bool flag = false;
        
        for(int j=0; j<str[i].length; ++j) {
            
            try {
                
                arr[len] = to!int(str[i][j]);
                ++len;
                flag = true;
                
            } catch(Exception e) {
                
                final switch(str[i][j]) {
                    case :
                        arr[len-2] = arr[len-2] + arr[len-1];
                        break;
                       
                    case :
                        arr[len-2] = arr[len-2] - arr[len-1];                       
                        break;
                        
                    case :
                        arr[len-2] = arr[len-2] * arr[len-1];
                        break;
                      
                    case :
                        arr[len-2] = arr[len-2] / arr[len-1];
                        break;
                }
                
                len -= 1;
                
            }
            
        }
        
        if(flag)
            writefln(, arr[0]);
    }
    
}"
D,"import std.stdio : writeln, writefln;
import std.array;
import std.range;
import std.math : sqrt, acos, PI;
double d(double[2] a){
	return sqrt(a[0]*a[0] + a[1]*a[1]);
}
void swap(T)(ref T a, ref T b){
	T tmp = a;
	a = b;
	b = tmp;
}
void main(){
	delim = ;
	while(hasNext){
		double[2] a = [next!double(), next!double()];
		double[2] b = [next!double(), next!double()];
		double[2] q = [next!double(), next!double()];
		
		double[2] v = a;
		v[]-=q[];
		
		double[2] r = [b[1]-a[1], -(b[0]-a[0])];
		r[]*=1.0/r.d;
		
		double cos_ = (v[0]*r[0] + v[1]*r[1])/(v.d*r.d);
		double h = v.d*cos_;
		
		r[]*=2.0*h;
		r[]+=q[];
		
		writefln(, r[0], r[1]);
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.algorithm;
import std.string;
import std.range;
string[dchar] code1;
dchar[string] code2;
void main() {
	code1[' '] = ;
	code1['\\''] = ;
	code1[','] = ;
	code1['-'] = ;
	code1['.'] = ;
	code1['?'] = ;
	code1['A'] = ;
	code1['B'] = ;
	code1['C'] = ;
	code1['D'] = ;
	code1['E'] = ;
	code1['F'] = ;
	code1['G'] = ;
	code1['H'] = ;
	code1['I'] = ;
	code1['J'] = ;
	code1['K'] = ;
	code1['L'] = ;
	code1['M'] = ;
	code1['N'] = ;
	code1['O'] = ;
	code1['P'] = ;
	code1['Q'] = ;
	code1['R'] = ;
	code1['S'] = ;
	code1['T'] = ;
	code1['U'] = ;
	code1['V'] = ;
	code1['W'] = ;
	code1['X'] = ;
	code1['Y'] = ;
	code1['Z'] = ;
	code2[] = 'A';
	code2[] = 'B';
	code2[] = 'C';
	code2[] = 'D';
	code2[] = 'E';
	code2[] = 'F';
	code2[] = 'G';
	code2[] = 'H';
	code2[] = 'I';
	code2[] = 'J';
	code2[] = 'K';
	code2[] = 'L';
	code2[] = 'M';
	code2[] = 'N';
	code2[] = 'O';
	code2[] = 'P';
	code2[] = 'Q';
	code2[] = 'R';
	code2[] = 'S';
	code2[] = 'T';
	code2[] = 'U';
	code2[] = 'V';
	code2[] = 'W';
	code2[] = 'X';
	code2[] = 'Y';
	code2[] = 'Z';
	code2[] = ' ';
	code2[] = '.';
	code2[] = ',';
	code2[] = '-';
	code2[] = '\\'';
	code2[] = '?';
	while(!stdin.eof()) {
		auto s1 = readln().chomp();
		if(!s1.empty()) {
			auto s2 = map!(a => code1[a])(s1).join();
			while(!s2.empty()) {
				while(s2.length < 5)
					s2 = s2 ~ '0';
				write(code2[s2[0..5]]);
				s2 = s2.drop(5);
			}
			writeln();
		}
	}
}"
D,"/+ dub.sdl:
    name 
    dependency  version=
+/
import std.stdio, std.algorithm, std.range, std.conv;
bool solve() {
    alias P = Point2D!double;
    string s;
    if (sc.read(s) != 1) return false;
    auto l = s.split();
    P[] p = new P[3];
    foreach (i; 0..3) {
        p[i] = P(l[2*i].to!double, l[2*i+1].to!double);
    }
    p[1] -= p[0];
    p[2] -= p[0];
    double ar = p[1].arg;
    p[2] = p[2].rot(-ar);
    p[2].y *= -1;
    p[2] = p[2].rot(ar);
    p[2] += p[0];
    writefln(, p[2].x, p[2].y);
    return true;
}
int main() {
    EPS!double = 1e-10;
    while (solve()) {}
    return 0;
}
Scanner sc;
static this() {
    sc = new Scanner(stdin);
}
 
class Scanner {
    import std.stdio : File;
    import std.conv : to;
    import std.range : front, popFront, array, ElementType;
    import std.array : split;
    import std.traits : isSomeChar, isStaticArray, isArray; 
    import std.algorithm : map;
    File f;
    this(File f) {
        this.f = f;
    }
    char[512] lineBuf;
    char[] line;
    private bool succW() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (!line.empty && line.front.isWhite) {
            line.popFront;
        }
        return !line.empty;
    }
    private bool succ() {
        import std.range.primitives : empty, front, popFront;
        import std.ascii : isWhite;
        while (true) {
            while (!line.empty && line.front.isWhite) {
                line.popFront;
            }
            if (!line.empty) break;
            line = lineBuf[];
            f.readln(line);
            if (!line.length) return false;
        }
        return true;
    }
    private bool readSingle(T)(ref T x) {
        import std.algorithm : findSplitBefore;
        import std.string : strip;
        import std.conv : parse;
        if (!succ()) return false;
        static if (isArray!T) {
            alias E = ElementType!T;
            static if (isSomeChar!E) {
                 
                 
                auto r = line.findSplitBefore();
                x = r[0].strip.dup;
                line = r[1];
            } else static if (isStaticArray!T) {
                foreach (i; 0..T.length) {
                    bool f = succW();
                    assert(f);
                    x[i] = line.parse!E;
                }
            } else {
                FastAppender!(E[]) buf;
                while (succW()) {
                    buf ~= line.parse!E;
                }
                x = buf.data;
            }
        } else {
            x = line.parse!T;
        }
        return true;
    }
    int read(T, Args...)(ref T x, auto ref Args args) {
        if (!readSingle(x)) return 0;
        static if (args.length == 0) {
            return 1;
        } else {
            return 1 + read(args);
        }
    }
}
 
 
 
 
T[N] fixed(T, size_t N)(T[N] a) {return a;}
 
 
 
struct FastAppender(A, size_t MIN = 4) {
    import std.algorithm : max;
    import std.conv;
    import std.range.primitives : ElementEncodingType;
    import core.stdc.string : memcpy;
    private alias T = ElementEncodingType!A;
    private T* _data;
    private uint len, cap;
     
    @property size_t length() const {return len;}
    bool empty() const { return len == 0; }
     
    void reserve(size_t nlen) {
        import core.memory : GC;
        if (nlen <= cap) return;
        
        void* nx = GC.malloc(nlen * T.sizeof);
        cap = nlen.to!uint;
        if (len) memcpy(nx, _data, len * T.sizeof);
        _data = cast(T*)(nx);
    }
    void free() {
        import core.memory : GC;
        GC.free(_data);
    }
     
    void opOpAssign(string op : )(T item) {
        if (len == cap) {
            reserve(max(MIN, cap*2));
        }
        _data[len++] = item;
    }
     
    void insertBack(T item) {
        this ~= item;
    }
     
    void removeBack() {
        len--;
    }
     
    void clear() {
        len = 0;
    }
    ref inout(T) back() inout { assert(len); return _data[len-1]; }
    ref inout(T) opIndex(size_t i) inout { return _data[i]; }
     
    T[] data() {
        return (_data) ? _data[0..len] : null;
    }
}
 
 
 
static if (__VERSION__ <= 2070) {
    /*
    Copied by https:
    Copyright: Andrei Alexandrescu 2008-.
    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
    */
    template fold(fun...) if (fun.length >= 1) {
        auto fold(R, S...)(R r, S seed) {
            import std.algorithm : reduce;
            static if (S.length < 2) {
                return reduce!fun(seed, r);
            } else {
                import std.typecons : tuple;
                return reduce!fun(tuple(seed), r);
            }
        }
    }
     
}
import core.bitop : popcnt;
static if (!__traits(compiles, popcnt(ulong.max))) {
    public import core.bitop : popcnt;
    int popcnt(ulong v) {
        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));
    }
}
bool poppar(ulong v) {
    v^=v>>1;
    v^=v>>2;
    v&=0x1111111111111111UL;
    v*=0x1111111111111111UL;
    return ((v>>60) & 1) != 0;
}
import std.traits;
template EPS(R) {
    R EPS;
}
int sgn(R)(R a) {
    if (a < -EPS!R) return -1;
    if (a > EPS!R) return 1;
    return 0;
}
struct Point2D(T) {
    T[2] d;
    this(T x, T y) {this.d = [x, y];}
    this(T[2] d) {this.d = d;}
    @property ref inout(T) x() inout {return d[0];}
    @property ref inout(T) y() inout {return d[1];}
    ref inout(T) opIndex(size_t i) inout {return d[i];}
    auto opOpAssign(string op)(in Point2D r) {
        return mixin(~op~);
    }
    auto opBinary(string op:)(in Point2D r) const {return Point2D(x+r.x, y+r.y);}
    auto opBinary(string op:)(in Point2D r) const {return Point2D(x-r.x, y-r.y);}
    static if (isFloatingPoint!T) {
        T abs() {
            import std.math : sqrt;
            return (x*x+y*y).sqrt;
        }
        T arg() {
            import std.math : atan2;
            return atan2(y, x);
        }
        Point2D rot(T ar) {
            import std.math : cos, sin;
            auto cosAr = cos(ar), sinAr = sin(ar);
            return Point2D(x*cosAr - y*sinAr, x*sinAr + y*cosAr);
        }
    }
}
bool near(T)(Point2D!T a, Point2D!T b) {
    return !sgn((a-b).abs);
}
T dot(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*l[0] + l[1]*r[1];
}
T cross(T)(in Point2D!T l, in Point2D!T r) {
    return l[0]*r[1] - l[1]*r[0];
}
int ccw(R)(Point2D!R a, Point2D!R b, Point2D!R c) {
    assert(!near(a, b));
    if (near(a, c) || near(b, c)) return 0;
    int s = sgn(cross(b-a, c-a));
    if (s) return s;
    if (dot(b-a, c-a) < 0) return 2;
    if (dot(a-b, c-b) < 0) return -2;
    return 0;
}
 
 
int contains(R)(Point2D!R[] pol, Point2D!R p) {
    import std.algorithm : swap;
    int res = -1;
    foreach (i; 0..pol.length) {
        auto a = pol[i] - p, b = pol[(i+1)<pol.length?i+1:0] - p;
        if (ccw(a, b, Point2D!R(0, 0)) == 0) return 1;
        if (a.y > b.y) swap(a, b);
        if (a.y <= 0 && 0 < b.y) {
            if (cross(a, b) < 0) res *= -1;
        }
    }
    return res+1;
}
 
 
int argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {
    int sgn(Point2D!T p) {
        if (p[1] < 0) return -1;
        if (p[1] > 0) return 1;
        if (p[0] < 0) return 2;
        return 0;
    }
    int lsgn = sgn(l);
    int rsgn = sgn(r);
    if (lsgn < rsgn) return -1;
    if (lsgn > rsgn) return 1;
    T x = cross(l, r);
    if (x > 0) return -1;
    if (x < 0) return 1;
    return 0;
}
 
/*
This source code generated by dcomp and include dcomp's source code.
dcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https:
dcomp's License: MIT License(https:
*/"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
class UnionFind
{
    private int[] p;
    private int[] r;
    this(int n){ p = iota(n).array(); r = new int[n]; }
    int find(int x)
    {
        if(x==p[x]) return x;
        return p[x]=find(p[x]);
    }
    void unite(int x, int y)
    {
        x=find(x);
        y=find(y);
        if(r[x]>r[y]) swap(x,y);
        p[y]=x;
        if(r[x]==r[y]) ++r[y]; 
    }
    bool same(int x, int y){ return find(x)==find(y); }
}
void main()
{
    for(int n; 0!=(n=readln().chomp().to!int()); )
    {
        immutable m = readln().chomp().to!int();
        auto g = iota(m).map!(_=>readln().chomp().split().map!(to!int).array()).array()
            .map!(a=>[a[2]/100-1,a[0],a[1]]).array().sort();
        auto uf = new UnionFind(n);
        int c=0;
        foreach(e;g)
        {
            if(uf.same(e[1],e[2])) continue;
            uf.unite(e[1],e[2]);
            c+=e[0];
        }
        writeln(c);
    }
}"
D,"import std.stdio : write, writeln, writefln, stdin;
import std.array;
import std.range;
import std.algorithm : max;
void main(){
	int[] d = [readln.chomp.to!int];
	while(true){
		auto str = readln.chomp.split();
		if(stdin.eof()) break;
		
		int[] r;
		foreach(i; str){
			r ~= i.to!int;
		}
		int[] d_ = repeat(0).take(r.length).array;
		
		if(r.length > d.length){
			for(int i=0; i<d.length; ++i){
				d_[i] = max(d_[i], r[i]+d[i]);
				d_[i+1] = max(d_[i+1], r[i+1]+d[i]);
			}
		}else{
			d_[0] = max(d_[0], r[0]+d[0]);
			for(int i=1; i<d.length-1; ++i){
				d_[i] = max(d_[i], r[i]+d[i]);
				d_[i-1] = max(d_[i-1], r[i-1]+d[i]);
			}
			d_[$-1] = max(d_[$-1], r[$-1]+d[$-1]);
		}
		
		d = d_.clone;
	}
	
	d.front.writeln;
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.algorithm;
import std.string;
import std.conv;
import std.math;
void main(){
    while(true){
	int[] cards;
	auto s = readln();
	if(stdin.eof()) break;
	auto s1 = split(chomp(s),',');
	for(int i=0;i<5;i++){
	    cards ~= to!int(s1[i]);
	}
	
	sort(cards);
	bool flg = false;
	int count = 0;
	for(int i=0;i<5;i++){
	    count = 0;
	    for(int j=0;j<5;j++){
		if(cards[i] == cards[j]) count++;
	    }
	    if(count==4) {
		writeln();
		flg = true;
		break;
	    }
	}
	if(!flg){
	    bool three=false, two=false;
	    for(int i=0;i<5;i++){
		count = 0;
		for(int j=0;j<5;j++){
		    if(cards[i]==cards[j]) count++;
		}
		if(count==3) three = true;
		if(count==2) two = true;
		if(three&&two){
		    writeln();
		    flg = true;
		    break;
		}
	    }
	}
	if(!flg){
	    bool st=true;
	    if(cards[0]==1&&cards[1]==10)cards[0]=9;
	    for(int i=0;i<4;i++){
		if(cards[i+1]-cards[i]!=1) st = false;
	    }
	    if(st){
		writeln();
		flg = true;
	    }
	}
	if(!flg){
	    bool three=false;
	    for(int i=0;i<5;i++){
		count = 0;
		for(int j=0;j<5;j++){
		    if(cards[i]==cards[j]) count++;
		}
		if(count==3) three = true;
		if(three){
		    writeln();
		    flg = true;
		    break;
		}
	    }
	}
	if(!flg){
	    int p1,p2;
	    for(int i=0;i<5;i++){
		count = 0;
		for(int j=0;j<5;j++){
		    if(cards[i]==cards[j]&&p1!=cards[i]) count++;
		}
		if(count==2&&p1>0) p2 = cards[i];
		if(count==2) p1 = cards[i];
		if(p1&&p2){
		    writeln();
		    flg=true;
		    break;
		}
	    }
	    if(p1&&!flg){
		writeln();
		flg = true;
	    }
	}
	if(!flg) writeln();
    }
}"
D,"import std.stdio;
import std.conv;
import std.string;
import std.typecons;
import std.algorithm;
import std.array;
import std.range;
import std.math;
import std.container;
import std.datetime;
void main()
{
	auto path = new int[][](5, 5);
	auto key = [' ', 'U', 'L', ' ', 'D', ' ', ' ', ' ', 'R'];
	auto dx = [0, 0, -1, 0, 0, 0, 0, 0, 1];
	auto dy = [0, -1, 0, 0, 1, 0, 0, 0, 0];
	foreach (i; 0..5) {
		auto x = readln.chomp;
		foreach (j, e; x) {
			if (e == '1') {
				path[i][j] |= 8;
				path[i][j+1] |= 2;
			}
		}
		if (i == 4) continue;
		auto y = readln.chomp;
		foreach (j, e; y) {
			if (e == '1') {
				path[i][j] |= 4;
				path[i+1][j] |= 1;
			}
		}
	}
	int x = 1, 
			y = 0, 
			dir = 8;
	write();
	while (x != 0 || y != 0) {
		auto d = dir << 1;
		if (d == 16) d = 1;
		if (path[y][x] & d) {
			x += dx[d];
			y += dy[d];
			write(key[d]);
			dir = d;
			continue;
		}
		d = dir;
		if (path[y][x] & d) {
			x += dx[d];
			y += dy[d];
			write(key[d]);
			continue;
		}
		d = dir >> 1;
		if (d == 0) d = 8;
		if (path[y][x] & d) {
			x += dx[d];
			y += dy[d];
			write(key[d]);
			dir = d;
			continue;
		}
		d = d >> 1;
		if (d == 0) d = 8;
		x += dx[d];
		y += dy[d];
		write(key[d]);
		dir = d; 
	}
	writeln();
}"
D,"import std.stdio;
import std.algorithm;
import std.string;
import std.array;
import std.conv;
import std.typecons;
int[][] F;
A[] ans;
struct P {
    int y, x;
}
struct A {
    int x, y, t;
}
int type(ulong len) {
    switch (len) {
        case 5: return 1;
        case 9: return 2;
        case 13: return 3;
        default: ;
    }
    throw new Error();
}
bool check() {
    foreach (i; 0 .. 10) 
        foreach (j; 0 .. 10) 
            if (F[i][j] > 0) return false;
    return true;
}
const Large = [
    P(0, 0),
    P(1, -1), P(1, 0), P(1, 1),
    P(2, -2), P(2, -1), P(2, 0), P(2, 1), P(2, 2),
    P(3, -1), P(3, 0), P(3, 1),
    P(4, 0)
];
const Medium = [
    P(0, 0), P(0, 1), P(0, 2),
    P(1, 0), P(1, 1), P(1, 2),
    P(2, 0), P(2, 1), P(2, 2)
];
const Small = [
    P(0, 0),
    P(1, -1), P(1, 0), P(1, 1),
    P(2, 0)
];
 
bool tryIt(int pos, const P[] D) {
    int y = pos / 10, x = pos % 10;
    foreach (d; D) {
        int ny = y + d.y, nx = x + d.x;
        if (! (0 <= ny && ny < 10 && 0 <= nx && nx < 10) ) return false;
        if (F[ny][nx] <= 0) return false;
    }
    foreach (d; D) {
        int ny = y + d.y, nx = x + d.x;
        F[ny][nx]--;
    }
    if (solve(pos)) {
        P med = D[$ / 2];
        ans ~= A(x + med.x, y + med.y, D.length.type);
        return true;
    }
    foreach (d; D) {
        int py = y + d.y, px = x + d.x;
        F[py][px]++;
    }
    return false;
}
bool solve(int pos = 0) {
    if (pos == 100) return check();
    int y = pos / 10, x = pos % 10;
    if (F[y][x] == 0) return solve(pos + 1);
    if (tryIt(pos, Large) || tryIt(pos, Medium) || tryIt(pos, Small)) {
        return true;
    }
    return false;
}
void main() {
    int N; readf(, &N);
    F = new int[][10];
    foreach (ref L; F) L = readln.chomp.split().map!(to!int).array;
    solve;
    foreach (a; ans) {
        writeln(a.x, , a.y, , a.t);
    }
}"
D,"import std.stdio : write, writef;
import std.array;
import std.range;
void main(){
	while(true){
		int n = next!int();
		if(n==0){ return; }
		
		int[][] map;
		for(int i=0; i<n; ++i){ map ~= repeat(0).take(n).array; }
		int count;
		
		int[2] ptr = [n/2, n/2+1];
		while(count<n*n){
			while(map[ptr[1]][ptr[0]]!=0){
				ptr[0] = (ptr[0] + n-1)%n;
				++ptr[1] %= n;
			}
			
			map[ptr[1]][ptr[0]] = ++count;
			++ptr[0] %= n;
			++ptr[1] %= n;
		}
		
		for(int y=0; y<n; ++y){
			for(int x=0; x<n; ++x){
				writef(,map[y][x]);
			}
			.write;
		}
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.array;
import std.algorithm;
import std.regex;
import std.container : SList;
void main() {
    char[] str;
    while((str = readln().dup).length != 0) {
        char[] ans = resolve(str);
        write(ans);
    }
}
char[] resolve(char[] str) {
    for (int c = 0; c < 'z'-'a' + 1; ++c) {
        for (int i = 0; i < str.length; ++i) {
            if ('a' <= str[i] && str[i] <= 'z') {
                if (str[i] == 'z') {
                    str[i] = 'a';
                } else {
                    str[i] += 1;
                }
            }
        }
        char[][] sxx = split(str);
        
        if (my_match(cast(immutable)str)) {
            break;
        }
    }
    return str;
}
bool my_match(string str) {
    if (match(str, r)) {
        return true;
    }
    return false;
}
bool contains_any(T, U...)(T[] arr, U elms) {
    foreach(elm ; elms) {
        if (!find(arr, elm).empty) {
            return true;
        }
    }
    return false;
}"
D,"import std.stdio;
import std.string;
import std.algorithm;
void main() {
    foreach (input; stdin.byLine) {
        
        string result = judge(input.chomp);
        
        result.writeln;
    }
}
string judge(char[] banmen) {
    
    auto combs = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    
    auto areas = [:getArea(banmen, 'o'), :getArea(banmen, 'x')];
    
    foreach(key; areas.keys) {
        foreach(comb; combs) {
            if(canFind(areas[key], comb[0]) &&
               canFind(areas[key], comb[1]) &&
               canFind(areas[key], comb[2])) return key;
        }
    }
    
    return ;
}
int[] getArea(char[] banmen, char side) {
    int[] area = [];
    foreach (i; 0..9) {
        if(banmen[i] == side) { area ~= i; }
    }
    return area;
}"
D,"import std.stdio;
import std.conv;
import std.string;
import std.typecons;
import std.algorithm;
import std.array;
import std.range;
import std.math;
import std.container;
void main()
{
	foreach (line; stdin.byLine) {
    int cnt[10];
    foreach (e; line.chomp) {
      cnt[e-'0']++;
    }
    int[int] res;
    foreach (i; 1..10) {
      auto tcnt = cnt.dup;
      tcnt[i]++;
      bool f1;
      foreach (j; 1..10) {
        if (tcnt[j] > 4) f1 = 1;
      }
      if (f1) continue;
      foreach (j; 1..10) {
        if (tcnt[j] < 2) continue;
        auto ttcnt = tcnt.dup;
        ttcnt[j] -= 2;
        bool f2;
        foreach (k; 1..10) {
          if (ttcnt[k] >= 3) {
            ttcnt[k] -= 3;
          }
          if (ttcnt[k] && k <= 7) {
            if (ttcnt[k] <= ttcnt[k+1] && ttcnt[k] <= ttcnt[k+2]) {
              ttcnt[k+1] -= ttcnt[k];
              ttcnt[k+2] -= ttcnt[k];
              ttcnt[k] = 0;
            }
          }
          if (ttcnt[k]) {
            f2 = 1;
            break;
          }
        }
        if (f2) continue;
        res[i]++;
        break;
      }
    }
    if (!res.keys.length) res[0]++;
    res.keys.sort.map!(to!string).join().writeln;
  }
}"
D,"import std.stdio;
import std.string;
/+
const int LEFT  = 0;
const int RIGHT = 1;
const int UP    = 2;
const int DOWN  = 3;
+/
enum {
    LEFT,
    RIGHT,
    UP,
    DOWN
}
void main()
{
    string[9] kabe;
    int x, y;
    int direction;
    foreach (i; 0..9) {
        kabe[i] = readln().chomp;
        kabe[i].length = 18;
    }
    x = 0;
    y = 0;
    direction = RIGHT;
    move(&x, &y, direction);
    while (x != 0 || y != 0) {
        if (isKabe(kabe, x, y, getLeft(direction)))
            direction = getLeft(direction);
        else if (isKabe(kabe, x, y, direction))
            {}
        else if (isKabe(kabe, x, y, getRight(direction)))
            direction = getRight(direction);
        else
            direction = getRight(getRight(direction));
        move(&x, &y, direction);
    }
    writeln();
}
bool isKabe(string[9] kabe, int x, int y, int dir)
{
    final switch (dir) {
    case LEFT:
        if (x <= 0) return false;
        return (kabe[y*2][x-1] == '1');
        break;
    case RIGHT:
        if (x >= 4) return false;
        return (kabe[y*2][x] == '1');
        break;
    case UP:
        if (y <= 0) return false;
        return (kabe[y*2-1][x] == '1');
        break;
    case DOWN:
        if (y >= 4) return false;
        return (kabe[y*2+1][x] == '1');
        break;
    }
    return false;
}
int getLeft(int dir)
{
    final switch (dir) {
    case LEFT: return DOWN; break;
    case RIGHT: return UP; break;
    case UP: return LEFT; break;
    case DOWN: return RIGHT; break;
    }
    return 0;
}
int getRight(int dir)
{
    final switch (dir) {
    case LEFT: return UP; break;
    case RIGHT: return DOWN; break;
    case UP: return RIGHT; break;
    case DOWN: return LEFT; break;
    }
    return 0;
}
void move(int* x, int* y, int dir)
{
    final switch (dir) {
    case LEFT:
        (*x)--;
        write();
        break;
    case RIGHT:
        (*x)++;
        write();
        break;
    case UP:
        (*y)--;
        write();
        break;
    case DOWN:
        (*y)++;
        write();
        break;
    }
}"
D,"import std.stdio;
import std.algorithm;
import std.array;
import std.conv;
import std.string;
T[][] permulate(T)(T[] items) {
  T[][] res;
  if (items.length == 1) return [items];
  foreach(uint i, T item; items) {
    res ~= remove(items.dup, i).permulate.map!((x) => item ~ x).array;
  }
  return res;
}
void solve(int[] items) {
  auto ops =
    [
     '+':(int x, int y) => x + y,
     '-':(int x, int y) => x - y,
     '*':(int x, int y) => x * y];
  
  foreach(i; permulate!(int)(items).sort) {
    foreach(char a_ch, a; ops) {
      foreach(char b_ch, b; ops) {
        foreach(char c_ch, c; ops) {
          auto num1 = a(b(c(i[0], i[1]), i[2]), i[3]);
          auto num2 = a(b(i[0], i[1]), c(i[2], i[3]));
          if (num1 == 10) {
            writeln(, i[0], , c_ch, , i[1], , b_ch, , i[2], , a_ch, , i[3], );
            goto end;
          }
          else if (num2 == 10) {
            writeln(, i[0], , b_ch, , i[1], , a_ch, , i[2], , c_ch, , i[3], );
            goto end;
          }
        }
      }
    }
  }
  writeln(0);
 end:;
}
void main() {
  while(true) {
    int[] list = readln().chomp.split().map!(to!(int)).array;
    if (list.filter!(x => x != 0).array == null) break;
    solve(list);
  }
}"
D,"import std.stdio;
import std.conv;
import std.string;
import std.algorithm;
import std.array;
int[] solve(int[][] items, int limit) {
  int[][] dp = new int[][](items.length + 1, limit + 1);
  int[int] weight;
  for(int i = 0; i < items.length; i++) {
    for(int j = 0; j <= limit; j++) {
      if (j < items[i][1]) {
        dp[i + 1][j] = dp[i][j];
      } else {
        int v = dp[i][j - items[i][1]] + items[i][0];
        if (v > dp[i][j]) {
          dp[i + 1][j] = v;
          if (v in weight) {
            weight[v] = min(weight[v], j);
          } else {
            weight[v] = j;
          }
        } else {
          dp[i + 1][j] = dp[i][j];
        }
      }
    }
  }
  return [dp[items.length][limit], weight[dp[items.length][limit]]];
}
int readnum() {return readln.chomp.to!(int);}
void main() {
  uint index = 1;
  while(true) {
    int limit = readnum;
    if (limit == 0) break;
    int times = readnum;
    int[][] items;
    foreach(t; 0..times) {
      items ~= readln.chomp.split().map!(to!(int)).array;
    }
    writeln(, index++, );
    solve(items, limit).map!(to!(string)).join().writeln;
  }
}"
D,"import std.stdio;
import std.string;
import std.math;
import std.conv;
import std.algorithm;
import std.bigint;
void main(){
    int[10][10] map;
    while(true){
	auto s = split(chomp(readln()),',');
	if(stdin.eof()) break;
	int x,y,size;
	x = to!int(s[0]);
	y = to!int(s[1]);
	size = to!int(s[2]);
	if(size >0){
	    auto d = [1,0,-1,0 ,0];
	    auto d1 = [0,1,0,-1,0];
	    for(int i=0;i<5;i++){
		if(0 <= d[i] + x &&  d[i] + x < 10 && 0 <= d1[i] + y &&  d1[i] + y < 10){
		    map[d[i] + x][d1[i] + y]++;
		}
	    }
	}
	size--;
	if(size>0){
	    auto d = [ 1,-1];
	    for(int i=0;i<2;i++){
		for(int j=0;j<2;j++){
		    if(0 <= d[i] + x &&  d[i] + x < 10 && 0 <= d[j] + y &&  d[j] + y < 10){
			map[d[i] + x][d[j] + y]++;
		    }
		}
	    }
	}
	size--;
	if(size>0){
	    auto d = [2,0,-2,0,0];
	    auto d1 = [0,2,0,-2,0];
	    for(int i=0;i<5;i++){
		if(0 <= d[i] + x &&  d[i] + x < 10 && 0 <= d1[i] + y &&  d1[i] + y < 10){
		    map[d[i] + x][d1[i] + y]++;
		}
	    }
	}
    }
    int ans1 = 0,ans2=0;
    for(int i=0;i<10;i++){
	for(int j=0;j<10;j++){
	    if(map[i][j] == 0) ans1++;
	    ans2 = max(map[i][j] , ans2);
	}
    }
    writeln(ans1);
    writeln(ans2);
}"
D,"import std.stdio : writeln, write, stdin;
import std.array;
import std.range;
import std.algorithm : filter, min;
int INF = 1<<28;
int solve(int[][] map, int n){
	int ptr = 0;
	bool[] done = new bool[n];
	int[] last = new int[n];
	int[] list = repeat(INF).take(n).array;
	list[ptr] = 0;
	while(true){
		int min_ = INF;
		for(int i=0; i<n; ++i){
			if(!done[i]){
				if(list[i] < min_){
					min_ = list[i];
					ptr = i;
				}
			}
		}
		if(min_==INF){ break; }
		
		done[ptr] = true;
		for(int i=0; i<n; ++i){
			if(!done[i]){
				if(map[ptr][i] < INF){
					if(map[ptr][i] < list[i]){
						list[i] = map[ptr][i];
					}
				}
			}
		}
	}
	assert(filter!(a => a==INF)(list).array.length==0);
	
	int count = 0;
	foreach(ite; filter!(a => a!=0)(list).array){
		count += ite -1;
	}
	
	return count;
}
void main(){
	while(true){
		delim = ;
		int n = next!int();
		
		if(n==0){ break; }
		
		int m = next!int();
		int[][] map;
		foreach(i; n.iota){
			map ~= repeat(INF).take(n).array;
		}
		delim = ;
		for(int i=0; i<m; ++i){
			int a = next!int();
			int b = next!int();
			int d = next!int()/100;
			
			map[a][b] = d;
			map[b][a] = d;
		}
		
		solve(map, n).writeln;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"module Main;
import std.stdio;
import std.string;
import std.conv;
import std.array;
import std.math;
import std.algorithm;
void main() {
    string input;
    immutable limitList = 50022;
    bool[] listPrimeNumber = new bool[](limitList);
    int number, primeNumberSmaller, primeNumberBigger;
    listPrimeNumber.fill(true);
    foreach (i; 2..limitList.to!double.sqrt.to!int) {
        if (listPrimeNumber[i]) {
            for (int j = i*2; j < limitList; j += i) listPrimeNumber[j] = false;
        }
    }
    while ((input = readln.chomp).length != 0) {
        number = input.to!int;
        primeNumberSmaller = getPrimeNumber(listPrimeNumber, number, false);
        primeNumberBigger  = getPrimeNumber(listPrimeNumber, number, true);
        writeln(primeNumberSmaller, , primeNumberBigger);
    }
}
int getPrimeNumber(in bool[] list, in int input, in bool flagBigger) {
    int temp;
    if (flagBigger) {
        temp = input + 1;
    } else {
        temp = input - 1;
    }
    if (list[temp]) {
        return temp;
    } else {
        return getPrimeNumber(list, temp, flagBigger);
    }
}"
D,"import std.stdio : writeln, write, stdin;
import std.array;
import std.range;
import std.algorithm : max;
void main(){
	int n = next!int();
	for(int i=0; i<n; ++i){
		readln;
		
		bool[8][8] map;
		for(int y=0; y<8; ++y){
			string str = next!string();
			for(int x=0; x<8; ++x){
				map[y][x] = str[x]=='1';
			}
		}
		int X = next!int() -1;
		int Y = next!int() -1;
		
		int[2][] queue;
		queue ~= [X, Y];
		while(queue.length > 0){
			auto p = queue.front;
			queue.popFront;
			
			int x_ = p[0];
			int y_ = p[1];
			if(map[y_][x_]){
				map[y_][x_] = false;
				for(int x = x_-3; x <= x_+3; ++x){
					if(0<=x && x<8){
						if(map[y_][x]){
							queue ~= [x, y_];
						}
					}
				}
				for(int y = y_-3; y <= y_+3; ++y){
					if(0<=y && y<8){
						if(map[y][x_]){
							queue ~= [x_, y];
						}
					}
				}
			}
		}
		
		writeln(, i+1, );
		for(int y=0; y<8; ++y){
			for(int x=0; x<8; ++x){
				write(map[y][x] ? 1 : 0);
			}
			write('\\n');
		}
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio : write, writeln, writefln, stdin;
import std.array;
import std.range;
import std.typecons;
import std.algorithm : max;
import std.math;
alias Tuple!(real, real) P;
void main(){
	delim = ;
	
	while(true){
		int n = next!int();
		if(n==0){ break; }
		
		P[] p = new P[n];
		foreach(i; n.iota){
			p[i][0] = next!real();
			p[i][1] = next!real();
		}
		
		P[] cross;
		foreach(i; n.iota){
			foreach(j; iota(i+1, n)){
				if(i!=j){
					P a = p[i];
					P b = p[j];
					
					real[2] v = [b[0]-a[0], b[1]-a[1]];
					real[] res_x, res_y;
					if(-real.epsilon <= v[1] && v[1] <= real.epsilon){
						res_y = f_y([], v);
						res_x = f_x(res_y, v);
					}else{
						res_x = f_x([], v);
						res_y = f_y(res_x, v);
					}
					
					foreach(k; res_x.length.iota){
						P p_;
						p_[0] = a[0] + res_x[k];
						p_[1] = a[1] + res_y[k];
						
						cross ~= p_;
					}
				}
			}
		}
		debug(1) { cross.dbg; }
		
		int max_;
		foreach(i; cross){
			int cnt;
			foreach(j; p){
				if([j[0]-i[0], j[1]-i[1]].d <= 1. + real.epsilon){
					++cnt;
				}
			}
			max_ = max(max_, cnt);
		}
		max_ = max(max_, 1);
		
		writeln = max_;
	}
}
real d(real[2] p){
	return sqrt(p[0]*p[0] + p[1]*p[1]);
}
real[] f_x(real[] y, real[2] p){
	if(-real.epsilon <= p[1] && p[1] <= real.epsilon){
		real[] res_x;
		
		foreach(ite; y){
			res_x ~= (p[0]*p[0] -2.*p[1]*ite + p[1]*p[1])/(2.*p[0]);
		}
		
		return res_x;
	}else{
		real a = 1. + (p[0]*p[0])/(p[1]*p[1]);
		real b = -(p[0]/p[1])*(p[0]*p[0] + p[1]*p[1])/(p[1]);
		real c = (p[0]*p[0] + p[1]*p[1])/(2.*p[1]);	c=c*c -1.;
		
		real D = b*b - 4.*a*c;
		if(D < -real.epsilon){
			return [];
		}else if(-real.epsilon <= D && D <= real.epsilon){
			return [(-b)/(2.*a)];
		}else{
			debug(1){ dbg(, a, b, c, [(-b + sqrt(D))/(2.*a), (-b - sqrt(D))/(2.*a)]); }
			return [(-b + sqrt(D))/(2.*a), (-b - sqrt(D))/(2.*a)];
		}
	}
}
real[] f_y(real[] x, real[2] p){
	if(-real.epsilon <= p[1] && p[1] <= real.epsilon){
		real a = 1. + (p[1]*p[1])/(p[0]*p[0]);
		real b = -(p[1]/p[0])*(p[0]*p[0] + p[1]*p[1])/(p[0]);
		real c = (p[0]*p[0] + p[1]*p[1])/(2.*p[0]);	c=c*c -1.;
		
		real D = b*b - 4.*a*c;
		if(D < -real.epsilon){
			return [];
		}else if(-real.epsilon <= D && D <= real.epsilon){
			return [(-b)/(2.*a)];
		}else{
			return [(-b + sqrt(D))/(2.*a), (-b - sqrt(D))/(2.*a)];
		}
	}else{
		real[] res_y;
		
		foreach(i; x){
			debug(1){ dbg(i.stringof, i); }
			res_y ~= (p[0]*p[0] -2.*p[0]*i + p[1]*p[1])/(2.*p[1]);
		}
	
		return res_y;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio : write;
import std.array;
import std.range;
void main(){
	while(hasNext){
		
		for(char* p = (next!string().dup ~ ).ptr; *p!='\\0'; ++p){
			if(*p == '@'){
				int l = *(++p) - '0';
				++p;
				foreach(i; l.iota){
					(*p).to!string.write;
				}
			}else{
				(*p).to!string.write;
			}
		}
		.write;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio,std.string,std.conv,std.algorithm;
int ans[10];
void solve(int a[10],int n)
{
	int count = 0;
	foreach(i;0..a.length) count += a[i];
	if(count == 0)
	{
		ans[n] = 1;
		return;
	}
	foreach(i;1..10)
	{
		if(a[i] >= 3)
		{
			a[i] -= 3;
			solve(a,n);
			a[i] += 3;
		}
	}
	foreach(i;3..10)
	{
		if(a[i-2] && a[i-1] && a[i])
		{
			a[i-2]--; a[i-1]--; a[i]--;
			solve(a,n);
			a[i-2]++; a[i-1]++; a[i]++;
		}
	}
}
int main()
{
	string s;
	while((s = readln.chomp).length != 0)
	{
		foreach(i;0..10)
		{
			ans[i] = 0;
		}
		int a[10];
		foreach(i;0..s.length) a[s[i] - '0']++;
		foreach(i;1..10)
		{
			if(a[i] == 4)
			{
				continue;
			}
			else
			{
				a[i]++;
				foreach(j;1..10)
				{
					if(a[j] >= 2)
					{
						a[j] -= 2;
						solve(a,i);
						a[j] += 2;
					}
				}
				a[i]--;
			}
		}
		bool count_0 = true;
		int ans_max = 0;
		foreach(i;0..10)
		{
			if(ans[i])
			{
				if(ans[i])
				{
					count_0 = false;
					ans_max = max(ans_max,i);
				}
			}
		}
		if(count_0)
		{
			0.writeln;
		}
		else
		{
			bool flag = true;
			foreach(i;1..10)
			{
				if(ans[i] == 1)
				{
					if(i == ans_max)
					{
						i.writeln;
					}
					else
					{
						write(i,);
					}
				}
			}
		}
	}
	return 0;
}"
D,"import std.stdio;
import std.string;
import std.conv;
import std.algorithm;
string Sorting_String(string s) {
    char[] str;
    for (int i = 0; i < s.length; i++)
        str ~= s[i];
    for (int i = 0; i < str.length; i++)
        for (int j = i + 1; j < str.length; j++) {
            if (str[i] > str[j]) {
                auto tmp = str[i];
                str[i] = str[j];
                str[j] = tmp;
            }
        }
    
    return to!string(str);
}
int Change_To_Int(string s) {
    int res = 0;
    for (int i = 1; i < s.length; i++)
        res += ((to!int(s[i]) - 48) * ((10 ^^ i) / 10));
    
    return res;
}
int Reverse_To_Int(string s) {
    char[] str;
    str ~= ;
    for (int i = 1; i < s.length; i++)
        str ~= s[s.length - i];
    int res = Change_To_Int(to!string(str));
    
    return res;
}
int main()
{
    int N;
    N = readln().chomp().to!int();
    
    for (int i = 0; i < N; i++) {
        string s = readln();
        auto str = Sorting_String(s);
        int num1 = Change_To_Int(str);
        int num2 = Reverse_To_Int(str);
        int ans = num1 - num2;
        writeln(ans);
    }
    return 0;
}"
D,"import std.cstream;
import std.stdio;
import std.string;
import std.algorithm;
 
void main(){
 
string inc=readln();
/+inc = chomp(inc);/+ /+改/+行+/を/+と+/る+/ +/ +/
 
int[string] mostLongestHash;
int[string] frequent;
int first,ansLength,ansFrequent;
 
 
  for(int i/+ use 0 as default +/;i<inc.length;i++){
    if(inc[i] == ' ' || i == inc.length-1){
     mostLongestHash[inc[first..i]]=cast(int)inc[first..i].length;
     ansLength = max(cast(int)inc[first..i].length,ansLength);
     ansFrequent = max(++frequent[inc[first..i]],ansFrequent);
    /+
     writeln(inc[first..i]);
     writeln(mostLongestHash[inc[first..i]]);
     writeln(frequent[inc[first..i]]);
     writeln(ansLength);
     writeln(ansFrequent);
    +/
     first=i+1;
    }
  }
 
  
 
first=0;
  for(int i=0;i<inc.length;i++){
    if(inc[i] == ' ' || i == inc.length-1){
      if(frequent[inc[first..i]] == ansFrequent){
      write(inc[first..i]);
      write();
      break;
      }
      first=i+1;
    }
  }
 
first=0;
  for(int i=0;i<inc.length;i++){
    if(inc[i] == ' ' || i == inc.length-1){
      if(mostLongestHash[inc[first..i]] == ansLength){
      writeln(inc[first..i]);
      break;
      }
      first=i+1;
    }
  }
 
 
 
}"
D,"import std.stdio, std.string, std.conv, std.algorithm;
void main()
{
    int[][] dp = new int[][](1001, 10001);
    int cases = 1;
    while(true)
    {
        int w = readln.chomp.to!int;
        if(!w)break;
        int n = readln.chomp.to!int;
        int[1001] treValue, treWeit;
        foreach(i; 1 .. n + 1)
        {
            auto f = readln.chomp.split().map!(to!int);
            treValue[i] = f[0];
            treWeit[i] = f[1];
        }
        foreach(i; 1 .. n + 1)
        {
            foreach(j; 1 .. w + 1)
            {
                if(treWeit[i] > j || dp[i - 1][j - treWeit[i]] + treValue[i] <= dp[i - 1][j])
                {
                    dp[i][j] = dp[i - 1][j];
                }
                else
                {
                    dp[i][j] = dp[i - 1][j - treWeit[i]] + treValue[i];
                }
            }
        }
        int maxValue = int.min, minWeit;
        foreach(i; 1 .. w + 1)
        {
            if(dp[n][i] > maxValue)
            {
                maxValue = dp[n][i];
                minWeit = i;
            }
        }
        writeln(, cases, );
        maxValue.writeln;
        minWeit.writeln;
        ++cases;
    }
}"
D,"import std.stdio : write, writeln, writefln, stdin;
import std.array;
import std.range;
import std.typecons;
import std.algorithm : max, min;
void main(){
	while(true){
		int n = next!int();
		if(n==0){ break; }
		
		int[] buf = repeat(0).take(n).array;
		int max_;
		for(int y=0; y<n; ++y){
			string s = next!string();
			int[] d = repeat(0).take(n).array;
			if(s[0]=='.') d[0]=1;
			for(int x=1; x<n; ++x){
				if(s[x]=='.'){
					int min_ = 1<<28;
					min_ = min(min_, d[x-1]);
					min_ = min(min_, buf[x-1]);
					min_ = min(min_, buf[x]);
					d[x] = min_+1;
					
					max_ = max(max_, d[x]);
				}
			}
			buf = d.dup;
		}
		
		writeln = max_;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
import std.math, std.format;
alias real F;
F area(F x1, F y1, F x2, F y2, F x3, F y3)
{
    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2;
}
F distance(F x1, F y1, F x2, F y2)
{
    return hypot(x1-x2,y1-y2);
}
F cross(F x1, F y1, F x2, F y2)
{
    return x1*y2-y1*x2;
}
F norm2(F x, F y)
{
    return x*x+y*y;
}
string r3(F v){ return format(,round(v*10^^3)/10^^3+0); }
void main()
{
    foreach(_;0..readln().chomp().to!int())
    {
        auto m = readln().split().map!(to!F);
        immutable x1=m[0], y1=m[1], x2=m[2], y2=m[3], x3=m[4], y3=m[5];
        immutable ax=2*(x2-x1), ay=2*(x3-x1);
        immutable bx=2*(y2-y1), by=2*(y3-y1);
        immutable cx=norm2(x1,y1)-norm2(x2,y2),
                  cy=norm2(x1,y1)-norm2(x3,y3);
        immutable x = cross(bx,by,cx,cy)/cross(ax,ay,bx,by);
        immutable y = cross(cx,cy,ax,ay)/cross(ax,ay,bx,by);
        immutable a = distance(x2,y2,x3,y3);
        immutable b = distance(x3,y3,x1,y1);
        immutable c = distance(x1,y1,x2,y2);
        immutable R = a*b*c/(area(x1,y1,x2,y2,x3,y3)*4);
        writeln(r3(x),,r3(y),,r3(R));
    }
}"
D,"import std.stdio, std.string, std.conv, std.algorithm, std.numeric;
import std.range, std.array, std.math, std.typecons, std.container, core.bitop;
void main() {
    string s;
    scan(s);
    writeln(s.retro());
}
void scan(T...)(ref T args) {
    string[] line = readln.split;
    foreach (ref arg; args) {
        arg = line.front.to!(typeof(arg));
        line.popFront();
    }
    assert(line.empty);
}
void fillAll(R, T)(ref R arr, T value) {
    static if (is(typeof(arr[] = value))) {
        arr[] = value;
    }
    else {
        foreach (ref e; arr) {
            fillAll(e, value);
        }
    }
}
struct Queue(T) {
    private {
        int N, head, tail;
        T[] data;
    }
    this(int n) {
        N = n + 1;
        data = new T[](N);
    }
    bool empty() {
        return head == tail;
    }
    bool full() {
        return (tail + 1) % N == head;
    }
    T front() {
        return data[head];
    }
    void push(T x) {
        assert(!full);
        data[tail++] = x;
        tail %= N;
    }
    void pop() {
        assert(!empty);
        head = (head + 1) % N;
    }
    void clear() {
        head = tail = 0;
    }
}"
D,"import std.stdio, std.conv, std.array, std.algorithm, std.string, std.math;
void main() {
    string s;
    while ((s = readln()).length != 0) {
        int[] nx;
        if (to!uint(s.chomp) == 0) {break;}
        for (uint i = 0; i < to!uint(s.chomp); ++i) {
            nx ~= to!int(readln().chomp);   
        }
        writeln(solve(nx));
    }
}
int solve(int[] tx) {
    if (negative_all(tx)) {
        int max = -100000;
        foreach(n ; tx) {
            if (n > max) {
                max = n;   
            }
        }
        return max;
    }
    
    int[] nx = reduce_by_sign(tx);
    
    if (nx.length == 1)      { return nx[0]; }
    
    if (nx[0] < 0)           { nx = nx[1..(nx.length)]; }
    if (nx[nx.length-1] < 0) { nx = nx[0..(nx.length-1)]; }
    /*for (uint i = 0; i < nx.length; ++i) {
        if (nx[i] < 0) {
            if (nx[i-1] >= abs(nx[i]) && nx[i+1] >= abs(nx[i])) {
                int t = nx[i-1] + nx[i] + nx[i+1];
                if (i+2 < nx.length) {
                    nx = nx[0..i-1] ~ [t] ~ nx[i+2..nx.length];
                } else {
                    nx = nx[0..i-1] ~ [t];
                }
            }
        }
    }
    int max = 0;
    foreach(n ; nx) {
        if (max < n) {
           max = n;   
        }
    }*/
    int max = nx[0];
    for (uint i = 0; i < nx.length; ++i) {
        int max_ = nx[i];
        int acc = max_;
        for (uint j = i+1; j < nx.length; ++j) {
            acc = acc + nx[j];
            if (acc > max_) { max_ = acc; }
        }
        if (max_ > max) { max = max_; }
    }
    
    return max;
}
bool negative_all(int[] nx) {
    foreach(n ; nx) {
        if (n > 0) {
            return false;
        }
    }
    return true;
}
int[] reduce_by_sign(int[] nx) {
    bool sign = (nx[0] >= 0);
    uint index = 0;
    int[] ret = [nx[0]];
    
    for (uint i = 1; i < nx.length; ++i) {
        if (sign != (0 <= nx[i])) {
            sign = !sign;
            ret ~= 0;
            ++index;
        }
            
        ret[index] += nx[i];
    }
    return ret;
}"
D,"import std.stdio, std.conv, std.algorithm;
import std.range, std.array, std.math;
void dump(int[][] field, int n) {
  for(int i = 0; i <= n + 1; i++) {
    for(int j = 0; j <= n + 1; j++) {
      writef(, field[i][j], j == (n + 1) ?  : );
    }
  }
}
void main() {
  int edge;
  while(readf(, &edge), edge != 0) {
    int[][] field = new int[][](1002, 1002);
    for(int i = 0; i <= (edge + 1); i++) {
      field[0][i] = 0;
      field[i][0] = 0;
      field[edge + 1][i] = 0;
      field[i][edge + 1] = 0;
    }
    for(int i = 1; i <= edge; i++) {
      string s = readln;;
      for(int j = 0; j < edge; j++) {
        switch(s[j]) {
        case '*':
          field[i][j + 1] = 0;
          break;
        case '.':
          field[i][j + 1] = 1;
          break;
        default:
          throw new Exception();
        }
      }
    }
    int square = 0;
    for(int i = edge; i >= 1; i--) {
      for(int j = edge; j >= 1; j--) {
        if (field[i][j] == 0) continue;
        field[i][j] =
          min(field[i][j + 1], field[i + 1][j], field[i + 1][j + 1]) + 1;
        square = max(square, field[i][j]);
      }
    }
    writeln(square);
  }
}"
D,"import std.algorithm;
import std.array;
import std.conv;
import std.math;
import std.range;
import std.stdio;
import std.string;
import std.typecons;
T read(T)() { return readln.chomp.to!T; }
T[] reads(T)() { return readln.split.to!(T[]); }
alias readint = read!int;
alias readints = reads!int;
int calc(int n, int s) {
    int ans = 0;
    foreach (e; combinations(iota(10).array, n)) {
        if (e.sum == s)
            ans++;
    }
    return ans;
}
void main() {
    while (true) {
        auto xs = readints;
        int n = xs[0], s = xs[1];
        if (n == 0 && s == 0) break;
        writeln(calc(n, s));
    }
}
Combinations!T combinations(T)(T[] xs, int n) {
    return Combinations!T(xs, n);
}
struct Combinations(T) {
    private T[] _source;
    private int _n;
    private T[][] _q;
    private int _state;
    this(T[] source, int n) {
        _source = source.dup;
        _n = n;
        _state = 0;
        pushNext();
    }
    @property T[] front() {
        return _q[0];
    }
    void popFront() {
        _q = _q[1..$];
        pushNext();
    }
    bool empty() {
        return _q.length == 0;
    }
    private void pushNext() {
        int len = cast(int)_source.length;
        while (_state < (1 << len)) {
            int[] buf;
            for (int j = 0; j < len; j++) {
                if (_state & (1 << j)) {
                    buf ~= _source[j];
                    if (buf.length > _n) break;
                }
            }
            _state++;
            if (buf.length == _n) {
                _q ~= buf;
                return;
            }
        }
    }
}"
D,"import std.stdio,std.string,std.conv,std.array,std.algorithm;
struct Point
{
	double x,y;
	this(double a,double b)
	{
		this.x = a;
		this.y = b;
	}
	Point opBinary(string s)(Point p) if(s == )
	{
		p.x = x - p.x;
		p.y = y - p.y;
		return p;
	}
	double det(Point a)
	{
		return this.x * a.y - this.y * a.x;
	}
}
Point[] convex_hull(Point[] ps)
{
	int n = cast(int)ps.length;
	int k = 0;
	sort!((a, b) 
	{
		if (a.x != b.x)  
		{
			return a.x < b.x;
		}
		else
		{
			return a.y < b.y;
		}
	})(ps);
	Point[] convex = new Point[n*2];
	foreach(i;0..n)
	{
		while (2 <= k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )
		{
			k--;
		}
		convex[k++] = ps[i];
	}
	
	for(int i = n-2,t = k; 0 <= i;i--)
	{
		while (t < k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )
		{
			k--;
		}
		convex[ k++ ] = ps[i];
	}
	convex.length = k - 1;
	return convex;
}
int main()
{
	int n;
	while((n = readln.chomp.to!int) != 0)
	{
		Point[] ps;
		ps.length = n;
		foreach(i;0..n)
		{
			string[] _s = readln.chomp.split();
			ps[i].x = _s[0].to!double;
			ps[i].y = _s[1].to!double;
		}
		Point[] convex = convex_hull(ps);
		writeln(n - convex.length);
	}
	return 0;
}"
D,"import std.stdio;
import std.string;
import std.conv;
import std.array;
import std.range;
import std.algorithm;
void main() {
    string input;
    while ((input = readln.chomp).length != 0) {
        int[] tehai = new int[](9);
        int[] yama = new int[](9);
        int[] ans;
        fill(yama, 4);
        foreach (i; 0..13) {
            int index = (input[i] - '0').to!int;
            tehai[index-1]++;
            yama[index-1]--;
        }
        ans = agari(tehai, yama);
        if (ans.length == 0) {
            writeln(0);
        } else {
            writeln(ans.map!(to!string).join());
        }
    }
}
/*
 * 何を自摸れば、上がれるかを判定する。
 * 上がることのできる牌を見つけたら、それをすべて配列に格納して返す。
 * 上がることができなければ、空の配列が返される。
 */
int[] agari(int[] tehai, int[] yama) {
    int[] ans;
    foreach (i; 0..tehai.length) {
        if (yama[i] == 0) continue;
        tehai[i]++;
        foreach (j; 0..tehai.length) {
            if (tehai[j] < 2) continue;
            tehai[j] -= 2;
            if (yaku(tehai, 0)) ans ~= (i + 1).to!int;
            tehai[j] += 2;
        }
        tehai[i]--;
    }
    return ans;
}
/*
 * 手持ちの牌で役が作れるかを判定する。
 * 順子、刻子の順番で試行し、組み合わせが４個できた時点で true を返し、組み合わせが４個できる前に順子、刻子ともに見つからなかったときは false を返す。
 */
bool yaku(int[] haipai, int num_yaku) {
    if (num_yaku >= 4) return true;
    int[] tehai;
    foreach (i; 0..haipai.length) {
        
        if (i >= 2 && haipai[i - 2] > 0 && haipai[i - 1] > 0 && haipai[i] > 0) {
            tehai = haipai.dup;
            tehai[i - 2]--;
            tehai[i - 1]--;
            tehai[i]--;
            return yaku(tehai, ++num_yaku);
        }
        
        if (haipai[i] >= 3) {
            tehai = haipai.dup;
            tehai[i] -= 3;
            return yaku(tehai, ++num_yaku);
        }
    }
    return false;
}"
D,"import std.stdio : write, writeln, writefln, stdin;
import std.array;
import std.range;
import std.typecons;
import std.algorithm : max;
import std.math;
alias Tuple!(real, real) P;
void main(){
	delim = ;
	
	while(true){
		int n = next!int();
		if(n==0){ break; }
		
		P[] p = new P[n];
		foreach(i; n.iota){
			p[i][0] = next!real();
			p[i][1] = next!real();
		}
		
		P[] cross;
		foreach(i; n.iota){
			foreach(j; iota(i+1, n)){
				if(i!=j){
					P a = p[i];
					P b = p[j];
					
					real[2] v = [b[0]-a[0], b[1]-a[1]];
					real[] res_x, res_y;
					if(-real.epsilon <= v[1] && v[1] <= real.epsilon){
						res_y = f_y([], v);
						res_x = f_x(res_y, v);
					}else{
						res_x = f_x([], v);
						res_y = f_y(res_x, v);
					}
					
					foreach(k; res_x.length.iota){
						P p_;
						p_[0] = a[0] + res_x[k];
						p_[1] = a[1] + res_y[k];
						
						cross ~= p_;
					}
				}
			}
		}
		debug(1) { cross.dbg; }
		
		int max_;
		foreach(i; cross){
			int cnt;
			foreach(j; p){
				if([j[0]-i[0], j[1]-i[1]].d <= 1. + double.epsilon){
					++cnt;
				}
			}
			max_ = max(max_, cnt);
		}
		max_ = max(max_, 1);
		
		writeln = max_;
	}
}
real d(real[2] p){
	return sqrt(p[0]*p[0] + p[1]*p[1]);
}
real[] f_x(real[] y, real[2] p){
	if(-real.epsilon <= p[1] && p[1] <= real.epsilon){
		real[] res_x;
		
		foreach(ite; y){
			res_x ~= (p[0]*p[0] -2.*p[1]*ite + p[1]*p[1])/(2.*p[0]);
		}
		
		return res_x;
	}else{
		real a = 1. + (p[0]*p[0])/(p[1]*p[1]);
		real b = -(p[0]/p[1])*(p[0]*p[0] + p[1]*p[1])/(p[1]);
		real c = (p[0]*p[0] + p[1]*p[1])/(2.*p[1]);	c=c*c -1.;
		
		real D = b*b - 4.*a*c;
		if(D < -real.epsilon){
			return [];
		}else if(-real.epsilon <= D && D <= real.epsilon){
			return [(-b)/(2.*a)];
		}else{
			debug(1){ dbg(, a, b, c, [(-b + sqrt(D))/(2.*a), (-b - sqrt(D))/(2.*a)]); }
			return [(-b + sqrt(D))/(2.*a), (-b - sqrt(D))/(2.*a)];
		}
	}
}
real[] f_y(real[] x, real[2] p){
	if(-real.epsilon <= p[1] && p[1] <= real.epsilon){
		real a = 1. + (p[1]*p[1])/(p[0]*p[0]);
		real b = -(p[1]/p[0])*(p[0]*p[0] + p[1]*p[1])/(p[0]);
		real c = (p[0]*p[0] + p[1]*p[1])/(2.*p[0]);	c=c*c -1.;
		
		real D = b*b - 4.*a*c;
		if(D < -real.epsilon){
			return [];
		}else if(-real.epsilon <= D && D <= real.epsilon){
			return [(-b)/(2.*a)];
		}else{
			return [(-b + sqrt(D))/(2.*a), (-b - sqrt(D))/(2.*a)];
		}
	}else{
		real[] res_y;
		
		foreach(i; x){
			debug(1){ dbg(i.stringof, i); }
			res_y ~= (p[0]*p[0] -2.*p[0]*i + p[1]*p[1])/(2.*p[1]);
		}
	
		return res_y;
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio;
import std.c.stdio;
import std.range;
import std.array;
import std.functional;
import std.algorithm;
import std.conv;
import std.container;
import std.math;
import std.numeric;
import std.string;
import std.c.string;
import std.regex;
import std.typecons;
int[] 素数集合() {
    const nの最大値 = 1000000;
    auto 表 = new bool[nの最大値];
    表[] = true;
    表[0] = 表[1] = false;
    int[] 集合;
    for (int i = 2; i < nの最大値; i++) {
        if (表[i]) {
            集合 ~= i;
            for (int j = i + i; j < nの最大値; j += i) {
                表[j] = false;
            }
        }
    }
    return 集合;
}
 
void main() {
    int n;
    auto 集合 = 素数集合();
    while (~scanf(, &n)) {
        if (n < 2) {
            writeln(0);
            continue;
        }
        int 下限 = 0, 上限 = cast(int)集合.length;
        while (下限 + 1 < 上限) {
            int 中間 = (下限 + 上限) / 2;
            if (集合[中間] <= n) {
                下限 = 中間;
            } else {
                上限 = 中間;
            }
        }
        writeln(下限 + 1);
    }
}"
