language,code
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <cstdlib>
#include <cmath>
#include <climits>
#include <cfloat>
#include <map>
#include <utility>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <deque>
#include <complex>
#include <stack>
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <ctime>
#include <iterator>
#include <bitset>
#include <numeric>
#include <list>
#include <iomanip>
#if __cplusplus >= 201103L
#include <array>
#include <tuple>
#include <initializer_list>
#include <unordered_set>
#include <unordered_map>
#include <forward_list>
#define cauto const auto&
#define ALL(v) begin(v),end(v)
#else
#define ALL(v) (v).begin(),(v).end()
#endif
using namespace std;
namespace{
typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef vector<int> vint;
typedef vector<vector<int> > vvint;
typedef vector<long long> vll, vLL;
typedef vector<vector<long long> > vvll, vvLL;
#define VV(T) vector<vector< T > >
template <class T>
void initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){
	v.assign(a, vector<T>(b, t));
}
template <class F, class T>
void convert(const F &f, T &t){
	stringstream ss;
	ss << f;
	ss >> t;
}
#define REP(i,n) for(int i=0;i<int(n);++i)
#define RALL(v) (v).rbegin(),(v).rend()
#define MOD 1000000007LL
#define EPS 1e-8
void mainmain(){
	for(int i=1;i<=9;++i)
	for(int j=1;j<=9;++j)
		printf(,i,j,i*j);
}
}
int main() try{
	mainmain();
}
catch(...){}"
C++,"#include<iostream>
#include<string>
#include<sstream>
const int MAX = 9;
class result{
        private:
                int num[MAX + 1][MAX + 1];
        public:
                result(void);
                int getResult(int, int);
};
class output{
        private:
                result *m_pResult;
                std::string m_strLine[MAX * MAX];
        public:
                output(void);
                ~output(void);
                std::string getLine(int);
};
class screan{
        private:
                output *m_pOp;
        public:
                void setOp(output*);
                void writeLine(void);
};
class consoleApp{
        private:
                output *m_pOutput;
                screan *m_pScrean;
        public:
                consoleApp(void);
                ~consoleApp(void);
                void run(void);
};
result::result(){
        for(int i = 1; i <= MAX; i++){
                for(int j = 1; j <= MAX; j++){
                        num[i][j] = i * j;
                }
        }
}
int result::getResult(int x, int y){
        if(x <= MAX && y <= MAX){
                return num[x][y];
        }
}
output::output(){
        m_pResult = new result;
        int count = 0;
        for(int i = 1; i <= MAX; i++){
                for(int j = 1; j <= MAX; j++){
                        std::stringstream ss;
                        ss << i <<  << j <<  << m_pResult->getResult(i, j);
                        m_strLine[count] = ss.str();
                        count++;
                }
        }
}
output::~output(){
        delete m_pResult;
}
std::string output::getLine(int x){
        return m_strLine[x];
}
void screan::setOp(output *op){
        m_pOp = op;
}
void screan::writeLine(){
        for(int i = 0; i < MAX * MAX; i++){
                std::cout << m_pOp->getLine(i) << std::endl;
        }
}
consoleApp::consoleApp(){
        m_pOutput = new output;
        m_pScrean = new screan;
}
consoleApp::~consoleApp(){
        delete m_pScrean;
        delete m_pOutput;
}
void consoleApp::run(){
        m_pScrean->setOp(m_pOutput);
        m_pScrean->writeLine();
}
int main(int argc, char **argv){
        consoleApp *ca = new consoleApp;
        ca->run();
        return 0;
}"
C++,"#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cassert>
#include <climits>
#include <algorithm>
#include <string>
#include <sstream>
#include <complex>
#include <vector>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <set>
#include <fstream>
using namespace std;
#define TOSTRING(x) #x
#define SZ(x) (int)(x).size()
#define REP(i,n) for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REPR(i,n) for(int i=(n)-1;i>=0;i--)
#define ALL(s) (s).begin(), (s).end()
#define so(V) sort(ALL(V))
#define rev(V) reverse(ALL(V))
#define uni(v) v.erase( unique(ALL(v)) , v.end());
#define PAU 
typedef long long unsigned int llu;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<bool> vb;
typedef vector<vi> vvi;
typedef vector<vll> vvll;
typedef vector<vb> vvb;
const double EPS = 1e-9;
const int MOD = 1e9 + 7;
const int INF = (1 << 28);
const ll LINF = 1e18;
const double PI = acos(-1);
int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	FOR(i, 1, 10) {
		FOR(j, 1, 10) {
			cout << i <<  << j <<  << i * j << endl;
		}
	}
	PAU;
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<ll, ll> P;
#define EACH(i,a) for (auto& i : a)
#define FOR(i,a,b) for (ll i=(a);i<(b);i++)
#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)
#define REP(i,n) for (ll i=0;i<(n);i++)
#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)
#define debug(x) cout<<#x<<<<x<<endl
#define pb push_back
#define ALL(a) (a).begin(),(a).end()
const ll linf = 1e18;
const int inf = 1e9;
const double eps = 1e-12;
const double pi = acos(-1);
template<typename T>
istream& operator>>(istream& is, vector<T>& vec) {
	EACH(x,vec) is >> x;
	return is;
}
template<typename T>
ostream& operator<<(ostream& os, vector<T>& vec) {
	REP(i,vec.size()) {
		if (i) os << ;
		os << vec[i];
	}
	return os;
}
template<typename T>
ostream& operator<<(ostream& os, vector< vector<T> >& vec) {
	REP(i,vec.size()) {
		if (i) os << endl;
		os << vec[i];
	}
	return os;
}
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	FOR(i, 1, 10) FOR(j, 1, 10) {
		cout << i <<  << j <<  << i*j << endl;
	}
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std ;
#define pb(n) push_back(n)
#define fi first
#define se second
#define np string::npos
#define X real()
#define Y imag()
#define value(x,y,w,h) (x >= 0 && x < w && y >= 0 && y < h)
#define all(r) (r).begin(),(r).end()
#define gsort(st,en) sort((st),(en),greater<int>())
#define vmax(ary) *max_element(all(ary))
#define vmin(ary) *min_element(all(ary))
#define debug(x) cout<<#x<<<<x<<endl
#define fcout(n) cout<<fixed<<setprecision((n))
#define scout(n) cout<<setw(n)
#define rep(i,n) for(int i = 0; i < (int)(n);++i)
#define repc(i,a,b) for(int i = (a);i < (int)(b);++i)
#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)
#define repa(n,array) for(auto &n :(array))
typedef long long ll ;
typedef deque<int> di ;
typedef deque<ll> dl ;
typedef map<string,int> dict;
typedef complex<double> comd;
typedef pair<int,int> pii;
constexpr int imax = ((1<<30)-1)*2+1 ;
constexpr int inf = 100000000;
constexpr double PI = acos(-1.0) ;
double eps = 1e-10 ;
const int dy[] = {-1,0,1,0};
const int dx[] = {0,-1,0,1};
double CalcDist(comd p1, comd p2){
  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));
}
template <typename T>
void out(deque < T > d)
{
  for(size_t i = 0; i < d.size(); i++)
  {
    debug(d[i]);
  }
}
template<typename T>
T ston(string& str, T n){
  istringstream sin(str) ;
  T num ;
  sin >> num ;
  return num ;
}
int main(){
  cin.tie(0);
  ios::sync_with_stdio(false);
  rep(i,9){
    rep(j,9){
      cout << i+1<<<<j+1 <<<<(i+1)*(j+1)<<endl;
    }
  }
  return 0;
}"
C++,"#include <bits/stdc++.h>
using namespace std;
#define FOR(i, s, n) for(int i = s; i < (int)n; i++)
#define per(i, n) for(int i = n; i >= 0; i--)
#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)
#define FORIT(i, A) for (auto i : A)
#define PRINT(x) cout << (x) << 
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define MP make_pair
#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)
#define SZ(a) int((a).size())
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
#define CLR(a) memset((a), 0 ,sizeof(a))
#define NCLR(a) memset((a), -1 ,sizeof(a))
#define dump(x) cout << #x <<  << (x) << ;
#define debug(x) cout << #x <<  << (x) <<  << __LINE__ <<  <<  << __FILE__ << ;
#define sq(n) (n) * (n)
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<string> VS;
typedef pair<int, int> PII;
typedef long long LL;
typedef vector<LL> VLL;
typedef vector<VLL> VVLL;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef priority_queue<int> maxpq;
typedef priority_queue< int, vector<int>, greater<int> > minpq;
typedef complex<double> P;
static const double EPS = 1e-10;
static const double PI = acos( -1.0 );
static const int mod = 1000000007;
static const int INF = 1 << 29;
static const LL LL_INF = 1152921504606846976;
static const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };
static const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };
int main() {
#ifdef _DEBUG
	printf(  );
#endif
	for ( int i = 1; i < 10; i++ ) {
		for ( int j = 1; j < 10; j++ ) {
			printf( , i, j, i * j );
		}
	}
	return 0;
}"
Python,"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy
sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
class Matrix():
    def __init__(self, A):
        self.A = A
        self.row = len(A)
        self.col = len(A[0])
    def __iter__(self):
        return self.A.__iter__()
    def __getitem__(self, i):
        return self.A.__getitem__(i)
    def __add__(self, B):
        aa = self.A
        bb = B.A
        return Matrix([[aa[i][j] + bb[i][j] for j in range(self.col)] for i in range(self.row)])
    def __sub__(self, B):
        aa = self.A
        bb = B.A
        return Matrix([[aa[i][j] - bb[i][j] for j in range(self.col)] for i in range(self.row)])
    def __mul__(self, B):
        aa = self.A
        bb = B.A
        a = []
        for i in range(self.row):
            ai = aa[i]
            r = []
            for j in range(B.col):
                r.append(sum([ai[k] * bb[k][j] for k in range(self.col)]))
            a.append(r)
        return Matrix(a)
    def __truediv__(self, x):
        pass
    def lu(self):
        size = self.row
        T = copy.deepcopy(self.A)
        L = [[0]*size for _ in range(size)]
        U = [[0]*size for _ in range(size)]
        for i in range(size):
            for j in range(i,size):
                L[j][i] = T[j][i]
            for j in range(i,size):
                U[i][j] = T[i][j] / T[i][i]
            for j in range(i+1,size):
                for k in range(i+1,size):
                    T[j][k] -= L[j][i] * U[i][k]
        return Matrix(L),Matrix(U)
    def __str__(self):
        return self.A.__str__()
def solve_se(A, b):
    n = A.row
    L,U = A.lu()
    y = []
    for i in range(n):
        t = b[i]
        for k in range(i):
            t -= L[i][k] * y[k]
        y.append(t / L[i][i])
    x = [0] * n
    for i in range(n-1,-1,-1):
        t = y[i]
        for k in range(i+1,n):
            t -= U[i][k] * x[k]
        x[i] = t
    return x
def main():
    sa = [s for s in sys.stdin.read().split('\\n') if s]
    r = []
    for s in sa:
        a,b,c,d,e,f = [int(c) for c in s.split()]
        A = Matrix([[a,b],[d,e]])
        B = [c,f]
        x = solve_se(A,B)
        r.append(' '.join(map(lambda t: '{:01.3f}'.format(1.0*t), x)))
    return '\\n'.join(r)
print(main())"
Python,"sheet = [[0 for _ in range(10)] for _ in range(10)]
small_range = ((0, 0), (1, 0), (0, 1), (-1, 0), (0, -1))
middle_range = ((0, 0), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))
large_range = ((0, 0), (1, 0), (2, 0), (1, 1), (0, 1), (0, 2), (-1, 1), (-1, 0), (-2, 0), (-1, -1), (0, -1), (0, -2), (1, -1))
def drop(x, y, drop_range):
  for dx, dy in drop_range:
    newx, newy = x + dx, y + dy
    if 0 <= newx <= 9 and 0 <= newy <= 9:
      sheet[newx][newy] += 1
while True:
  try:
    x, y, s = map(int, input().split("",""))
    if s == 1:
      drop(x, y, small_range)
    elif s == 2:
      drop(x, y, middle_range)
    else:
      drop(x, y, large_range)
  except EOFError:
    break
zero_cnt = 0
max_ink = 0
for x in range(10):
  for y in range(10):
    ink = sheet[x][y]
    if ink == 0:
      zero_cnt += 1
    if max_ink < ink:
      max_ink = ink
print(zero_cnt)
print(max_ink)"
Python,"import sys
class Paper(object):
    def __init__(self, x=None, y=None):
        if x == None:
            self.x = 10
        else:
            self.x = x
        if y == None:
            self.y = 10
        else:
            self.y = y
        t = [0] * self.x
        self.sheet = [t[:] for _ in range(self.y)]
    def drop_ink(self, ink):
        x, y, s = ink
        if s == 1:
            self.process_ink(x, y)
            self.process_ink(x+1, y)
            self.process_ink(x-1, y)
            self.process_ink(x, y+1)
            self.process_ink(x, y-1)
        elif s == 2:
            self.process_ink(x-1, y-1)
            self.process_ink(x, y-1)
            self.process_ink(x+1, y-1)
            self.process_ink(x-1, y)
            self.process_ink(x, y)
            self.process_ink(x+1, y)
            self.process_ink(x-1, y+1)
            self.process_ink(x, y+1)
            self.process_ink(x+1, y+1)
        elif s == 3:
            self.process_ink(x, y-2)
            self.process_ink(x-1, y-1)
            self.process_ink(x, y-1)
            self.process_ink(x+1, y-1)
            self.process_ink(x-2, y)
            self.process_ink(x-1, y)
            self.process_ink(x, y)
            self.process_ink(x+1, y)
            self.process_ink(x+2, y)
            self.process_ink(x-1, y+1)
            self.process_ink(x, y+1)
            self.process_ink(x+1, y+1)
            self.process_ink(x, y+2)
    def process_ink(self, x, y):
        if 0 <= x < self.x and 0 <= y < self.y:
            self.sheet[y][x] += 1
    def print_sheet(self):
        for row in self.sheet:
            print(row)
if __name__ == '__main__':
    ink_drops = []
    for line in sys.stdin:
        ink_drops.append([int(x) for x in line.strip().split(',')])
    p = Paper(10, 10)
    for ink in ink_drops:
        p.drop_ink(ink)
        
        
    white_cell = 0
    max_ink = 0
    for r in p.sheet:
        white_cell += r.count(0)
        max_ink = max(max(r), max_ink)
    print(white_cell)
    print(max_ink)"
Python,"import math
if __name__=='__main__':
  
  
  n = int(raw_input())
  for i in xrange(n):
    
    x1, y1, x2, y2, x3, y3, x4, y4 = map(float, raw_input().strip().split(' '))
    
    
    
    
    
    
    
    
    
    
    
    
    
      
    if math.fabs((y2 - y1) * (x4 - x3) - (y4 - y3) * (x2 - x1)) < 1e-10:
      print 'YES'
    else:
      print 'NO'
      
      
      
      
      
      
      
      
    
    "
Python,"""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0012&lang=jp
""""""
import sys
from sys import stdin
input = stdin.readline
class Point(object):
    epsilon = 1e-10
    def __init__(self, x=0.0, y=0.0):
        if isinstance(x, tuple):
            self.x = x[0]
            self.y = x[1]
        else:
            self.x = x
            self.y = y
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    def __sub__(self, other):
        return Point(self.x - other.x, self.y - other.y)
    def __mul__(self, other):
        return Point(other * self.x, other * self.y)
    def __truediv__(self, other):
        return Point(self.x / other, self.y / other)
    def __lt__(self, other):
        if self.x == other.x:
            return self.y < other.y
        else:
            return self.x < other.x
    def __eq__(self, other):
        from math import fabs
        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:
            return True
        else:
            return False
    def norm(self):
        return self.x * self.x + self.y * self.y
    def __abs__(self):
        return sqrt(self.norm())
    def ccw(self, p0, p1):
        
        a = Vector(p1 - p0)
        b = Vector(self - p0)
        if Vector.cross(a, b) > Point.epsilon:
            return 1 
        elif Vector.cross(a, b) < -Point.epsilon:
            return -1 
        elif Vector.dot(a, b) < -Point.epsilon:
            return 2 
        elif a.norm() < b.norm():
            return -2 
        else:
            return 0 
    def project(self, s):
        
        base = Vector(s.p2 - s.p1)
        a = Vector(self - s.p1)
        r = Vector.dot(a, base)
        r /= base.norm()
        return s.p1 + base * r
    def reflect(self, s):
        
        proj = self.project(s)
        return self + (proj - self)*2
    def distance(self, s):
        
        if Vector.dot(s.p2-s.p1, self-s.p1) < 0.0:
            return abs(self - s.p1)
        if Vector.dot(s.p1-s.p2, self-s.p2) < 0.0:
            return abs(self - s.p2)
        return abs(Vector.cross(s.p2-s.p1, self-s.p1) / abs(s.p2-s.p1))
class Vector(Point):
    def __init__(self, x=0.0, y=0.0):
        if isinstance(x, tuple):
            self.x = x[0]
            self.y = x[1]
        elif isinstance(x, Point):
            self.x = x.x
            self.y = x.y
        else:
            self.x = x
            self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)
    def __mul__(self, other):
        return Vector(other * self.x, other * self.y)
    def __truediv__(self, other):
        return Vector(self.x / other, self.y / other)
    @classmethod
    def dot(cls, a, b):
        return a.x * b.x + a.y * b.y
    @classmethod
    def cross(cls, a, b):
        return a.x * b.y - a.y * b.x
    @classmethod
    def is_orthogonal(cls, a, b):
        return Vector.dot(a, b) == 0.0
    @classmethod
    def is_parallel(cls, a, b):
        return Vector.cross(a, b) == 0.0
class Segment(object):
    def __init__(self, p1=Point(), p2=Point()):
        if isinstance(p1, Point):
            self.p1 = p1
            self.p2 = p2
        elif isinstance(p1, tuple):
            self.p1 = Point(p1[0], p1[1])
            self.p2 = Point(p2[0], p2[1])
    def intersect(self, s):
        
        ans1 = s.p1.ccw(self.p1, self.p2) * s.p2.ccw(self.p1, self.p2)
        ans2 = self.p1.ccw(s.p1, s.p2) * self.p2.ccw(s.p1, s.p2)
        return ans1 <= 0 and ans2 <= 0
    def cross_point(self, s):
        
        base = s.p2 - s.p1
        d1 = abs(Vector.cross(base, self.p1-s.p1))
        d2 = abs(Vector.cross(base, self.p2-s.p1))
        t = d1 / (d1 + d2)
        return self.p1 + (self.p2 - self.p1) * t
    def distance(self, s):
        
        if self.intersect(s):
            return 0.0
        d1 = s.p1.distance(self)
        d2 = s.p2.distance(self)
        d3 = self.p1.distance(s)
        d4 = self.p2.distance(s)
        return min(d1, d2, d3, d4)
    @classmethod
    def is_orthogonal(cls, s1, s2):
        a = Vector(s1.p2 - s1.p1)
        b = Vector(s2.p2 - s2.p1)
        return Vector.is_orthogonal(a, b)
    @classmethod
    def is_parallel(cls, s1, s2):
        a = Vector(s1.p2 - s1.p1)
        b = Vector(s2.p2 - s2.p1)
        return Vector.is_parallel(a, b)
class Line(Segment):
    pass
class Cirle(object):
    def __init__(self, x, y=Point(), r=1.0):
        if isinstance(x, Point):
            self.c = x
            self.r = y
        elif isinstance(x, tuple):
            self.c = Point(x[0], x[1])
            self.r = r
    def cross_points(self, s):
        if isinstance(s, Segment):
            pr = self.c.project(s)
            e = (s.p2 - s.p1) / abs(s.p2 - s.p1)
            base = sqrt(self.r * self.r - (pr - self.c).norm())
            return pr + e * base, pr - e * base
        elif isinstance(s, Cirle):
            c2 = s
            d = abs(self.c - c2.c)
            a = acos((self.r * self.r + d * d - c2.r * c2.r) / (2 * self.r * d))
            t = atan2(c2.c.y - self.c.y, c2.c.x - self.c.x)
            temp1 = Point(cos(t+a)*self.r, sin(t+a)*self.r)
            temp2 = Point(cos(t-a)*self.r, sin(t-a)*self.r)
            return self.c + temp1, self.c + temp2
def contains(polygon, p):
    n = len(polygon)
    x = False
    for i in range(n):
        a = polygon[i] - p
        b = polygon[(i+1)%n] - p
        if abs(Vector.cross(a, b)) < Point.epsilon and Vector.dot(a, b) < Point.epsilon:
            return 1
        if a.y > b.y:
            temp = a
            a = b
            b = temp
        if a.y < Point.epsilon and Point.epsilon < b.y and Vector.cross(a, b) > Point.epsilon:
            x = not x
    return 2 if x else 0
def main(args):
    for line in sys.stdin:
        polygon = []
        x1, y1, x2, y2, x3, y3, xp, yp = map(float, line.split())
        polygon.append(Point(x1, y1))
        polygon.append(Point(x2, y2))
        polygon.append(Point(x3, y3))
        result = contains(polygon, Point(xp, yp))
        if result == 2:
            print('YES')
        else:
            print('NO')
if __name__ == '__main__':
    main(sys.argv[1:])"
Python,"import sys
from decimal import Decimal
def is_parallel(x1, y1, x2, y2, x3, y3, x4, y4):
    d1x = x2 - x1
    d1y = y2 - y1
    d2x = x4 - x3
    d2y = y4 - y3
    return d1x * d2y == d1y * d2x
    
    
    
    
    
    
    
    
def main():
    n = int(sys.stdin.readline().strip())
    for _ in range(n):
        data = sys.stdin.readline().strip().split(' ')
        
        
        
        
        
        
        
        
        x1 = Decimal(data[0])
        y1 = Decimal(data[1])
        x2 = Decimal(data[2])
        y2 = Decimal(data[3])
        x3 = Decimal(data[4])
        y3 = Decimal(data[5])
        x4 = Decimal(data[6])
        y4 = Decimal(data[7])
        if is_parallel(x1, y1, x2, y2, x3, y3, x4, y4):
            print('YES')
        else:
            print('NO')
            
if __name__ == '__main__':
    main()"
Python,"def paint(masu,data):
    masu[data[1]][data[0]]+=1                   
    
    if data[2]==1:                              
        if data[0]!=0:
            masu[data[1]][data[0]-1]+=1
        if data[0]!=9:
            masu[data[1]][data[0]+1]+=1
        if data[1]!=0:
            masu[data[1]-1][data[0]]+=1
        if data[1]!=9:
            masu[data[1]+1][data[0]]+=1
        
    elif data[2]==2:                            
        if data[0]!=0:
            masu[data[1]][data[0]-1]+=1
        if data[0]!=9:
            masu[data[1]][data[0]+1]+=1
        if data[1]!=0:
            masu[data[1]-1][data[0]]+=1
        if data[1]!=9:
            masu[data[1]+1][data[0]]+=1
        if data[1]!=9 and data[0]!=9:
            masu[data[1]+1][data[0]+1]+=1
        if data[1]!=9 and data[0]!=0:
            masu[data[1]+1][data[0]-1]+=1
        if data[1]!=0 and data[0]!=9:
            masu[data[1]-1][data[0]+1]+=1
        if data[1]!=0 and data[0]!=0:
            masu[data[1]-1][data[0]-1]+=1
        
    elif data[2]==3:                            
        if data[0]!=0:
            masu[data[1]][data[0]-1]+=1
        if data[0]!=9:
            masu[data[1]][data[0]+1]+=1
        if data[1]!=0:
            masu[data[1]-1][data[0]]+=1
        if data[1]!=9:
            masu[data[1]+1][data[0]]+=1
        if data[1]!=9 and data[0]!=9:
            masu[data[1]+1][data[0]+1]+=1
        if data[1]!=9 and data[0]!=0:
            masu[data[1]+1][data[0]-1]+=1
        if data[1]!=0 and data[0]!=9:
            masu[data[1]-1][data[0]+1]+=1
        if data[1]!=0 and data[0]!=0:
            masu[data[1]-1][data[0]-1]+=1
        if data[1]>=2:
            masu[data[1]-2][data[0]]+=1
        if data[1]<=7:
            masu[data[1]+2][data[0]]+=1
        if data[0]>=2:
            masu[data[1]][data[0]-2]+=1
        if data[0]<=7:
            masu[data[1]][data[0]+2]+=1
        
    return masu
masu=[
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0]
    ]
def keisan(masu):
    max=0
    num1=0
    for na in range(10):
        for ma in range(10):
            if masu[na][ma]==0:
                num1+=1
            if masu[na][ma]>max:
                max=masu[na][ma]
    print(num1)
    print(max)
while True:
    try:
        x,y,s=list(map(int, input().split(',')))
        data=[x,y,s]   
        masu2=paint(masu,data)
    except:
        break
    
    
keisan(masu2)"
Python,"def perpendicular_bisector(p, q):
    x = (q[0] - p[0])
    y = (q[1] - p[1])
    return (2 * x, 2 * y, p[0]**2-q[0]**2+p[1]**2-q[1]**2)
def gauss_jordan_elimination(Array):
    
    N = len(Array)
    if N == 0:
        return (True, Array)
    else:
        M = len(Array[0])
    A = []
    for i in range(len(Array)):
        A.append(Array[i][:])
    pivot = 0
    L = min(N, M)
    while pivot < L:
        pivot_v = A[pivot][pivot]
        pivot_row = pivot
        for i in range(pivot + 1, L):
            v = max(A[i][pivot], -A[i][pivot])
            if pivot_v < v:
                pivot_row = i
                pivot_v = v
        if pivot_row > pivot:
            for i in range(M):
                A[pivot][i], A[pivot_row][i] = A[pivot_row][i], A[pivot][i]
        if pivot_v == 0:
            return ('False', A)
        inv_pivot = 1 / A[pivot][pivot]
        A[pivot][pivot] = 1
        for i in range(pivot + 1, M):
            A[pivot][i] *= inv_pivot
        for i in range(N):
            if i == pivot:
                continue
            t = -1 * A[i][pivot]
            A[i][pivot] = 0
            for j in range(pivot + 1, M):
                A[i][j] += t * A[pivot][j]
        pivot += 1
    return ('True', A)
n = int(input())
for _ in range(n):
    x1, y1, x2, y2, x3, y3 = map(float, input().split())
    a = list(perpendicular_bisector((x1, y1), (x2, y2)))
    b = list(perpendicular_bisector((x1, y1), (x3, y3)))
    c = [a, b]
    state, c = gauss_jordan_elimination(c)
    x = -c[0][2]
    y = -c[1][2]
    r = ((x - x1)**2 + (y - y1)**2)**0.5
    print('{0:.3f} {1:.3f} {2:.3f}'.format(round(x, 3), round(y, 3), round(r, 3)))"
Python,"""""""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0021&lang=jp
WA
""""""
import sys
from sys import stdin
input = stdin.readline
class Point(object):
    epsilon = 1e-10
    def __init__(self, x=0.0, y=0.0):
        if isinstance(x, tuple):
            self.x = x[0]
            self.y = x[1]
        else:
            self.x = x
            self.y = y
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    def __sub__(self, other):
        return Point(self.x - other.x, self.y - other.y)
    def __mul__(self, other):
        return Point(other * self.x, other * self.y)
    def __truediv__(self, other):
        return Point(self.x / other, self.y / other)
    def __lt__(self, other):
        if self.x == other.x:
            return self.y < other.y
        else:
            return self.x < other.x
    def __eq__(self, other):
        from math import fabs
        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:
            return True
        else:
            return False
    def norm(self):
        return self.x * self.x + self.y * self.y
    def __abs__(self):
        return sqrt(self.norm())
    def ccw(self, p0, p1):
        
        a = Vector(p1 - p0)
        b = Vector(self - p0)
        if Vector.cross(a, b) > Point.epsilon:
            return 1 
        elif Vector.cross(a, b) < -Point.epsilon:
            return -1 
        elif Vector.dot(a, b) < -Point.epsilon:
            return 2 
        elif a.norm() < b.norm():
            return -2 
        else:
            return 0 
    def project(self, s):
        
        base = Vector(s.p2 - s.p1)
        a = Vector(self - s.p1)
        r = Vector.dot(a, base)
        r /= base.norm()
        return s.p1 + base * r
    def reflect(self, s):
        
        proj = self.project(s)
        return self + (proj - self)*2
    def distance(self, s):
        
        if Vector.dot(s.p2-s.p1, self-s.p1) < 0.0:
            return abs(self - s.p1)
        if Vector.dot(s.p1-s.p2, self-s.p2) < 0.0:
            return abs(self - s.p2)
        return abs(Vector.cross(s.p2-s.p1, self-s.p1) / abs(s.p2-s.p1))
class Vector(Point):
    def __init__(self, x=0.0, y=0.0):
        if isinstance(x, tuple):
            self.x = x[0]
            self.y = x[1]
        elif isinstance(x, Point):
            self.x = x.x
            self.y = x.y
        else:
            self.x = x
            self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)
    def __mul__(self, other):
        return Vector(other * self.x, other * self.y)
    def __truediv__(self, other):
        return Vector(self.x / other, self.y / other)
    @classmethod
    def dot(cls, a, b):
        return a.x * b.x + a.y * b.y
    @classmethod
    def cross(cls, a, b):
        return a.x * b.y - a.y * b.x
    @classmethod
    def is_orthogonal(cls, a, b):
        return abs(Vector.dot(a, b)) < Vector.epsilon
    @classmethod
    def is_parallel(cls, a, b):
        return abs(Vector.cross(a, b)) < Vector.epsilon
class Segment(object):
    def __init__(self, p1=Point(), p2=Point()):
        if isinstance(p1, Point):
            self.p1 = p1
            self.p2 = p2
        elif isinstance(p1, tuple):
            self.p1 = Point(p1[0], p1[1])
            self.p2 = Point(p2[0], p2[1])
    def intersect(self, s):
        
        ans1 = s.p1.ccw(self.p1, self.p2) * s.p2.ccw(self.p1, self.p2)
        ans2 = self.p1.ccw(s.p1, s.p2) * self.p2.ccw(s.p1, s.p2)
        return ans1 <= 0 and ans2 <= 0
    def cross_point(self, s):
        
        base = s.p2 - s.p1
        d1 = abs(Vector.cross(base, self.p1-s.p1))
        d2 = abs(Vector.cross(base, self.p2-s.p1))
        t = d1 / (d1 + d2)
        return self.p1 + (self.p2 - self.p1) * t
    def distance(self, s):
        
        if self.intersect(s):
            return 0.0
        d1 = s.p1.distance(self)
        d2 = s.p2.distance(self)
        d3 = self.p1.distance(s)
        d4 = self.p2.distance(s)
        return min(d1, d2, d3, d4)
    @classmethod
    def is_orthogonal(cls, s1, s2):
        a = Vector(s1.p2 - s1.p1)
        b = Vector(s2.p2 - s2.p1)
        return Vector.is_orthogonal(a, b)
    @classmethod
    def is_parallel(cls, s1, s2):
        a = Vector(s1.p2 - s1.p1)
        b = Vector(s2.p2 - s2.p1)
        return Vector.is_parallel(a, b)
class Line(Segment):
    pass
class Cirle(object):
    def __init__(self, x, y=Point(), r=1.0):
        if isinstance(x, Point):
            self.c = x
            self.r = y
        elif isinstance(x, tuple):
            self.c = Point(x[0], x[1])
            self.r = r
    def cross_points(self, s):
        if isinstance(s, Segment):
            pr = self.c.project(s)
            e = (s.p2 - s.p1) / abs(s.p2 - s.p1)
            base = sqrt(self.r * self.r - (pr - self.c).norm())
            return pr + e * base, pr - e * base
        elif isinstance(s, Cirle):
            c2 = s
            d = abs(self.c - c2.c)
            a = acos((self.r * self.r + d * d - c2.r * c2.r) / (2 * self.r * d))
            t = atan2(c2.c.y - self.c.y, c2.c.x - self.c.x)
            temp1 = Point(cos(t+a)*self.r, sin(t+a)*self.r)
            temp2 = Point(cos(t-a)*self.r, sin(t-a)*self.r)
            return self.c + temp1, self.c + temp2
def contains(polygon, p):
    n = len(polygon)
    x = False
    for i in range(n):
        a = polygon[i] - p
        b = polygon[(i+1)%n] - p
        if abs(Vector.cross(a, b)) < Point.epsilon and Vector.dot(a, b) < Point.epsilon:
            return 1
        if a.y > b.y:
            temp = a
            a = b
            b = temp
        if a.y < Point.epsilon and Point.epsilon < b.y and Vector.cross(a, b) > Point.epsilon:
            x = not x
    return 2 if x else 0
def main(args):
    n = int(input())
    for _ in range(n):
        x1, y1, x2, y2, x3, y3, x4, y4 = map(float, input().split())
        a = Point(x1, y1)
        b = Point(x2, y2)
        c = Point(x3, y3)
        d = Point(x4, y4)
        AB = Segment(a, b)
        CD = Segment(c, d)
        result = Segment.is_parallel(AB, CD)
        if result:
            print('YES')
        else:
            print('NO')
if __name__ == '__main__':
    main(sys.argv[1:])"
Python,"class Point(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __str__(self):
        return ""x = {0}, y = {1}"".format(self.x, self.y)
class Line(Point):
    eps = 10**(-10)
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
    def isParallel(self, another_p):
        try:
            angle1 = (self.p1.y - self.p2.y) / (self.p1.x - self.p2.x)
            angle2 = (another_p.p1.y - another_p.p2.y) / (another_p.p1.x - another_p.p2.x)
            if angle1 >= angle2-self.eps and angle1 <= angle2+self.eps:
                return True
            else:
                return False
        except ZeroDivisionError:
            if self.p1.x == self.p2.x and another_p.p1.x == another_p.p2.x:
                return True
            else:
                return False
n = int(input())
for i in range(n):
    x1, y1, x2, y2, x3, y3, x4, y4 = map(float, input().split())
    A = Point(x1, y1)
    B = Point(x2, y2)
    C = Point(x3, y3)
    D = Point(x4, y4)
    AB = Line(A, B)
    CD = Line(C, D)
    if AB.isParallel(CD):
        print(""YES"")
    else:
        print(""NO"")"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
namespace ConsoleApplication2 {
    class Program {
        static void Main(string[] args) {
            TextReader input = Console.In;
            string str = ;
            while((str = input.ReadLine()) != null) {
                
                string[] works = str.Split(' ');
                
                if (works.Length != 6) {
                    continue;
                }
                double a, b, c, d, e, f;
                if (!double.TryParse(works[0], out a)) {
                    continue;
                }
                if (!double.TryParse(works[1], out b)) {
                    continue;
                }
                if (!double.TryParse(works[2], out c)) {
                    continue;
                }
                if (!double.TryParse(works[3], out d)) {
                    continue;
                }
                if (!double.TryParse(works[4], out e)) {
                    continue;
                }
                if (!double.TryParse(works[5], out f)) {
                    continue;
                }
                double x = (b * f - e * c) / (b * d - e * a);
                double y = (a * f - c * d) / (a * e - b * d);
                Console.WriteLine(x.ToString() +  + y.ToString());
            }
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
class Problem0004
{
    static void Main(string[] args)
    {
        var xyPairs =
            GetInputLines()
            .Select(line => line.Split().Select(word => double.Parse(word)).ToArray())
            .Select(abcdef => Solve(abcdef));
        foreach (double[] xy in xyPairs)
        {
            Console.WriteLine(xy[0].ToString() +  + xy[1].ToString());
        }
    }
    static double[] Solve(double[] abcdef)
    {
        double a = abcdef[0];
        double b = abcdef[1];
        double c = abcdef[2];
        double d = abcdef[3];
        double e = abcdef[4];
        double f = abcdef[5];
        double x = (c * e - b * f) / (a * e - b * d);
        double y = (c * d - a * f) / (b * d - a * e);
        return new double[] { x, y };
    }
    static IEnumerable<string> GetInputLines()
    {
        string line;
        while (!string.IsNullOrEmpty(line = System.Console.ReadLine()))
        {
            yield return line;
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace AOJ
{
    class Program
    {
        static void Main(string[] args)
        {
            Solver solver = new Solver();
            solver.solve();
            return;
        }
    }
    class Solver
    {
        public Solver()
        {
            
        }
        public void solve()
        {
            for (int i = 1; i < 10; i++)
                for (int j = 1; j < 10; j++)
                    Console.WriteLine(i +  + j +  + (i * j));
        }
        static String rs() { return Console.ReadLine(); }
        static int ri() { return int.Parse(Console.ReadLine()); }
        static long rl() { return long.Parse(Console.ReadLine()); }
        static double rd() { return double.Parse(Console.ReadLine()); }
        static String[] rsa() { return Console.ReadLine().Split(' '); }
        static int[] ria() { return Array.ConvertAll(Console.ReadLine().Split(' '), e => int.Parse(e)); }
        static long[] rla() { return Array.ConvertAll(Console.ReadLine().Split(' '), e => long.Parse(e)); }
        static double[] rda() { return Array.ConvertAll(Console.ReadLine().Split(' '), e => double.Parse(e)); }
    }
}"
C#,"using System;
using System.Collections.Generic;
class Program {
    static int Main(string[] args) {
        List<decimal[]> list = new List<decimal[]>();
        while (true) {
            string v = Console.ReadLine();
            if (string.IsNullOrEmpty(v) == true) { break; }
            string[] vs = v.Split(' ');
            decimal[] vd = new decimal[6];
            for (int i = 0; i < 6; i++) {
                vd[i] = decimal.Parse(vs[i]);
            }
            list.Add(vd);
        }
        for (int i = 0; i < list.Count; i++) {
            Calc(list[i]);
        }
        return 0;
    }
    static void Calc(decimal[] v) {
        decimal a = v[0];
        decimal b = v[1];
        decimal c = v[2];
        decimal d = v[3];
        decimal e = v[4];
        decimal f = v[5];
        decimal x = Math.Round((b * f - c * e) / (b * d - a * e), 3, MidpointRounding.AwayFromZero);
        decimal y = Math.Round((a * f - c * d) / (a * e - b * d), 3, MidpointRounding.AwayFromZero);
        Console.WriteLine(string.Format(, x, y));
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
class Program
{
    
    static string InputPattern = ;
    static List<string> GetInputList()
    {
        var WillReturn = new List<string>();
        if (InputPattern == ) {
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
            WillReturn.Add();
        }
        else {
            for (int I = 1; I <= 10; I++) {
                WillReturn.Add(Console.ReadLine());
            }
        }
        return WillReturn;
    }
    static void Main()
    {
        List<string> InputList = GetInputList();
        IEnumerable<int> tmp1 = InputList.Select(X => int.Parse(X));
        IEnumerable<int> tmp2 = tmp1.OrderByDescending(X => X).Take(3);
        foreach (int EachInt in tmp2) {
            Console.WriteLine(EachInt);
        }
    }
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
namespace ConsoleApplication2 {
    class Program {
        static void Main(string[] args) {
            TextReader input = Console.In;
            string str = ;
            
            int dataSet = 0;
            str = input.ReadLine();
            if (string.IsNullOrEmpty(str)) {
                return;
            }
            if (!int.TryParse(str, out dataSet)) {
                return;
            }
            if (dataSet == 0) {
                return;
            }
            for (int ii = 0; ii < dataSet; ii++) {
                str = input.ReadLine();
                if (string.IsNullOrEmpty(str)) {
                    break;
                }
                
                string[] triLens = str.Split(' ');
                
                if (triLens.Length != 3) {
                    continue;
                }
                List<int> lens = new List<int>();
                int work = 0;
                if (!int.TryParse(triLens[0], out work)) {
                    continue;
                }
                lens.Add(work);
                if (!int.TryParse(triLens[1], out work)) {
                    continue;
                }
                lens.Add(work);
                if (!int.TryParse(triLens[2], out work)) {
                    continue;
                }
                lens.Add(work);
                lens.Sort(delegate(int w1, int w2){return w2.CompareTo(w1);});
                if (lens[0] * lens[0] == lens[1] * lens[1] + lens[2] * lens[2]) {
                    Console.WriteLine();
                } else {
                    Console.WriteLine();
                }
            }
        }
    }
}"
C#,"using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
public class my
{
	
	private static StringBuilder sb = new StringBuilder();
	
	public static void Main()
	{
		string s;
 
		while( null != ( s = Console.ReadLine() ) ){
			var t =s.Split(' ');
			var a = int.Parse(t[0]);
			var b = int.Parse(t[1]);
			
			var c = a + b;
			
			if(c > 0) {
				var digit = 0;
				
				while(c  > 0) {
					digit++;
					c /= 10;
				}
				
				my.AppendLine(digit);
			} else {
				sb.AppendLine();	
			}
		}
		
		my.Flush();
	}
	
	private static int CountChar(string s, char c)
	{
		return s.Length - s.Replace(c.ToString(), ).Length;
	}
	
	private static void Flush()
	{
		Console.Write(sb);
		sb.Length = 0;
	}
	
	private static void AppendLine(int v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(long v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(string[] v)
	{
		sb.AppendLine(string.Join(, v));
	}
	private static void Swap(ref string a, ref string b) 
	{
		string tmp = a;
		a = b;
		b = tmp;
	}
	
	private static void Swap(ref int a, ref int b) 
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	
	private static int[] GetIntArray()
	{
		return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);
	}
	
	private static void WriteArray(int[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static void WriteArray(long[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static int GetInt()
	{
		return int.Parse(Console.ReadLine());
	}
	
	private static long GetLong()
	{
		return long.Parse(Console.ReadLine());
	}
}"
C#,"using System;
 
class p0003{
     
    static void Main(string[] args){
        int n;
        string str;
        string[] s;
        int[] a = new int[3];
        while ((str = Console.ReadLine()) != null)
        {
            n = int.Parse(str);
            while (0 < n--)
            {
                s = (Console.ReadLine()).Split(' ');
                for (int i = 0; i < 3; ++i)
                {
                    a[i] = int.Parse(s[i]);
                    a[i] = a[i] * a[i];
                }
                Console.WriteLine(, ((a[0] == a[1] + a[2] || a[1] == a[0] + a[2] || a[2] == a[0] + a[1]) ?  : ));
            }
        }
    }
     
}"
C#,"using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
public class my
{
	
	private static StringBuilder sb = new StringBuilder();
	
	public static void Main()
	{
		for(int i = 1; i <= 9; i++) {
			for(int j = 1; j <= 9; j++) {
				sb.AppendLine(string.Format(, i, j, i*j ));
			}
		}
		
		Console.Write(sb);
	}
	
	private static int CountChar(string s, char c)
	{
		return s.Length - s.Replace(c.ToString(), ).Length;
	}
	
	private static void Flush()
	{
		Console.Write(sb);
		sb.Length = 0;
	}
	
	private static void AppendLine(int v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(long v)
	{
		sb.AppendLine(v.ToString());
	}
	
	private static void AppendLine(string[] v)
	{
		sb.AppendLine(string.Join(, v));
	}
	private static void Swap(ref string a, ref string b) 
	{
		string tmp = a;
		a = b;
		b = tmp;
	}
	
	private static void Swap(ref int a, ref int b) 
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	
	private static int[] GetIntArray()
	{
		return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);
	}
	
	private static void WriteArray(int[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static void WriteArray(long[] a)
	{
		Console.WriteLine(string.Join(, Array.ConvertAll( a, x=>x.ToString() ) ) );
	}
	
	private static int GetInt()
	{
		return int.Parse(Console.ReadLine());
	}
	
	private static long GetLong()
	{
		return long.Parse(Console.ReadLine());
	}
}"
C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Prob0004
{
    class Program
    {
        const char splitBy = ' ';
        static void Main(string[] args)
        {
            string line;
            while (!string.IsNullOrEmpty(line = System.Console.ReadLine()))
            {
                double[] param = Array.ConvertAll(line.Split(splitBy), e => double.Parse(e));
                solve(param);
            }
        }
        static void solve(double[] param)
        {
            double x;
            double y;
            if (param[0] != 0.0 && param[3] != 0.0)
            {
                double a = param[3] / param[0];
                y = (param[5] - param[2] * a) / (param[4] - param[1] * a);
                x = (param[2] - param[1] * y) / param[0];
            }
            else
            {
                double a = param[4] / param[1];
                x = (param[5] - param[2] * a) / (param[3] - param[0] * a);
                y = (param[2] - param[0] * x) / param[1];
            }
            Console.WriteLine(, x, y);
        }
    }
}"
Rust,"use std::collections::HashMap;
fn main(){
  let n: usize = read();
  for t in 0 .. n {
    let mut sdv: Vec<Vec<u32>> = Vec::new();
    let mut stv: Vec<Vec<char>> = vec![vec![' ';9];9];
  
    for _ in 0 .. 9 {
      sdv.push(read_vec());
    }
    for i in 0 .. 9 {
      let mut hm1: HashMap<u32, (usize, usize)> = HashMap::new();
      let mut hm2: HashMap<u32, (usize, usize)> = HashMap::new();
      for j in 0 .. 9 {
        match hm1.get(&sdv[i][j]) {
          Some(&(u, v)) => {
            stv[i][j] = '*';
            stv[u][v] = '*';
          },
          None => {
            hm1.insert(sdv[i][j], (i, j));
          },
        }
        match hm2.get(&sdv[j][i]) {
          Some(&(u, v)) => {
            stv[j][i] = '*';
            stv[u][v] = '*';
          },
          None => {
            hm2.insert(sdv[j][i], (j, i));
          },
        }
      }
    }
    
    for bi in 0 .. 3 {
      for bj in 0 .. 3 {
        let mut hm: HashMap<u32, (usize, usize)> = HashMap::new();
        for i in 0 .. 3 {
          for j in 0 .. 3 {
            let ii = bi * 3 + i;
            let jj = bj * 3 + j;
            match hm.get(&sdv[ii][jj]) {
              Some(&(u, v)) => {
                stv[ii][jj] = '*';
                stv[u][v] = '*';
              },
              None => {
                hm.insert(sdv[ii][jj], (ii, jj));
              },
            }
          }
        }
      }
    }
    if t > 0 { println!(); }
    for i in 0 .. 9 {
      for j in 0 .. 9 {
        print!(, stv[i][j], sdv[i][j]);
        if j == 8 { println!(); }
      }
    }
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"fn main(){
  loop {
    let xyz: Vec<usize> = read_vec();
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    if x == 0 && y == 0 && z == 0 { break; }
    
    let v: Vec<usize> = read_vec();
    let mut bd: Vec<(usize, usize)> = vec![(0, 0);y+1];
    
    for _ in 0 .. z {
      let nea: Vec<usize> = read_vec();
      let n = nea[0];
      let e = nea[1];
      let a = nea[2];
      bd[n] = (e, a);
    }
    let mut dp: Vec<Vec<f64>> = vec![vec![0.0 ; 5000] ; y + 1];
    dp[0][0] = 1.0;
    for i in 0 .. y {
      for j in 0 .. 5000 {
        for k in 0 .. x {
          let ni = if i + v[k] < y { i + v[k] } else { y };
          match bd[ni] {
            (1, a) => {
              let nni = if ni + a < y { ni + a } else { y };
              dp[nni][j] += dp[i][j] / (x as f64);
            },
            (2, a) => {
              if j + a < 5000 {
                dp[ni][j + a] += dp[i][j] / (x as f64);
              }
            },
            (3, a) => {
              dp[ni][if j > a { j - a } else { 0 }] += dp[i][j] / (x as f64);
            },
            (_, _) => {
              dp[ni][j] += dp[i][j] / (x as f64);
            },
          }
        }
      }
    }
    let ans: f64 = dp[y].iter().enumerate().map(|(i, &j)| (i as f64) * j).sum();
    println!(, ans as usize);
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"/*input
ABAABBBAABABAAABBAA
AABBBABBABBAAABABABAAB
BABAABAABABABBAAAB
AABABAAABBAABBBABAA
AAAAAAAAAAA
ABBBBBBBBBB
0
*/
macro_rules! input_vec {
    () => {
        input!()
            .split_whitespace()
            .map(|x| x.parse().unwrap())
            .collect()
    };
    ($delimiter:expr) => {
        input!()
            .split($delimiter)
            .map(|x| x.parse().unwrap())
            .collect()
    };
}
macro_rules! input {
    () => {{
        let mut return_ = String::new();
        std::io::stdin().read_line(&mut return_).ok();
        return_.pop();
        return_
    }};
}
fn main() {
    let (mut inp, mut a, mut b);
    loop {
        a = 0;
        b = 0;
        inp = input!();
        if &inp[..] ==  {
            break;
        }
        for i in inp.chars().skip(1) {
            match i {
                'A' => {
                    a += 1;
                }
                'B' => {
                    b += 1;
                }
                _ => {}
            }
        }
        if a > b {
            a += 1;
        } else {
            b += 1;
        }
        println!(, a, b);
    }
}"
Rust,"fn main(){
  let nq: Vec<usize> = read_vec();
  let q = nq[1];
  let cv: Vec<usize> = read_vec();
  let mut sc: Vec<bool> = vec![false; 300001];
  for i in 0 .. cv.len() {
    sc[cv[i]] = true;
  }
  let mut nxt: Vec<usize> = vec![0; 300001];
  let mut tv: usize = 0;
  
  for i in 0 .. sc.len() {
    nxt[i] = tv;
    if sc[i] { tv = i; }
  }
  
  for _ in 0 .. q {
    let qi: usize = read();
    let mut i: usize = tv;
    let mut ans: usize = 0;
    while i > 0 {
      let r = i % qi;
      if ans < r { ans = r; }
      i = nxt[i-r];
    }
    println!(, ans);
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"fn main(){
  loop {
    let n: u32 = read();
    if n == 0 { break; }
  
    let mut fld: Vec<Vec<usize>> = vec![vec![0; 5]; 5000];
    let mut pa: Vec<usize> = vec![0; 5];
    
    for _ in 0 .. n {
      let tv: Vec<usize> = read_vec();
      let d = tv[0];
      let p = tv[1];
      let q = tv[2] - 1;
      put_block(&mut fld, &mut pa, d, p, q);
    }
    let cnt: usize = count_block(&fld, &pa);
    println!(, cnt);
  }
}
fn read<T>() -> T
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.trim().parse().unwrap()
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}
fn put_block(fld: &mut Vec<Vec<usize>>, pa: &mut Vec<usize>, d: usize, p: usize, q: usize) {
  if d == 1 {
    let mx: usize = (q..q+p).map(|i| pa[i]).max().unwrap();
    for i in q .. q + p {
      fld[mx][i] = 1;
      pa[i] = mx + 1;
    }
    if fld[mx].iter().all(|i| *i == 1) {
      let tp: usize = (0..5).map(|i| pa[i]).max().unwrap();
      for i in mx .. tp {
        for j in 0 .. 5 {
          fld[i][j] = fld[i+1][j];
        }
      }
      
      for j in 0 .. 5 {
        for i in (0 .. pa[j]).rev() {
          if fld[i][j] == 1 { break; }
          else { pa[j] = i; }
        }
      }
    }
  } else {
    for i in pa[q] .. pa[q] + p {
      fld[i][q] = 1;
    }
    pa[q] = pa[q] + p;
    for i in (pa[q]-p .. pa[q]).rev() {
      if fld[i].iter().all(|i| *i == 1) {
        let tp: usize = (0..5).map(|i| pa[i]).max().unwrap();
        for j in i .. tp {
          for k in 0 .. 5 {
            fld[j][k] = fld[j+1][k];
          }
        }
      }
    }
    
    for j in 0 .. 5 {
      for i in (0 .. pa[j]).rev() {
        if fld[i][j] == 1 { break; }
        else { pa[j] = i; }
      }
    }
  }
}
fn count_block(fld: &Vec<Vec<usize>>, pa: &Vec<usize>) -> usize {
  let mut cnt: usize = 0;
  for j in 0 .. 5 {
    for i in 0 .. pa[j] {
      if fld[i][j] == 1 { cnt += 1; }
    }
  }
  cnt
}"
Rust,"#![allow(unused_mut, non_snake_case,unused_imports)]
use std::iter;
use std::cmp::{max, min, Ordering};
use std::mem::{swap};
use std::collections::{HashMap,BTreeMap,HashSet,BTreeSet,BinaryHeap,VecDeque};
use std::iter::FromIterator;
macro_rules! input {(source = $s:expr, $($r:tt)*) => {let mut iter = $s.split_whitespace();let mut next = || { iter.next().unwrap() };input_inner!{next, $($r)*}};($($r:tt)*) => {let stdin = std::io::stdin();let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));let mut next = move || -> String{bytes.by_ref().map(|r|r.unwrap() as char).skip_while(|c|c.is_whitespace()).take_while(|c|!c.is_whitespace()).collect()};input_inner!{next, $($r)*}};}
macro_rules! input_inner {($next:expr) => {};($next:expr, ) => {};($next:expr, $var:ident : $t:tt $($r:tt)*) => {let $var = read_value!($next, $t);input_inner!{$next $($r)*}};}
macro_rules! read_value {($next:expr, ( $($t:tt),* )) => {( $(read_value!($next, $t)),* )};($next:expr, [ $t:tt ; $len:expr ]) => {(0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()};($next:expr, chars) => {read_value!($next, String).chars().collect::<Vec<char>>()};($next:expr, usize1) => {read_value!($next, usize) - 1};($next:expr, $t:ty) => {$next().parse::<$t>().expect()};}
/*
 <url:http:
 問題文============================================================
 =================================================================
 解説=============================================================
 ================================================================
 */
fn main(){
    input!(N:usize,C:usize,p:[usize;C]);
    let sum = p.into_iter().sum::<usize>();
    let mut ans = 0;
    ans += sum/(N+1);
    if sum%(N+1) != 0{
        ans+=1;
    }
    println!(,ans);
}"
Rust,"use std::cmp::Ordering;
use std::collections::BinaryHeap;
fn main(){
  let nq: Vec<usize> = read_vec();
  let n = nq[0];
  let q = nq[1];
  
  let mut cnt: Vec<i32> = vec![0;n];
  let mut bh = BinaryHeap::new();
  
  for _ in 0 .. q {
    let av: Vec<i32> = read_vec();
    let a = av[0] as usize - 1;
    let v = av[1];
    
    cnt[a] = cnt[a] + v;
    bh.push(Angler{a:a, v:cnt[a]});
    
    loop {
      let &ang = bh.peek().unwrap();
      if cnt[ang.a] == ang.v {
        println!(, ang.a + 1, ang.v);
        break;
      }
      
      bh.pop();
    }
  }
}
#[derive(Eq, PartialEq, Debug, Copy, Clone)]
struct Angler {
  a: usize,
  v: i32,
}
impl Ord for Angler {
  fn cmp(&self, other: &Angler) -> Ordering {
    if self.v == other.v {other.a.cmp(&self.a)} else {self.v.cmp(&other.v)}
  }
}
impl PartialOrd for Angler {
  fn partial_cmp(&self, other: &Angler) -> Option<Ordering> {
    Some(self.cmp(other))
  }
}
fn read_vec<T>() -> Vec<T>
  where T: std::str::FromStr,
        T::Err: std::fmt::Debug
{
  let mut buf = String::new();
  std::io::stdin().read_line(&mut buf).expect();
  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()
}"
Rust,"use std::io::stdin;
fn main() {
    loop {
        let mut s = String::new();
        stdin().read_line(&mut s).unwrap();
        let end: i32 = match s.trim().parse() {
            Ok(end) => end,
            Err(_) => return
        };
        if end < 2 {
            println!(, 0);
            continue;
        }
        
        
        let mut flags = vec![true; ((end + 1) / 2) as usize];
        let flags_len = flags.len();
        flags[0] = false;
        for i in 1..flags_len {
            if !flags[i] {
                continue
            }
            let n = i * 2 + 1;
            let mut j = 3;
            let mut comp_index = (n * j - 1) / 2;
            while comp_index < flags_len {
                flags[comp_index] = false;
                j += 2;
                comp_index = (n * j - 1) / 2;
            }
        }
        
        println!(, flags.iter().filter(|x| **x).count() + 1);
    }
}"
Rust,"fn main(){
    let n=readln();
    for _i in 0..n{
        let mut v:Vec<i64> = readln();
        v.sort();
        if v[0]*v[0] + v[1]*v[1]==v[2]*v[2] {
            println!();
        }
        else{
            println!();
        }
    }
}
    
#[allow(unused_imports)]
use std::cmp::{max, min};
#[allow(unused_imports)]
 
pub trait FromLn {
    fn fromln(s: &str) -> Self;
}
pub fn readln<T: FromLn>() -> T {
    let mut buf = String::new();
    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();
    T::fromln(buf.trim())
}
pub fn readlns<T: FromLn>(n: usize) -> Vec<T> {
    let mut vs = vec![];
    for _ in 0..n {
        vs.push(readln());
    }
    vs
}
macro_rules! fromln_primitives {
    ($($t:ty),*) => { $(
        impl FromLn for $t {
            fn fromln(s: &str) -> $t {
                s.parse().unwrap()
            }
        }
    )* }
}
fromln_primitives!(
    String,
    bool,
    f32,
    f64,
    isize,
    i8,
    i16,
    i32,
    i64,
    usize,
    u8,
    u16,
    u32,
    u64
);
impl<T> FromLn for Vec<T>
where
    T: FromLn,
{
    fn fromln(s: &str) -> Vec<T> {
        s.split_whitespace().map(T::fromln).collect()
    }
}
impl FromLn for Vec<char> {
    fn fromln(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
macro_rules! fromln_tuple {
    ($($t:ident),*) => {
        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {
            fn fromln(s: &str) -> ($($t),*) {
                let mut it = s.split_whitespace();
                let t = ($($t::fromln(it.next().unwrap())),*);
                assert_eq!(it.next(), None);
                t
            }
        }
    }
}
fromln_tuple!(A, B);
fromln_tuple!(A, B, C);
fromln_tuple!(A, B, C, D);
fromln_tuple!(A, B, C, D, E);
fromln_tuple!(A, B, C, D, E, F);"
Rust,"use std::io::*;
fn fizzbuzz_eq(n: usize, s: &str) -> bool {
  if      n % 15 == 0 { s ==  }
  else if n %  3 == 0 { s ==  }
  else if n %  5 == 0 { s ==  }
  else { n == s.parse().unwrap() }
}
fn main() {
  let stdin = stdin();
  let mut lines = stdin.lock().lines().map(|l| l.unwrap());
  loop {
    let (m, n) = {
      let line = lines.next().unwrap();
      let mut iter = line.split_whitespace().map(|s| s.parse::<usize>().unwrap());
      (iter.next().unwrap(), iter.next().unwrap())
    };
    if m == 0 { return; }
    let mut players_alive = vec![true; m];
    let mut cur = 0;
    for i in 1..(n + 1) {
      let ans = lines.next().unwrap();
      let is_correct = fizzbuzz_eq(i, &ans);
      if !is_correct { players_alive[cur] = false; }
      if i < n {
        let mut iter = ((cur + 1)..(cur + m)).map(|p| p % m);
        cur = iter.find(|&p| players_alive[p]).unwrap();
        if !is_correct && !iter.any(|p| players_alive[p]) {
          lines.nth(n - i - 1);
          break
        }
      }
    }
    let mut iter = players_alive.into_iter().enumerate()
      .filter(|&(_, a)| a).map(|(n, _)| n + 1);
    let mut result = iter.next().unwrap().to_string();
    for n in iter {
      result.push_str(&format!(, n));
    }
    println!(, result);
  }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try {
			String s;
			int input = Integer.parseInt(br.readLine());
			List<String> rightAngleList = new ArrayList<String>();
			for (int i = 1; i <= input; i++) {
				s = br.readLine();
				String[] num = s.split();
				Integer[] side = convertArray(num);
					Arrays.sort(side);
					if (side[2] * side[2] == side[1] * side[1] + side[0]
							* side[0]) {
						rightAngleList.add();
					} else {
						rightAngleList.add();
					}
			}
			String[] rightAngles = rightAngleList.toArray(new String[0]);
			for(String rightAngle : rightAngles){
				System.out.println(rightAngle);
			}
		} finally {
			br.close();
		}
	}
	public static Integer[] convertArray(String[] str) {
		List<Integer> list = new ArrayList<Integer>();
		for (String num : str) {
			list.add(Integer.parseInt(num));
		}
		return list.toArray(new Integer[0]);
	}
}"
Java,"public class Main {
	public static void main(String args[]){
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
	}
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;
public class Main {
    final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    final String LINE_SPR = System.getProperty();
    final int BIG_MOD = 1000000007;
    void run() throws Exception {
        for(int i = 1; i <= 9; i++) 
            for(int j = 1; j <= 9; j++) 
                System.out.println(i +  + j +  + (i * j));
    }
    /*
     * Templates
     */
    void dumpObjArr(Object[] arr, int n) {
        for(int i = 0; i < n; i++) {
            System.out.print(arr[i]);
            if(i < n - 1)
                System.out.print();
        }
        System.out.println();
    }
    void dumpObjArr2(Object[][] arr, int m, int n) {
        for(int j = 0; j < m; j++) 
            dumpObjArr(arr[j], n);
    }
    int ni() throws Exception {
        return Integer.parseInt(br.readLine().trim());
    }
    long nl() throws Exception {
        return Long.parseLong(br.readLine().trim());
    }
    String ns() throws Exception {
        return br.readLine();
    }
    boolean isPrime(int n) {
        for(int i=2;i<n;i++) {
            if(n%i==0)
                return false;
        }
        return true;
    }
    int getPrime(int n) {
        List<Integer> primes = new ArrayList<Integer>();
        primes.add(2);
        int count = 1;
        int x = 1;
        while(primes.size() < n) {
            x+=2;
            int m = (int)Math.sqrt(x);
            for(int p : primes) {
                if(p > m) {
                    primes.add(x);
                    break;
                }
                if(x % p == 0) 
                    break;
            }
        }
        return primes.get(primes.size() - 1);
    }
    void gcjPrint(String str, int t) {
        System.out.println( + t +  + str);
    }
    public static void main(String[] args) throws Exception {
        new Main().run();
    }
}"
Java,"public class Main {
    private static final int BEGIN = 1;
    private static final int END = 9;
    /**
     * 九九の一覧を表示する
     *
     * @param args
     */
    public static void main(String[] args) {
        
        for (int i = BEGIN; i <= END; i++) {
            for (int j = BEGIN; j <= END; j++) {
                System.out.println(createMultiplicationLine(i, j));
            }
        }
    }
    /**
     * 指定されたオペランドを用いて、掛け算の1行を表す文字列作成する。
     * 例： 
     *
     * @param i オペランド1
     * @param j オペランド2
     * @return 指定されたオペランドを用いて作成した掛け算を表す文字列
     */
    protected static String createMultiplicationLine(int i, int j) {
        StringBuilder buffer = new StringBuilder();
        buffer.append(i);
        buffer.append();
        buffer.append(j);
        buffer.append();
        buffer.append(i * j);
        return buffer.toString();
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        try {
            line = br.readLine();
            int n = Integer.parseInt(line.trim());
            for(int i=0; i<n; i++){
                line = br.readLine();
                String[] numbers = line.trim().split();
                int[] sides = {Integer.parseInt(numbers[0]), Integer.parseInt(numbers[1]), Integer.parseInt(numbers[2])};
                int maxSide = sides[0]>sides[1] && sides[0]>sides[2]? 0: sides[1]>sides[2]? 1: 2;
                int sum = 0;
                for(int j=0; j<3; j++){
                    if(j != maxSide){
                        sum += sides[j] * sides[j];
                    }
                }
                System.out.println(sides[maxSide] * sides[maxSide] == sum ? : );
            }
        } catch (IOException e) {
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
public class Main {
    private static final int DATA_SET = 200;
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        List<String> inputDataList = new ArrayList<String>(DATA_SET);
        String input = null;
        try {
            while((input = in.readLine()) != null) {
                inputDataList.add(input);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        for (String inputData : inputDataList) {
            String[] data = inputData.split();
            double result = Math.log10(Double.parseDouble(data[0]) + Double.parseDouble(data[1]));
            System.out.println(new Double(result).intValue() + 1);
        }
    }
}"
Java,"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;
public class Main {
	private final static String NEGATIVE = ;
	private final static String AFFIRMATIVE = ;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in),1024);
		int number = Integer.parseInt(br.readLine());
		int sides[] = new int[3];
		StringTokenizer tknz;
		StringBuilder builder = new StringBuilder();
		for (; 0 < number; number--) {
			tknz = new StringTokenizer(br.readLine());
			for (int i = 0; i < 3; i++) {
				sides[i] = Integer.parseInt(tknz.nextToken());
			}
			Arrays.sort(sides);
			if (sides[0] * sides[1] * sides[2] % 60 != 0) {
				builder.append(NEGATIVE);
			} else if (Math.pow(sides[0], 2) + Math.pow(sides[1], 2) != Math.pow(sides[2], 2)) {
				builder.append(NEGATIVE);
			} else {
				builder.append(AFFIRMATIVE);
			}
		}
		System.out.print(builder);
	}
}"
Java,"import java.io.BufferedReader;
import java.io.BufferedOutputStream;
import java.io.PrintWriter;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;
import java.io.IOException;
public class Main{
   public static void main(String[] args) {
      Scanner kb = new Scanner(System.in);
      out = new PrintWriter(new BufferedOutputStream(System.out));
      
      int height[] = new int[10];
      for(int i = 0 ; i < 10 ; i++){
    	  height[i] = kb.nextInt();
      }
      
      Arrays.sort(height);
      
      System.out.println(height[9]);
      System.out.println(height[8]);
      System.out.println(height[7]);
   }
   
   public static PrintWriter out;
      
   
   public static class MyScanner {
      BufferedReader br;
      StringTokenizer st;
 
      public MyScanner() {
         br = new BufferedReader(new InputStreamReader(System.in));
      }
 
      String next() {
          while (st == null || !st.hasMoreElements()) {
              try {
                  st = new StringTokenizer(br.readLine());
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
          return st.nextToken();
      }
 
      int nextInt() {
          return Integer.parseInt(next());
      }
 
      long nextLong() {
          return Long.parseLong(next());
      }
 
      double nextDouble() {
          return Double.parseDouble(next());
      }
 
      String nextLine(){
          String str = ;
   try {
      str = br.readLine();
   } catch (IOException e) {
      e.printStackTrace();
   }
   return str;
      }
   }
   
}"
Java,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
	        BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1);
	        String str = ;
	        StringTokenizer st;
	        while ((str = br.readLine()) != null) {
	            st = new StringTokenizer(str, );
	            if(st.countTokens() > 2)
	            	System.out.println();
	            int n1;
				int n2;
				try {
					n1 = Integer.parseInt(st.nextToken());
					n2 = Integer.parseInt(st.nextToken());
		            if(n1<0 || n2 < 0 || n1 > 1000000 || n2 > 1000000)
		            	System.out.println();
		            
		            str = String.valueOf(n1+n2);
		            System.out.println(str.length());
				} catch (NumberFormatException e) {
					System.out.println();
				}
	        }
	}
}"
Java,"public class Main {
	public static void main(String args[]){
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();System.out.println();
		System.out.println();System.out.println();System.out.println();System.out.println();
	}
}"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.List.Split (splitOn)
main :: IO ()
main = do
  xs <- readResult []
  ys <- getc toInt
  mapM_ print $ solve xs ys
solve :: [(Int,Int)] -> [Int] -> [Int]
solve tbl qs = map (toRank db) qs
  where
    stbl = sortBy (\\i j -> compare (snd j) (snd i)) tbl
    db = setRank 1 [] stbl
    
readResult :: [(Int,Int)] -> IO [(Int,Int)]
readResult acc = do
  [x,y] <- getl $ map toInt . splitOn "",""
  if (x == 0 && y == 0)
    then return acc
    else readResult ((x,y) : acc)
setRank :: Int -> [(Int,Int)] -> [(Int,Int)] -> [(Int,Int)]
setRank r acc [(n1, p1)] = (n1, r) : acc
setRank r acc ((n1, p1) : (n2, p2) : xs)
  | p1 == p2 = setRank r ((n1, r) : acc) ((n2,p2) : xs)
  | otherwise = setRank (r + 1) ((n1, r) : acc) ((n2,p2) : xs)
toRank :: [(Int,Int)] -> Int -> Int
toRank db i = let Just r = lookup i db in r
    
toInt :: String -> Int
toInt s = read s
getl :: (String -> a) -> IO a
getl f = f <$> getLine
getc :: (String -> a) -> IO [a]
getc f = map f . lines <$> getContents"
Haskell,"import           Control.Applicative
import           Control.Monad
import           Data.List           hiding (union)
import           Text.Printf
main :: IO ()
main = mapM_ (print . process . read) . lines =<< getContents
  where
    process n = length $ takeWhile (<=n) primesPQWE
primesTME :: [Int]
primesTME = 2 : ([3,5..] `minus` foldt [[p*p,p*p+2*p..] | p <- primes_])
   where
     primes_ = 3 : ([5,7..] `minus` foldt [[p*p,p*p+2*p..] | p <- primes_])
     foldt ((x:xs):t)    = x : union xs (foldt (pairs t))
     pairs ((x:xs):ys:t) = (x : union xs ys) : pairs t               
primesTMWE :: [Int]
primesTMWE = 2:3:5:7: gaps 11 wheel (fold3t $ roll 11 wheel primes_)
  where
   primes_ = 11: gaps 13 (tail wheel) (fold3t $ roll 11 wheel primes_)     
   fold3t ((x:xs): ~(ys:zs:t)) = x : union xs (union ys zs)
                                      `union` fold3t (pairs t)              
   pairs ((x:xs):ys:t)         = (x : union xs ys) : pairs t
   wheel = 2:4:2:4:6:2:6:4:2:4:6:6:2:6:4:2:6:4:6:8:4:2:4:2:
           4:8:6:4:6:2:4:6:2:6:6:4:2:4:6:2:6:4:2:4:2:10:2:10:wheel
   gaps k ws@(w:t) cs@ ~(c:u) | k==c  = gaps (k+w) t u              
                              | True  = k : gaps (k+w) t cs
   roll k ws@(w:t) ps@ ~(p:u) | k==p  = scanl (\\c d->c+p*d) (p*p) ws
                                          : roll (k+w) t u
                              | True  = roll (k+w) t ps
minus :: [Int] -> [Int] -> [Int]
minus xs@(x:xt) ys@(y:yt) = case compare x y of
  LT -> x : minus xt ys
  EQ ->     minus xt yt
  GT ->     minus xs yt
minus a         b         = a
union :: [Int] -> [Int] -> [Int]
union xs@(x:xt) ys@(y:yt) = case compare x y of
  LT -> x : union xt ys
  EQ -> x : union xt yt
  GT -> y : union xs yt
union a         []        = a
union []        b         = b
primesPQWE::[Int]
primesPQWE = 2 : 3 : 5 : 7 : sieve 11 wheel
  where
    
    
    wheel :: Integral a => [a]
    wheel = 2:4:2:4:6:2:6:4:2:4:6:6:2:6:4:2:6:4:6:8:4:2:4:2:4:8:6:4:6:2:4:6
      :2:6:6:4:2:4:6:2:6:4:2:4:2:10:2:10:wheel
    
    
    
    
    
    sieve :: Integral a => a -> [a] -> [a]
    sieve n [] = []
    sieve n wheel@(d:ds) = n : (map (\\(p,wheel) -> p) primes1) where
      primes1 = sieve' (n+d) ds initialTable
      primes2 = sieve' (n+d) ds initialTable
      initialTable = initHQ (insertPQ (n*n) (n, wheel) emptyPQ)
                   (map (\\(p,wheel) -> (p*p,(p,wheel))) primes2)
    sieve' n []     table = []
    sieve' n wheel@(d:ds) table
        | nextComposite <= n = sieve' (n+d) ds (adjust table)
        | otherwise	     = (n,wheel) : sieve' (n+d) ds table
        where
            nextComposite = minKeyHQ table
            adjust table
                | m <= n    = adjust (deleteMinAndInsertHQ m' (p, ds) table)
                | otherwise = table
                where
		              (m, (p, d:ds)) = minKeyValueHQ table
		              m' = m + p * d
data PriorityQ k v = Lf
                   | Br {-# UNPACK #-} !k v !(PriorityQ k v) !(PriorityQ k v)
               deriving (Eq, Ord, Read, Show)
emptyPQ :: PriorityQ k v
emptyPQ = Lf
isEmptyPQ :: PriorityQ k v -> Bool
isEmptyPQ Lf = True
isEmptyPQ _  = False
minKeyValuePQ :: PriorityQ k v -> (k, v)
minKeyValuePQ (Br k v _ _) = (k,v)
minKeyValuePQ _            = error ""Empty heap!""
minKeyPQ :: PriorityQ k v -> k
minKeyPQ (Br k v _ _) = k
minKeyPQ _            = error ""Empty heap!""
minValuePQ :: PriorityQ k v -> v
minValuePQ (Br k v _ _) = v
minValuePQ _            = error ""Empty heap!""
insertPQ :: Ord k => k -> v -> PriorityQ k v -> PriorityQ k v
insertPQ wk wv (Br vk vv t1 t2)
               | wk <= vk   = Br wk wv (insertPQ vk vv t2) t1
               | otherwise  = Br vk vv (insertPQ wk wv t2) t1
insertPQ wk wv Lf             = Br wk wv Lf Lf
siftdown :: Ord k => k -> v -> PriorityQ k v -> PriorityQ k v -> PriorityQ k v
siftdown wk wv Lf _             = Br wk wv Lf Lf
siftdown wk wv (t @ (Br vk vv _ _)) Lf
    | wk <= vk                  = Br wk wv t Lf
    | otherwise                 = Br vk vv (Br wk wv Lf Lf) Lf
siftdown wk wv (t1 @ (Br vk1 vv1 p1 q1)) (t2 @ (Br vk2 vv2 p2 q2))
    | wk <= vk1 && wk <= vk2    = Br wk wv t1 t2
    | vk1 <= vk2                = Br vk1 vv1 (siftdown wk wv p1 q1) t2
    | otherwise                 = Br vk2 vv2 t1 (siftdown wk wv p2 q2)
deleteMinAndInsertPQ :: Ord k => k -> v -> PriorityQ k v -> PriorityQ k v
deleteMinAndInsertPQ wk wv Lf             = error ""Empty PriorityQ""
deleteMinAndInsertPQ wk wv (Br _ _ t1 t2) = siftdown wk wv t1 t2
leftrem :: PriorityQ k v -> (k, v, PriorityQ k v)
leftrem (Br vk vv Lf Lf) = (vk, vv, Lf)
leftrem (Br vk vv t1 t2) = (wk, wv, Br vk vv t t2) where
    (wk, wv, t) = leftrem t1
leftrem _                = error ""Empty heap!""
deleteMinPQ :: Ord k => PriorityQ k v -> PriorityQ k v
deleteMinPQ (Br vk vv Lf _) = Lf
deleteMinPQ (Br vk vv t1 t2) = siftdown wk wv t2 t where
    (wk,wv,t) = leftrem t1
deleteMinPQ _ = error ""Empty heap!""
type HybridQ k v = (PriorityQ k v, [(k,v)])
initHQ :: PriorityQ k v -> [(k,v)] -> HybridQ k v
initHQ pq feeder = (pq, feeder)
insertHQ :: (Ord k) => k -> v -> HybridQ k v -> HybridQ k v
insertHQ k v (pq, q) = (insertPQ k v pq, q)
deleteMinAndInsertHQ :: (Ord k) => k -> v -> HybridQ k v -> HybridQ k v
deleteMinAndInsertHQ k v (pq, q) = postRemoveHQ(deleteMinAndInsertPQ k v pq, q)
    where
        postRemoveHQ mq@(pq, []) = mq
        postRemoveHQ mq@(pq, (qk,qv) : qs)
            | qk < minKeyPQ pq = (insertPQ qk qv pq, qs)
            | otherwise        = mq
minKeyHQ      :: HybridQ k v -> k
minKeyHQ (pq, q) = minKeyPQ pq
minKeyValueHQ :: HybridQ k v -> (k, v)
minKeyValueHQ (pq, q) = minKeyValuePQ pq"
Haskell,"import Data.List
parse :: String -> [Int]
parse xs = case read (""("" ++ xs ++ "")"") of
    (c1,c2,c3,c4,c5) -> [c1,c2,c3,c4,c5]
(<|>) :: Maybe a -> Maybe a -> Maybe a
Nothing <|> x = x
x       <|> _ = x
conditional :: a -> a -> Bool -> a
conditional x y b = if b then x else y
onePair :: [Int] -> Maybe String
onePair = conditional (Just ""one pair"") Nothing . any ((== 2) . length) . group
twoPair :: [Int] -> Maybe String
twoPair [c1,c2,c3,c4,c5] = conditional (Just ""two pair"") Nothing $ (c1 == c2 && c3 == c4) || (c1 == c2 && c4 == c5) || (c2 == c3 && c4 == c5)
twoPair _ = undefined
threeCard :: [Int] -> Maybe String
threeCard = conditional (Just ""three card"") Nothing . any ((== 3) . length) . group
straight :: [Int] -> Maybe String
straight (x:xs) = conditional (Just ""straight"") Nothing $ impl x xs
    where
        impl :: Int -> [Int] -> Bool
        impl _ [] = True
        impl 1 [10,11,12,13] = True
        impl y (z:zs)
            | succ y == z = impl z zs
            | otherwise   = False
straight _ = undefined
fullHouse :: [Int] -> Maybe String
fullHouse = conditional (Just ""full house"") Nothing . all ((\\ x -> x == 2 || x == 3) . length) . group
fourCard :: [Int] -> Maybe String
fourCard = conditional (Just ""four card"") Nothing . any ((== 4) . length) . group
apply :: [(a -> b)] -> a -> [b]
apply fs x = map (\\ f -> f x) fs
score :: [Int] -> Maybe String
score = foldr (<|>) Nothing . apply [fourCard , fullHouse , straight , threeCard , twoPair , onePair] . sort
solve :: [Int] -> IO ()
solve = putStrLn . maybe ""null"" id . score
    
main :: IO ()
main = getContents
    >>= mapM_ solve . map parse . lines"
Haskell,"import Control.Applicative ((<$>), (<*>))
import Control.Monad
import Data.List
import Data.Array
main :: IO ()
main = do
  n <- getl toInt
  when (n /= 0) $ do
    putStr $ solve n
    main
solve :: Int -> String
solve n = unlines . map concat . split n . map toStr $ elems msqr
  where
    (_,msqr) = foldl putnum (((n+1) `div` 2 + 1, (n+1) `div` 2),(listArray ((1,1),(n,n)) $ repeat 0)) [1..n^2]
    putnum :: ((Int,Int), Array (Int,Int) Int) -> Int -> ((Int,Int), Array (Int,Int) Int)
    putnum ((i,j),ar) k = let nar = ar // [((i,j),k)] in (next nar (i+1,j+1),nar)
    next ar (y, x)
      | y == n+1 && x == n+1 = next ar (1,1)
      | y == n+1 && x == 0 = next ar (1,n)
      | y == n+1 = next ar (1,x)
      | x == n+1 = next ar (y,1)
      | x == 0 = next ar (y,n)
      | ar ! (y,x) /= 0 = next ar (y+1,x-1)
      | otherwise = (y,x)
        
toStr :: Int -> String
toStr x
  | x >= 100 = "" "" ++ show x
  | x >= 10 = ""  "" ++ show x
  | otherwise = ""   "" ++ show x
split :: Int -> [a] -> [[a]]
split n xs
  | null zs = [ys]
  | otherwise = ys : split n zs
  where
    (ys,zs) = splitAt n xs
toInt :: String -> Int
toInt s = read s
getl :: (String -> a) -> IO a
getl f = f <$> getLine"
Haskell,"import Text.Printf
ans :: (Double,Double) -> (Double,Double) -> (Double,Double) -> [Double]
ans (x1,y1) (x2,y2) (x3,y3) =
  
  
  
  
  
  
  
  
  
  
  
  
  
  let a2 = x1^2 - x2^2
      b2 = 2*(x1-x2)
      c2 = y1^2 - y2^2
      d2 = 2*(y1-y2)
      a3 = x1^2 - x3^2
      b3 = 2*(x1-x3)
      c3 = y1^2 - y3^2
      d3 = 2*(y1-y3)
      xp = (a2*d3 + c2*d3 - a3*d2 - c3*d2) / (b2*d3-b3*d2)
      yp = if d2 /= 0
           then (a2+c2-b2*xp) / d2
           else (a3+c3-b3*xp) / d3
      r  = sqrt ( (x1-xp)^2 + (y1-yp)^2 )
  in
    [xp,yp,r]
main = do
  c <- getContents
  let i = map (map read) $ map words $ drop 1 $ lines c :: [[Double]]
      o = map (\\(x1:y1:x2:y2:x3:y3:_) -> ans (x1,y1) (x2,y2) (x3,y3)) i
  mapM_ (\\x -> printf ""%.3f %.3f %.3f\\n"" (x!!0) (x!!1) (x!!2) ) o"
Haskell,"main :: IO()
main = getContents >>= mapM_ (print . solve . read) . lines
solve :: Int -> Int
solve n | n < 100     = length $ takeWhile (<= n) primes
        | n < 1000    = (25 +)     . f $ [101, 103..n]
        | n < 10000   = (168 +)    . f $ [1001, 1003..n]
        | n < 100000  = (1229 +)   . f $ [10001,10003..n]
        | n < 200000  = (9592 +)   . f $ [100001, 100003..n]
        | n < 300000  = (17984 +)  . f $ [200001, 200003..n]
        | n < 400000  = (25997 +)  . f $ [300001, 300003..n]
        | n < 500000  = (33860 +)  . f $ [400001, 400003..n]
        | n < 600000  = (41538 +)  . f $ [500001, 500003..n]
        | n < 700000  = (49098 +)  . f $ [600001, 600003..n]
        | n < 800000  = (56543 +)  . f $ [700001, 700003..n]
        | n < 900000  = (63951 +)  . f $ [800001, 800003..n]
        | n >= 999983 && n < 1000000 = 78498
        | n < 1000000 = (71724 +)  . f $ [900001, 900003..n]
        | otherwise   = (78498 +)  . f $ [1000001, 1000003..n]
    where f = length . (filter isPrime)
primes :: [Int]
primes = (2 :) . (3 :) . (5 :) . (7 :) $ filter isPrime [11, 13..] 
isPrime :: Int -> Bool
isPrime 2 = True
isPrime n
    | n < 2            = False
    | (n `mod` 2) == 0 = False
    | otherwise        = testDiv 3 n
    where testDiv :: Int -> Int -> Bool
          testDiv i n
              | i * i > n      = True
              | n `mod` i == 0 = False
              | otherwise      = testDiv (i + 2) n"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array.IO
import Data.IORef
import Control.Monad.ST
import Data.STRef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
dec [] = []
dec ('@':n:c:s) = replicate (digitToInt n) c ++ dec s
dec (c:s) = (c:dec s)
main = map dec . lines <$> getContents >>= mapM_ putStrLn"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Array.IO
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
main = do
    [a, b] <- map (map (readInt . takeWhile (/=','))) . splitWhen (=="""") . lines <$> getContents
    let counts = map (applyTuple (head, length)) $ group $ sort (a ++ b)
    mapM_ putStrLn $ map (applyBin (((++) .) (++"" "")) (show . fst) (show . snd)) $ filter (flip elem b . fst) $ filter (flip elem a . fst) counts"
Haskell,"import Control.Monad
import Control.Applicative
import Data.Functor
import Data.Function
import Data.Monoid
import Data.Maybe
import Data.List
import Data.Foldable (foldMap)
import Data.List.Split
import Data.Char
import Data.Ratio
import Data.Ord
import Data.Tuple
import Data.Array.IO
import Data.IORef
import Control.Monad.ST
import Data.STRef
 
readInt = read :: String -> Int
readDouble = read :: String -> Double
getInt = readLn :: IO Int
getInts = map readInt . words <$> getLine
sjoin :: (Show a) => [a] -> String
sjoin = unwords . map show
cond :: a -> a -> Bool -> a
cond t f c = if c then t else f
applyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
applyBin op f g x = op (f x) $ g x
applyUni :: (a -> b -> c) -> (a -> b) -> a -> c
applyUni op f x = op x $ f x
applyTuple :: (a -> b, a -> c) -> a -> (b, c)
applyTuple (f,g) a = (f a, g a)
main = map fst . filter ((>=25) . snd) . map ((\\[s,w,h] -> (s, readDouble w / readDouble h ^ 2)) . wordsBy (==',')) . lines <$> getContents >>= mapM_ putStrLn"
Haskell,"import Data.List (nub, intersect)
import Data.IntMap (insert, keys, (!), fromList)
 
main = interact $ unlines . casenum . map (show' . bombs_chain) . read' . tail . lines
 where
  read' = foldr (\\(_:str) acc -> let (b,[x,y]) = splitAt 8 str in ((read x, read y), concat b) : acc) [] . groupAt 11
  show' = init . unlines . groupAt 8
  casenum = zipWith (++) (map (\\n -> ""Data "" ++ show n ++ "":\\n"") [1..])
 
bombs_chain ((bx,by), board) = foldr (\\p acc -> replace acc p '0') board bombed
 where
  pos = (by-1)*8 + bx-1
  bombed = make_shortcuts pos (blast_graph board) ! pos
  blast_graph = fromList . add_blast . coordinates
  add_blast cs = map (\\c -> (c, filter (in_range c) cs)) cs
  coordinates board = [x | x<-[0..63], is_installed x board]
  is_installed ix board = board !! ix == '1'
  in_range ix bx
   | elem ix $ filter (\\x -> div x 8 == div bx 8) [bx-3,bx-2,bx-1,bx,bx+1,bx+2,bx+3] = True
   | elem ix [bx-24,bx-16,bx-8,bx,bx+8,bx+16,bx+24] = True
   | otherwise = False
make_shortcuts v im = untilFix (make_shortcut v) im
make_shortcut v im = insert v new im
 where new = nub $ (im!v) ++ concatMap (im !) (intersect (keys im) (im!v))
 
untilFix f x = if f x == x then x else untilFix f (f x)
replace xs i r = foldr (\\x acc -> if (i+1) + length acc == length xs then r:acc else x:acc) [] xs
 
groupAt n [] = []
groupAt n xs = take n xs : groupAt n (drop n xs)"
PHP,"<?php
$map = array_fill(0, 10, array_fill(0, 10, 0));
while (($line = trim(fgets(STDIN))) !== '') {
    sscanf($line, '%d,%d,%d', $x, $y, $size);
    
    if ($size === 1) {
        isset($map[$y - 1]) && $map[$y - 1][$x]++;
        isset($map[$y + 1]) && $map[$y + 1][$x]++;
        isset($map[$y][$x - 1]) && $map[$y][$x - 1]++;
        isset($map[$y][$x + 1]) && $map[$y][$x + 1]++;
        $map[$y][$x]++;
        continue;
    }
    
    if ($size === 3) {
        isset($map[$y - 2]) && $map[$y - 2][$x]++;
        isset($map[$y + 2]) && $map[$y + 2][$x]++;
        isset($map[$y][$x - 2]) && $map[$y][$x - 2]++;
        isset($map[$y][$x + 2]) && $map[$y][$x + 2]++;
    }
    
    for ($y2 = $y - 1; $y2 <= $y + 1; $y2++) {
        if ($y2 < 0 || $y2 > 9) {
            continue;
        }
        for ($x2 = $x - 1; $x2 <= $x + 1; $x2++) {
            if ($x2 >= 0 && $x2 < 10) {
                $map[$y2][$x2]++;
            }
        }
    }
}
$cnt = 0;
$max = 0;
for ($y = 0; $y < 10; $y++) {
    for ($x = 0; $x < 10; $x++) {
        $n = $map[$y][$x];
        $max = max($max, $n);
        !$n && $cnt++;
    }
}
printf(, $cnt, $max);"
PHP,"<?php
$string_tmp = array();
$ans_set = array();
while ($line = fgets(STDIN)) {
   $tmp[] = trim($line);
}
$max_lenge = 8;
foreach($tmp as $val){
    
    $max_lenge--;
    
    if(preg_match('/1/',$val)){
        $string_tmp[] = $val;
    }
     
    if($max_lenge < 0){
        $ans_set[] = judge($string_tmp);
        
        $string_tmp = array();
        $max_lenge = 8;
    }
}
$ans_set[] = judge($string_tmp);
foreach($ans_set as $val){
    echo $val.;
}
function judge($string_tmp){
    $ans;
    $tmp_length = count($string_tmp);
        if($tmp_length == 4){
            $ans = ;
        }elseif($tmp_length == 1){
            $ans = ;
        }elseif($tmp_length == 2){
            $ans = judge_line2($string_tmp);
        }elseif($tmp_length == 3){
            $ans = judge_line3($string_tmp);
        }
    return $ans;
}
function judge_line2($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos == $pos2){
        return ;
    }elseif ($pos < $pos2) {
        return ;
    }else{
        return ;
    }
}
function judge_line3($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos > $pos2){
        return ;
    }else{
        return ;
    }
}"
PHP,"<?php
$string_tmp = array();
$ans_set = array();
while ($line = fgets(STDIN)) {
   $tmp[] = trim($line);
}
$max_lenge = 8;
foreach($tmp as $val){
    
    $max_lenge--;
    
    if(preg_match('/1/',$val)){
        $string_tmp[] = $val;
    }
     
    if($max_lenge < 0){
        $tmp_length = count($string_tmp);
        if($tmp_length == 4){
            $ans_set[] = ;
        }elseif($tmp_length == 1){
            $ans_set[] = ;
        }elseif($tmp_length == 2){
            $ans_set[] = judge_line2($string_tmp);
        }elseif($tmp_length == 3){
            $ans_set[] = judge_line3($string_tmp);
        }
        
        $string_tmp = array();
        $max_lenge = 8;
    }
}
$ans_set[] = judge($string_tmp);
foreach($ans_set as $val){
    echo $val.;
}
function judge($string_tmp){
    $ans;
    $tmp_length = count($string_tmp);
        if($tmp_length == 4){
            $ans = ;
        }elseif($tmp_length == 1){
            $ans = ;
        }elseif($tmp_length == 2){
            $ans = judge_line2($string_tmp);
        }elseif($tmp_length == 3){
            $ans = judge_line3($string_tmp);
        }
    return $ans;
}
function judge_line2($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos == $pos2){
        return ;
    }elseif ($pos < $pos2) {
        return ;
    }else{
        return ;
    }
}
function judge_line3($string_tmp){
    $pos = strpos($string_tmp[0], );
    $pos2 = strpos($string_tmp[1], );
    if($pos > $pos2){
        return ;
    }else{
        return ;
    }
}"
PHP,"<?php
$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));
function dfs($c, $y, $x){
	global $move;
	global $map;
	global $goal_flag;
	global $yg;
	global $xg;
	if ($y === $yg && $x === $xg){	
		$goal_flag = 1;
		return;
	}
	$map[$c][$y][$x] = 0;	
	for ($i=0; $i<=3; $i++){	
		$y2 = $y + $move[$i][1];
		$x2 = $x + $move[$i][0];
		if (!empty($map[$c][$y2][$x2]) && $map[$c][$y2][$x2]===1){
			dfs($c, $y2, $x2);
		}
	}
	return;
}
while(1){
	
	$goal_flag = 0;
	$map = array();
	$usecolor = 0;		
	
	fscanf(STDIN, '%d %d', $w, $h);
	
	if ($w==0 && $h==0){
		break;
	}
	fscanf(STDIN, '%d %d', $xs, $ys);
	fscanf(STDIN, '%d %d', $xg, $yg);
	fscanf(STDIN, '%d', $n);
	for ($i=0; $i<$n; $i++){
		fscanf(STDIN, '%d %d %d %d', $c, $d, $xblock, $yblock);
		
		if ($d === 0){		
			for ($p=0; $p<=3; $p++){
				for ($q=0; $q<=1; $q++){
					$map[$c][$yblock + $q][$xblock + $p] = 1;
				}
			}
		} else {
			for ($p=0; $p<=1; $p++){
				for ($q=0; $q<=3; $q++){
					$map[$c][$yblock + $q][$xblock + $p] = 1;
				}
			}
		}
	}
	
	for ($c=1; $c<=5; $c++){
		if (!empty($map[$c][$ys][$xs]) && $map[$c][$ys][$xs] === 1){
			$usecolor = $c;
			break;
		}
	}
	
	if ($usecolor !== 0){
		dfs($usecolor, $ys, $xs);
	}
	
	if ($goal_flag === 1){
		echo 'OK';
	} else {
		echo 'NG';
	}
	echo PHP_EOL;
}"
PHP,"<?php
while ($g = rtrim(fgets(STDIN))){ 
    $a = preg_split(, $g);
    
    
    $player_sum = $a[0] + $a[1];
    
    
    $player_left = 20 - $player_sum;
    
    
    
    
    
    $opponent_card = $a[2];
    
    
    $card_all = [];
    for ($i=1; $i <= 10 ; $i++) {
        if ($i == $a[0]){
            $card_all[] = 0;
        } else if ($i == $a[1]){
            $card_all[] = 0;
        } else if ($i == $a[2]){
            $card_all[] = 0;
        } else {
            $card_all[] = $i;
        }
    }
    
    
    $count = 0;
    for ($i=0; $i < 10 ; $i++) { 
        if($card_all[$i] <= $player_left && $card_all[$i] !== 0){
            $count++;
        }
    }
    if ($count >= 4){
        print 'YES';
    } else {
        print 'NO';
    }
    print PHP_EOL;
    
}"
PHP,"<?php
	$inputArr = ReadStd();
	$octalArr = ChangeOctalToDecimal($inputArr);
	$answerArr = CreateAnswer($octalArr);
	Display($answerArr);
	/**
      * ?¨??????\\?????????????????????????????????????????????????????????
      */
    function ReadStd(){
	    $inputArr = array();
		while(intval($line_num = trim(fgets(STDIN)))!=0){
			$inputArr[] =  intval($line_num);
		}
		return $inputArr;
	}
	/**
      * ?????°??§??????????????????????????°???????????????????????°????????????????????????
      */
	function ChangeOctalToDecimal($inputArr){
		$octalArr = array();
		foreach ($inputArr as $num) {
			$octalArr[] = decoct ( $num );
		}
		return $octalArr;
	}
	/**
      * 4567???????????????5789??????????????????
      * ?????????8?????°???0,1,2,3,4,5,6,7?????????
      * ?????????8?????°???0,1,2,3,5,7,8,9???????????????????????????
      */
	function CreateAnswer($octalArr){
		$answerArr = array();
		foreach ($octalArr as $num) {
            $num = str_replace (  ,  , $num );
            $num = str_replace (  ,  , $num );            
            $num = str_replace (  ,  , $num );
            $num = str_replace (  ,  , $num );
            $answerArr[] = $num;
		}
		return $answerArr;
	}
	/**
      * ?????????????????????
      */
	function Display($answerArr){
		echo implode(,$answerArr);
	}
?>"
PHP,"<?php
class AOJ0534 {
    var $T;
    var $TC;
    var $L;
    var $LC;
    public function init() {
        $L = &$this->L;
        $LC = &$this->LC;
        $T = &$this->T;
        $TC = &$this->TC;
        
        $in = file_get_contents('/dev/stdin');
        $L = explode( , trim($in) );
        $LC = count($L);
        $T = array();
        $TC = 0;
    }
    
    public function input() {
        $L = &$this->L;
        $LC = &$this->LC;
        $T = &$this->T;
        $TC = &$this->TC;
        
        for ( $i = 0; $i < $LC; ++ $i ) {
            if ( $L[$i] ==  ) break;
            $n = $L[$i++];
            $T[$TC] = array();
            for ( $j = 0; $j < $n; ++ $j ) {
                $T[$TC][] = intval($L[$i++]);
            }
            $TC++;
            $i--;
        }
    }
    public function check($s) {
        for ( $i = 1; $i <= 3; ++ $i ) {
            $key = str_repeat( $i, 4 );
            if ( strstr( $s, $key ) ) return true;
        }
        return false;
    }
    public function calc($s) {
        while ( $this->check($s) ) {
            for ( $i = 1; $i <= 3; ++ $i ) {
                $regexp = .$i.;
                $s = preg_replace( $regexp, '', $s );
            }
        }
        return $res = strlen($s);
    }
    public function check_around( $s, $k ) {
        $res = 0;
        $n = strlen($s);
        for ( $i = 0; $i < 4; ++ $i ) {
            $id = $k - $i - 1;
            if ( $id < 0 ) break;
            if ( $s[$k] != $s[$id] ) break;
            $res ++;
        }
        for ( $i = 0; $i < 4; ++ $i ) {
            $id = $k + $i + 1;
            if ( $id >= $n ) break;
            if ( $s[$k] != $s[$id] ) break;
            $res ++;
        }
        return $res + 1;
    }
    
    public function solve($s_) {
        $res = PHP_INT_MAX;
        $s = implode('', $s_);
        for ( $i = 1; $i <= 3; ++ $i ) {
            $regexp = .$i.;
            $s = preg_replace( $regexp, str_repeat($i, 4), $s );
        }
        $n = strlen($s);
        for ( $i = 0; $i < $n; ++ $i ) {
            $t = $s;
            for ( $j = 1; $j <= 3; ++ $j ) {
                if ( $t[$i] == $j ) continue;
                $t[$i] = $j;
                if ( $this->check_around( $t, $i ) < 4 ) continue;
                if ( ( $i-1 >= 0 && $t[$i-1] == $j ) || ( $i+1 < $n && $t[$i+1] == $j ) ) {
                    $res = min( $res, $this->calc($t) );
                }
            }
        }
        return $res;
    }
    
    public function run() {
        $this->init();
        $this->input();
        foreach ( $this->T as $test ) {
            echo $this->solve($test).;
        }
    }
}
$instance = new AOJ0534;
$instance->run();"
PHP,"<?php
$a = array(0,1,2,3,4,5,6,7,8,9);
function dfs($i, $n, $s, $sum, $stack){
	
	global $a;
	global $ans;
	
	if ( $i == count($a) ) {
		
		if ($sum == $s && count($stack) == $n) {
			$ans[] = array_slice($stack, 0);	
		}
		return ;
	}
	
	
	
	dfs($i+1, $n, $s, $sum, $stack);
	
	array_push($stack, $a[$i]);	
	dfs($i+1, $n, $s, $sum+$a[$i], $stack);
	array_pop($stack);	
}
while (1) {
	fscanf(STDIN, '%d %d', $n, $s);
	
	
	$i = 0;
	$sum = 0;
	$stack = array();
	$ans = array();
	
	if ($n == 0 && $s == 0) {
		break;
	}
	
	dfs($i, $n, $s, $sum, $stack);
	
	$len_ans = count($ans);
	
	echo $len_ans;
	echo PHP_EOL;
}"
PHP,"<?php
while (!feof(STDIN)) {
  $stdin = trim(fgets(STDIN));
  $values  = explode(',', $stdin);
  if (count($values) != 5) {
  } else {
    $temp = array();
    foreach ($values as $value) {
      if (!isset($temp[$value])) {
        $temp[$value] = 1;
      } else {
        $temp[$value]++;
      }
    }
    ksort($temp);
    $ret = 'null';
    foreach ($temp as $t) {
      if ($t == 4) {
        $ret = 'four card';
      } elseif ($t == 3) {
        if ($ret == 'one pair') {
          $ret = 'full house';
        } else {
          $ret = 'three card';
        }
      } elseif ($t == 2) {
        if ($ret == 'one pair') {
          $ret = 'two pair';
        } elseif ($ret == 'three card') {
          $ret = 'full house';
        } else {
          $ret = 'one pair';
        }
      }
    }
    $temp = array_keys($temp);
    if (count($temp) == 5 && $temp[4] - $temp[0] == 4) {
      $ret = 'straight';
    }
    
    $temp2 = array();
    foreach ($temp as $t) {
      if ($t == 1) {
        $temp2[] = 14;
      } else {
        $temp2[] = $t;
      }
    }
    sort($temp2);
    if (count($temp2) == 5 && $temp2[4] - $temp2[0] == 4) {
      $ret = 'straight';
    }
    echo $ret . ;
  }
}"
PHP,"<?php
$case = 0;
while (TRUE) {
	$dp = array();
	$W = trim(fgets(STDIN));
	if ($W == 0) {
		break;
	}
	$case++;
	$N = trim(fgets(STDIN));
	$items = array();
	for ($i = 0; $i < $N; $i++) {
		list($v, $w) = explode(',', trim(fgets(STDIN)));
		$items[] = array('value' => $v, 'weight' => $w);
	}
	$res = rec(0, $W, 0);
	echo ;
	echo $res[0] . ;
	echo $res[1] . ;
}
function rec($i, $w, $total) {
	global $dp, $N, $items;
	if (isset($dp[$i][$w])) {
		return $dp[$i][$w];
	}
	$res = null;
	if ($i == $N) {
		
		$res =  array(0, $total);
	} elseif ($w < $items[$i]['weight']) {
		
		$res = rec($i + 1, $w, $total);
	} else {
		
		$v1 = rec($i + 1, $w, $total);
		$v2 = rec($i + 1, $w - $items[$i]['weight'], $total + $items[$i]['weight']);
		$v2[0] += $items[$i]['value'];
		if ($v1[0] < $v2[0]) {
			$res = $v2;
		} else {
			$res = $v1;
		}
	}
	return $dp[$i][$w] = $res;
}"
JavaScript,"function Vector(x, y) {
  this.x = x;
  this.y = y;
}
Vector.prototype.sub = function(v) {
  return new Vector(this.x - v.x, this.y - v.y);
};
Vector.prototype.product = function(v) {
  return this.x * v.y - this.y * v.x;
};
(function(input) {
  var line = input.replace(/\\n$/, '').split('\\n');
  while (line.length > 0) {
    var p = line.shift().split(' ').map(Number);
    var v1 = new Vector(p.shift(), p.shift());
    var v2 = new Vector(p.shift(), p.shift());
    var v3 = new Vector(p.shift(), p.shift());
    var p = new Vector(p.shift(), p.shift());
    var v12 = v2.sub(v1);
    var v2p = p.sub(v2);
    var v23 = v3.sub(v2);
    var v3p = p.sub(v3);
    var v31 = v1.sub(v3);
    var v1p = p.sub(v1);
    var c1 = v12.product(v2p);
    var c2 = v23.product(v3p);
    var c3 = v31.product(v1p);
    
    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {
      console.log('YES');
      continue;
    }
    console.log('NO');
  }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
JavaScript,"function Main(input) {
    var week = [,,,,,,];
    inputLine = input.split();
    for(var i=0;;i++){
        var dateObj = new Date();
        dateObj.setFullYear(2004);
        var date = inputLine[i].split();
        var month = int(date[0]);
        var day = int(date[1]);
        if(month === 0)break;
        dateObj.setMonth(month-1);
        dateObj.setDate(day);
        output(week[dateObj.getDay()]);
        dateObj=null;
    }
}
function ascendingOrder(val1,val2){
    return val1 - val2;
}
function descendingOrder(val1,val2){
    return val2 - val1;
}
function int(str){
    return parseInt(str, 10);
}
function str(num){
    return num.toString(10);
}
function output(str){
	if(_Isdebug){
		document.getElementById().value+=(str+);
	}
	console.log(str);
}
var _Isdebug = false;
function debug(){
	_Isdebug = true;
	var input = document.getElementById().value;
	document.getElementById().value+=;
	Main(input);
}
Main(require().readFileSync(, ));"
JavaScript,"(function(input) {
    var p = input.replace(/\\n$/, '').split('\\n');
    var n = Number(p.shift());
    for (var i = 0; i < n; i++) {
        var args = p[i].split(' ').map(Number);
        
        var x1 = args.shift();
        var y1 = args.shift();
        var x2 = args.shift();
        var y2 = args.shift();
        var x3 = args.shift();
        var y3 = args.shift();
        var x = ((Math.pow(x3, 2) - Math.pow(x2, 2) + Math.pow(y3, 2) - Math.pow(y2, 2)) * (y2 - y1)
            - (Math.pow(x2, 2) - Math.pow(x1, 2) + Math.pow(y2, 2) - Math.pow(y1, 2)) * (y3 - y2))
            / 2 / ((y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2));
        var y = ((Math.pow(y3, 2) - Math.pow(y2, 2) + Math.pow(x3, 2) - Math.pow(x2, 2)) * (x2 - x1)
            - (Math.pow(y2, 2) - Math.pow(y1, 2) + Math.pow(x2, 2) - Math.pow(x1, 2)) * (x3 - x2))
            / 2 / ((x2 - x1) * (y3 - y2) - (y2 - y1) * (x3 - x2));
        console.log(x.toFixed(3), y.toFixed(3), Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2)).toFixed(3));
    }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
JavaScript,"function generateTrianglesFromInput(input) {
  var max = 1000;
  var lines = getInputAsLines(input, );
  var vertices = lines.map(processLineToVertices);
  for(var i = 0; i < vertices.length; i++) {
    var line = vertices[i];
    if(i === 0) {
      if(line[0] > max) {
        break;
      }
    }
    var tri = new Triangle({
      constraints: {
        min: 1,
        max: 1000
      },
      vertices: {
        a: line[0],
        b: line[1],
        c: line[2]
      }
    });
    if(tri.isValid()) {
      var isRightAngleTriangle = tri.isRightAngleTriangle();
      var logValue = (isRightAngleTriangle) ? 'YES' : 'NO';
      console.log(logValue);
    }
  }
}
function getInputAsLines(input, delimeter) {
  return input.split(delimeter);
}
function processLineToVertices(line) {
  var vertices = line.split(' ');
  return vertices;
}
function Triangle(options) {
  this.constraints = {};
  this.vertices = {};
  
  this.constraints.min = options.constraints.min || 1;
  this.constraints.max = options.constraints.max || 1000;
  
  this.vertices.a = (this.vertexIsWithinConstraints(options.vertices.a)) ? options.vertices.a : null;
  this.vertices.b = (this.vertexIsWithinConstraints(options.vertices.b)) ? options.vertices.b : null;
  this.vertices.c = (this.vertexIsWithinConstraints(options.vertices.c)) ? options.vertices.c : null;
}
Triangle.prototype.vertexIsWithinConstraints = function(vertex) {
  return (vertex >= this.constraints.min && vertex <= this.constraints.max);
}
Triangle.prototype.isValid = function() {
  return (this.vertices.a && this.vertices.b && this.vertices.c);
}
Triangle.prototype.isRightAngleTriangle = function() {
  var value = false;
  if(this.isValid) {
    var vertexArray = [];
    vertexArray.push(this.vertices.a);
    vertexArray.push(this.vertices.b);
    vertexArray.push(this.vertices.c);
    vertexArray.sort(function(a, b) {return a-b});
    var squares = vertexArray.map(function (vertex) { return Math.pow(vertex, 2)});
    value = (squares[2] === (squares[0] + squares[1]));
  }
  return value;
}
var input = require('fs').readFileSync('/dev/stdin', 'utf8').trim();
generateTrianglesFromInput(input);"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');
main();
 
function main(){
  var operands = ['+', '-', '*'];
  var inp;
  for(var i = 0; (inp = input[i]) != '0 0 0 0'; i++){
    inp = new Int8Array(inp.split(' ').map(Number));
    var found = false;
    var searched = new Int8Array(10000);
 
  FIRST:for(var a = 0; a < 4; a++){
    var inpa = inp[a]; 
    for(var b = 0; b < 4; b++){
      if(a==b)continue;
      var inpb = inp[b];
      for(var c = 0; c < 4; c++){
        if(a==c||b==c)continue;
        var inpc = inp[c];
        for(var d = 0; d < 4; d++){
          if(a==d||b==d||c==d)continue;
          var inpd = inp[d];
          var target = inpa*1000 + inpb*100 + inpc*10 + inpd;
          if(searched[target])
            continue;
          searched[target]++;
          for(var op1 = 0; op1 < 3; op1++){
            var operandsop1 = operands[op1];
            for(var op2 = 0; op2 < 3; op2++){
              var operandsop2 = operands[op2];
              for(var op3 = 0; op3 < 3; op3++){
                var operandsop3 = operands[op3];
                if(op1 == 1 && op2 == 1 && op3 == 1)continue;
                
                for(var pattern = 0; pattern < 3; pattern++){
                  var polish = [];
                  switch(pattern){
                  case 0:
                    
                    polish = [inpa, inpb, operandsop1, inpc, operandsop2, inpd, operandsop3];
                    break;
                  case 1:
                    
                    polish = [inpa, inpb, inpc, operandsop1, operandsop2, inpd, operandsop3];
                    break;
                  case 2:
                    
                    polish = [inpa, inpb, operandsop1,inpc, inpd, operandsop2, operandsop3];
                    break;
                  }
 
                  var stack = [];
                  for(var j = 0; j < 7; j++){
                    var h = polish[j];
                    switch(h){
                    case '+':
                      stack.push(stack.pop() + stack.pop());
                      break;
                    case '-':
                      stack.push(-stack.pop() + stack.pop());
                      break;
                    case '*':
                      stack.push(stack.pop() * stack.pop());
                      break;
                    default:
                      stack.push(h);
                      break;
                    }
                  }
 
                  if(stack.pop() == 10){
                    found = true;
 
                    var result = [];
                    var l, r;
                    for(var j = 0; j < 7; j++){
                    var h = polish[j];
                      if(h == '+' || h == '-' || h == '*'){
                        r = result.pop();
                        l = result.pop();
                        result.push( + l +  + h +  + r + );
                      }else{
                        result.push(h);
                      }
                    }
                     
                    console.log(result.pop());
                    break FIRST;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
 
    if(!found)
      console.log(0);
     
  }
}"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int32Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int32Array(maxWeight + 1);
 
      for(var w = 1; w < tw; w++){
        dp[w] = pdp[w];
      }
       
      for(var w = tw; w <= maxWeight; w++){
        dp[w] = max(pdp[w-tw] + tv, pdp[w]);
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i]
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
JavaScript,"var primeNxt = new Array(1000000);
function primeGenerator()
{
    var p, fact, m;
    var maxN = 9999999;
    var primePrv = new Array(1000000);
    
    for(p=2;p<=maxN;++p){
        primeNxt[p] = p + 1;
        primePrv[p] = p - 1;
    }
    primePrv[2] = 0;
    primeNxt[maxN] = 0;
    
    
    for(p=2;p*p<=maxN;p=primeNxt[p]){
        for(fact=p;p*fact<=maxN;fact=primeNxt[fact]){
            for(m=p*fact;m<=maxN;m*=p){
                primeNxt[primePrv[m]] = primeNxt[m];
                primePrv[primeNxt[m]] = primePrv[m];
            }
        }
    }
}
process.stdin.resume();
process.stdin.setEncoding('utf8');
 
process.stdin.on('data', function(input){
    primeGenerator();
    input.trim().split('\\n').forEach(function(val){
        var N = parseInt(val);
        var cnt = 1;
        if( N == 1 ){
            console.log(0);
        }
        else if( N == 2 ){
            console.log(1);
        }
        else{
            for(var i=3;i<=N;i=primeNxt[i]){
               ++cnt;
            }
            console.log(cnt);
        }
    });
});"
JavaScript,"(function(input) {
  var p = input.replace(/\\n$/, '').split('\\n');
  var n = p.length;
  for (var i = 0; i < n; i++) {
    var a = p.shift().split(',').map(Number);
    var r = {};
    for (var j = 0; j < a.length; j++) {
      if (a[j] in r) {
        r[a[j]]++;
      } else {
        r[a[j]] = 1;
      }
    }
    var c = [];
    for (var k in r) {
      if (r[k] in c) {
        c[r[k]].push(k);
      } else {
        c[r[k]] = [k];
      }
    }
    console.log(check(c));
  }
})(require('fs').readFileSync('/dev/stdin', 'utf8'));
function check(c) {
  if (c[4]) {
    return 'four card';
  }
  if (c[3] && c[2]) {
    return 'full house';
  }
  if (c[1] && c[1].length === 5) {
    var a = c[1];
    a = a.map(Number).sort(function (a, b) {
      return a - b;
    });
    
    if (a[0] > 9) {
      return 'null';
    }
    if (a[1] === 10) {
      return 'straight';
    }
    if (a[1] === a[0] + 1 &&
      a[2] === a[1] + 1 &&
      a[3] === a[2] + 1 &&
      a[4] === a[3] + 1
    ) {
      return 'straight';
    }
  }
  if (c[3]) {
    return 'three card';
  }
  if (c[2] && c[2].length === 2) {
    return 'two pair';
  }
  if (c[2]) {
    return 'one pair';
  }
  return 'null';
}"
JavaScript,"  
function main(){
  var localInput = input;
  var f = [];
  for(var y=-2;y<12;y++){
    f[y] = [];
    for(var x=-2;x<12;x++){
      f[y][x] = 0;
    }
  }
  
  var len = localInput.length - 1;
  for(;len--;){
    var l = localInput[len];
    var ix = parseInt(l[0]);
    var iy = parseInt(l[2]);
    switch(l[4]){
    case '3': 
      f[iy+2][ix]++;
      f[iy-2][ix]++;
      f[iy][ix-2]++;
      f[iy][ix+2]++;
    case '2':
      f[iy+1][ix-1]++;
      f[iy+1][ix+1]++;
      f[iy-1][ix-1]++;
      f[iy-1][ix+1]++;
    case '1':
      f[iy+1][ix]++;
      f[iy][ix-1]++;
      f[iy][ix]++;
      f[iy][ix+1]++;
      f[iy-1][ix]++;
      break;
    }
  }
  
  var nd=0;
  var md=0;
  var y = 10;
  for(;y--;){
    var x = 10;
    for(;x--;){
      nd += !(f[y][x]);
      md = mx(f[y][x], md);
    }
  }
  
  console.log(nd);
  console.log(md);
}
   
function mx(a, b){
 var t = (a-b);
 return a - (t & (t >> 31));
}
var
input = '';
  
process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk) {
  input += chunk;
});
process.stdin.on('end', function() {
  input = input.split('\\n');
  main();
});"
JavaScript,"var fs = require('fs'),
length = fs.fstatSync(process.stdin.fd).size,
buffer = new Buffer(length),
bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),
input = buffer.toString('utf8', 0, bytesRead).split('\\n');
main();
 
function main(){
  var read = 0;
  var resultCase = 1;
  while(true){
    var maxWeight = +input[read++];
    if(!maxWeight){
      break;
    }
     
    var treasures = +input[read++];
    var pdp = new Int16Array(maxWeight + 1);
    for(var i = treasures; i--;){
      var c = input[read++].split();
      var tv = +c[0];
      var tw = +c[1];
 
      var dp = new Int16Array(maxWeight + 1);
      for(var w = 1; w <= maxWeight; w++){
        var pdpw = pdp[w];
        dp[w] = pdpw;
        if(w - tw >= 0){
          dp[w] = max(pdp[w-tw] + tv, pdpw);
        }
      }
      pdp = dp;
    }
 
    var resultWeight = 1001;
    var resultCost = 0;
    for(var i = 0; i <= maxWeight; i++){
      var pdpi = pdp[i];
      if(pdpi > resultCost){
        resultCost = pdpi;
        resultWeight = i;
      }
    }
     
    console.log( + resultCase++ +  + resultCost +  + resultWeight);
  }
}
 
function max(a, b) {
  var t = a - b;
  return a - (t & (t >> 31));
}"
C,"#include<stdio.h>
typedef struct eq
{
	int a;
	int b;
	int c;
} eq_t;
int main(){
	eq_t eq1, eq2;
	double ans_x, ans_y;
	
	while(scanf(, &eq1.a, &eq1.b, &eq1.c, &eq2.a, &eq2.b, &eq2.c)==6)
	{
		if(eq1.b == 0)
		{
			ans_x = (double)(eq1.c / eq1.a);
			ans_y = (double)(( eq2.c - eq2.a * ans_x ) / eq2.b);
		}
		else if(eq1.a == 0)
		{
			ans_y = (double)(eq1.c / eq1.b);
			ans_x = (double)(( eq2.c - eq2.b * ans_y ) / eq2.a);
		}
		else
		{
			if(eq2.b == 0)
			{
				ans_x = (double)(eq2.c / eq2.a);
				ans_y = (double)(( eq1.c - eq1.a * ans_x ) / eq1.b);
			}
			else if(eq2.a == 0)
			{
				ans_y = (double)(eq2.c / eq2.b);
				ans_x = (double)(( eq1.c - eq1.b * ans_y ) / eq1.a);
			}
			else
			{
				ans_x = (double)( eq1.c * eq2.b - eq1.b * eq2.c );
				ans_x = ans_x / ( eq1.a * eq2.b - eq1.b * eq2.a );
				ans_y = (double)(( eq1.c - eq1.a * ans_x ) / eq1.b);
			}
		}
		ans_x = ans_x + 0.000499999999;
		ans_y = ans_y + 0.000499999999;
		printf(, ans_x, ans_y);
	}
	
    return 0;
}"
C,"#include <stdio.h>
#include <math.h>
int max(int n1, int n2, int n3) {
    int max;
    
    max = n1;
    
    if(n2 > max)
        max = n2;
    if(n3 > max)
        max = n3;
    
    return(max);
}
int others(int n1, int n2, int n3) {
    int na = 0;
    int nb = 0;
    int two_pow2;
    
    if(n1 != max(n1, n2, n3)) {
        na = n1;
    }
    if(n2 != max(n1, n2, n3)) {
        if(na == 0)
            na = n2;
        else {
            nb = n2;
        }
    }
    if(n3 != max(n1, n2, n3)) {
        if(na == 0 || nb == 0){
            if(na == 0)
                na = n3;
            else {
                nb = n3;
            }
        }
    }
    
    two_pow2 = pow(na, 2) + pow(nb, 2);
    
    return(two_pow2);
    
}
void two_pow2(int n1, int n2, int n3) {
    
    if(others(n1, n2, n3) == pow(max(n1, n2, n3), 2))
        puts();
    else
        puts();
    
}
int main(void) {
    int n1, n2, n3;
    int num, i;
    
    scanf(, &num);
    
        
    for(i = 0; i < num; i++) {
        if(num > 1000) break;
        
        scanf(, &n1, &n2, &n3);
    
        two_pow2(n1, n2, n3);
    }
    
    return(0);
}"
C,"#include <stdio.h>
int main(void) 
{
  /*
  int mountains[] = { 1819, 2003, 876, 2840, 1723, 1673, 3776, 2848,
		      1592, 922 };
  */
  int mountains[10];
  int scan = 0;
  for ( scan; scan < 10; ++scan ) {
    scanf(, &mountains[scan]);
    
    if ( mountains[scan] < 0 || mountains[scan] > 10000 ) {
      
      return -1;
    }
  }
  int first = 0;
  int second = 0;
  int third = 0;
  int x = 0;
  for ( x; x < 10; ++x ) {
    if ( mountains[x] > first ) {
      int old_first = first;
      first = mountains[x];
      if ( old_first > second ) {
	int old_second = second;
	second = old_first;
	if ( old_second > third ) {
	  third = old_second;
	}
      }
    } else if ( mountains[x] > second ) {
      int old_second = second;
      second = mountains[x];
      if ( old_second > third ) {
	third = old_second;
      }
    } else if ( mountains[x] > third ) {
      third = mountains[x];
    }
  }
  printf(, first);
  printf(, second);
  printf(, third);
  return 0;
}"
C,"#include <stdio.h>
#include <math.h>
int main(){
    int a,b,r=100,a2,b2,i,cnt=0,s=1;
    long int yaku[1000]={0},bai[1000];
    while(scanf(,&a,&b)!=EOF){
        a2=a;
        b2=b;
        if(a>b){
            r=a-b;
        }else{
            r=b-a;
        }
        while(r!=0){
            if(a2>b2){
                r=a2-b2;
                a2=b2;
                b2=r;
                s=1;
            }else{
                r=b2-a2;
                b2=a2;
                a2=r;
                s=2;
            }
        }
        if(s==1){
            yaku[cnt]=a2;
        }else{
            yaku[cnt]=b2;
        }
        bai[cnt]=1;
        for(i=100;i>1;i--){
            if(a%i==0&&b%i==0){
                while(1){
                    a=a/i;
                    b=b/i;
                    bai[cnt]*=i;
                    if(a%i!=0||b%i!=0) break;
                }
            }
        }
        
        bai[cnt]*=a*b;
        cnt++;
        r=100;
    }
    for(i=0;i<cnt;i++){
        printf(,yaku[i],bai[i]);
    }
    return 0;
}"
C,"#include <stdio.h>
int main(){
	printf(
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           );
	return 0;
}"
C,"/*
aとbの最小公倍数、最大公約数を求めよ。
aとbは20億以下とする。
ただし、公倍数も20億以下とする。
やり方：
	・aとbを入力。
	・最小公倍数を求める関数koubai00と、最大公約数を求める関数kouyaku00を使い、
		配列2つ（koubai[]とkouyaku[]）にそれぞれ記録していく。
	・表示して終わり。
結果：Run time error
何がおかしいのだろう。
普通に実行できるのだが。
*/
#include <stdio.h>
int koubai00(int a, int b);		
int kouyaku00(int a, int b);		
int main()
{
	int a,b;
	int i=0,count;
	int koubai,kouyaku;
	int ret;
	while(1){
		ret=scanf(,&a, &b);
		if(ret==EOF){
			break;
		}
		koubai=koubai00(a, b);
		kouyaku=kouyaku00(a, b);
		printf(,kouyaku, koubai);
	}
    return 0;
}
int koubai00(int a, int b)				
{										
	int small,big;
	int r;
	int result;
	if(a<b){
		small=a;
		big=b;
	}
	else if(a>b){
		small=b;
		big=a;
	}
	else{
		return a;
	}
	while(small!=0){
		r=big%small;
		big=small;
		small=r;
	}
	result=(a/big)*b;
	return result;
}
int kouyaku00(int a, int b)				
{
	int r;
	int small,big;
	if(a<b){
		small=a;
		big=b;
	}
	else if(a>b){
		small=b;
		big=a;
	}
	else{
		return a;
	}
	while(small!=0){
		r=big%small;
		big=small;
		small=r;
	}
	return big;
}"
C,"d;main(a,b){for(;d=~scanf(,&a,&b);puts(&d))d=log10(a+b)+49;}
 
 
 "
C,"#include <stdio.h> 
 
typedef enum { 
    FALSE, 
    TRUE 
} bool_t; 
 
void sorter ( int* data, int elements ) 
{ 
    int i, j, cmp, key; 
    for ( i = 0; i < elements; i++ ) 
    { 
        key = data[i]; 
        for ( j = i; j > 0; j-- ) 
        { 
            cmp = data[j - 1]; 
            if ( key < cmp ) 
            { 
                break; 
            } 
            else 
            { 
                data[j] = cmp; 
            } 
        } 
        data[j] = key; 
    } 
} 
 
int square ( int input ) 
{ 
    return input * input; 
} 
 
bool_t alg ( int* length ) 
{ 
    if ( square(length[0]) == square(length[1]) + square(length[2]) )                  
        return TRUE;                             
    else                                         
        return FALSE; 
} 
 
int main ( void ) 
{ 
    bool_t result; 
    int linenum, i; 
    int data[3]; 
 
    scanf( , &linenum ); 
 
    for ( i = 0; i < linenum; i++ ) 
    { 
        scanf( , &data[0], &data[1], &data[2] ); 
        sorter( data, 3 ); 
        if ( alg(data) ) 
            puts(  ); 
        else 
            puts(  ); 
    } 
 
    return 0; 
} "
C,"#include<stdio.h>
int main(void){
	int a, b, c, d, e, f, g, h, i, j, x;
	
	scanf(, &a);
	
	scanf(, &b);
	
	scanf(, &c);
	
	scanf(, &d);
	
	scanf(, &e);
	
	scanf(, &f);
	
	scanf(, &g);
	
	scanf(, &h);
	
	scanf(, &i);
	
	scanf(, &j);
	
	if (a<b){
		x = a;
		a = b;
		b = x;
	}
	if (a < c){
		x = a;
		a = c;
		c = x;
	}
	if (a < d){
		x = a;
		a = d;
		d = x;
	}
	if (a < e){
		x = a;
		a = e;
		e = x;
	}
	if (a < f){
		x = a;
		a = f;
		f = x;
	}
	if (a < g){
		x = a;
		a = g;
		g = x;
	}
	if (a < h){
		x = a;
		a = h;
		h = x;
	}
	if (a < i){
		x = a;
		a = i;
		i = x;
	}
	if (a < j){
		x = a;
		a = j;
		j = x;
	}
	
		
		if (b < c){
			x = b;
			b = c;
			c = x;
		}
		if (b < d){
			x = b;
			b = d;
			d = x;
		}
		if (b < e){
			x = b;
			b = e;
			e = x;
		}
		if (b < f){
			x = b;
			b = f;
			f = x;
		}
		if (b < g){
			x = b;
			b = g;
			g = x;
		}
		if (b < h){
			x = b;
			b = h;
			h = x;
		}
		if (b < i){
			x = b;
			b = i;
			i = x;
		}
		if (b < j){
			x = b;
			b = j;
			j = x;
		}
		
		if (c < d){
			x = c;
			c = d;
			d = x;
		}
		if (c < e){
			x = c;
			c = e;
			e = x;
		}
		if (c < f){
			x = c;
			c = f;
			f = x;
		}
		if (c < g){
			x = c;
			c = g;
			g = x;
		}
		if (c < h){
			x = c;
			c = h;
			g = x;
		}
		if (c < i){
			x = c;
			c = i;
			i = x;
		}
		if (c < j){
			x = c;
			c = j;
			j = x;
		}
		printf(,a);
		printf(,b);
		printf(,c);
		return 0;
}"
C,"#include <stdio.h>
#include <stdlib.h>
int alg ( int* coef, float* answer )
{
    float det, form_revA[4] = { 0 };
    if ( (det = coef[0] * coef[4] - coef[1] * coef[3]) == 0 )
        return -1;
    form_revA[0] = coef[4] / det;
    form_revA[1] = - ( coef[1] / det );
    form_revA[2] = - ( coef[3] / det );
    form_revA[3] = coef[0] / det;
    answer[0] = coef[2] * form_revA[0] + coef[5] * form_revA[1];
    answer[1] = coef[2] * form_revA[2] + coef[5] * form_revA[3];
    return 0;
}
int main ( void )
{
    int coef[6] = { 0 };
    float answer[2] = { 0.0 };
    while ( scanf(,
                &coef[0], &coef[1], &coef[2], &coef[3], &coef[4], &coef[5] )
            != EOF )
    {
        if ( alg( coef, answer ) < 0 )
            puts(  );
        else
            printf(, answer[0], answer[1] );
    }
    return 0;
}"
D,"import std.stdio;
import std.string;
import std.conv;
void main() {
    string input;
    const string[] classBoxing = [, , , , , , , , , , ];
    while ((input = readln.chomp).length != 0) {
        double weight = input.to!double;
        uint index;
        if (weight <= 48.00) {
            index = 0;
        } else if (weight <= 51.00) {
            index = 1;
        } else if (weight <= 54.00) {
            index = 2;
        } else if (weight <= 57.00) {
            index = 3;
        } else if (weight <= 60.00) {
            index = 4;
        } else if (weight <= 64.00) {
            index = 5;
        } else if (weight <= 69.00) {
            index = 6;
        } else if (weight <= 75.00) {
            index = 7;
        } else if (weight <= 81.00) {
            index = 8;
        } else if (weight <= 91.00) {
            index = 9;
        } else {
            index = 10;
        }
        writeln(classBoxing[index]);
    }
}"
D,"import std.stdio : write, writeln, writefln, stdin;
import std.array;
import std.range;
void main(){
	while(true){
		double[] stack;
		
		bool start = false;
		string[] str = readln.chomp.split;
		if(stdin.eof) break;
		foreach(s; str){
			if(s==){
				double t = stack.back;
				stack.popBack;
				double u = stack.back;
				stack.popBack;
				
				stack ~= u+t;
			}else if(s==){
				double t = stack.back;
				stack.popBack;
				double u = stack.back;
				stack.popBack;
				
				stack ~= u-t;
			}else if(s==){
				double t = stack.back;
				stack.popBack;
				double u = stack.back;
				stack.popBack;
				
				stack ~= u*t;
			}else if(s==){
				double t = stack.back;
				stack.popBack;
				double u = stack.back;
				stack.popBack;
				
				stack ~= u/t;
			}else{
				stack ~= s.to!double;
			}
		}
		
		writefln(, stack.back);
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"import std.stdio : writefln;
import std.array;
import std.range;
import std.math : sqrt;
void main(){
	while(true){
		int x = next!int();
		int h = next!int();
		if( (x|h)== 0){ return; }
		
		auto x_ = x.to!double;
		auto h_ = h.to!double;
		writefln(, x_*(x_*x_ + 4.*h_*h_).sqrt + x_*x_);
	}
}
import std.stdio : readln, chomp;
import std.conv : to;
import std.string : split;
shared string[] input;
shared string delim = ;
T next(T)()
in
{
	assert(hasNext());
}
out
{
	input.popFront;
}
body
{
	return input.front.to!T;
}
void next(T)(ref T v){
	v = next!T();
}
bool hasNext(){
	if(input.length > 0){
		return true;
	}
	
	string str = readln;
	if(str.length > 0){
		input ~= str.chomp.split(delim);
		return true;
	}else{
		return false;
	}
}
void dbg(T...)(T vs)
{
	import std.stdio : stderr;
	foreach(v; vs)
		stderr.write(v.to!string ~ );
	stderr.write();
}
T clone(T)(T v){
	T v_;
	static if(isInputRange!(T)){
		foreach(ite; v){
			v_ ~= ite.clone;
		}
	}else{
		v_ = v;
	}
	
	return v_;
}"
D,"/*
  数式のパターンは、
  ・数字の並べ方 -> 4!  = 24
  ・演算子の挿入 -> 3*3 = 9
  ・括弧の付け方 -> 5   = 5
  である。
  (((a # b) # c) # d)
  ((a # (b # c)) # d)
  (a # (b # (c # d)))
  (a # ((b # c) # d))
  ((a # b) # (c # d))
*/
import std.stdio;
import std.array;
import std.conv;
void main()
{
    auto op = ['+', '-', '*'];
    
    while (true) {
        auto flag = false;
        auto num = readln.split.to!(int[]);
        if (num[] == [0, 0, 0, 0]) break;
        
    loop:
        foreach (i; 0..3) {
            foreach (j; 0..3) {
                foreach (k; 0..3) {
                    foreach (a; 0..4) {
                        foreach (b; 0..4) {
                            if (b == a) continue;
                            foreach (c; 0..4) {
                                if (c == a || c == b) continue;
                                foreach (d; 0..4) {
                                    if (d == a || d == b || d == c) continue;
                                    if (cal(k, cal(j, cal(i, num[a], num[b]), num[c]), num[d]) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(k, cal(i, num[a], cal(j, num[b], num[c])), num[d]) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(i, num[a], cal(j, num[b], cal(k, num[c], num[d]))) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(i, num[a], cal(k, cal(j, num[b], num[c]), num[d])) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                    if (cal(j, cal(i, num[a], num[b]), cal(k, num[c], num[d])) == 10) {
                                        writefln(, num[a], op[i], num[b], op[j], num[c], op[k], num[d]);
                                        flag = true;
                                        break loop;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!flag) writeln(0);
    }
}
int cal(const int op, const int n1, const int n2)
{
    switch (op) {
    case 0:
        return n1 + n2;
        break;
    case 1:
        return n1 - n2;
        break;
    case 2:
        return n1 * n2;
        break;
    default:
        writeln();
        return 0;
        break;
    }
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
import std.math;
private{
alias real F;
bool eq(F[] a, F[] b){ return a[0]==b[0] && a[1]==b[1]; }
F norm2(F[] a){ return a[0]^^2+a[1]^^2; }
F dist2(F[] a, F[] b){ return (a[0]-b[0])^^2+(a[1]-b[1])^^2; }
F cross(F[] a, F[] b){ return a[0]*b[1]-b[0]*a[1]; }
F[] circumcenter(F[] a, F[] b, F[] c)
{
    F[] vb = [2*(b[0]-a[0]),2*(c[0]-a[0])];
    F[] vc = [2*(b[1]-a[1]),2*(c[1]-a[1])];
    F[] vd = [norm2(a)-norm2(b),norm2(a)-norm2(c)];
    F cbc = cross(vb,vc);
    return [cross(vc,vd)/cbc, cross(vd,vb)/cbc];
}
}
void main()
{
    for(int n; 0!=(n=readln().chomp().to!int()); )
    {
        auto ps = iota(n).map!(_=>readln().chomp().split().map!(to!F).array()).array();
        auto s = new bool[][](n,n);
        foreach(i;0..n-1)
            foreach(j;i+1..n)
                if(!eq(ps[i],ps[j]) && dist2(ps[i],ps[j])<=4)
                    s[i][j]=s[j][i]=true;
        size_t m=1;
        foreach(i;0..n-1) foreach(j;i+1..n)
        {
            {
                auto c = [(ps[i][0]+ps[j][0])/2,(ps[i][1]+ps[j][1])/2];
                m=max(m,ps.count!(p=>dist2(p,c)<=1)());
            }
            if(!s[i][j]) continue;
            m=max(m,2);
            foreach(k;j+1..n) if(s[i][k]&&s[j][k])
            {
                auto c = circumcenter(ps[i],ps[j],ps[k]);
                m=max(m,ps.count!(p=>dist2(p,c)<=1)());
            }
        }
        writeln(m);
    }
}"
D,"import std.stdio;
import std.conv;
import std.string;
import std.algorithm;
import std.math;
void main(){
    while(true){
	string[] s = [];
	for(int i=0;i<8;i++){
	    string temp = readln();
	    if(stdin.eof()) break;
	    s ~= chomp(temp);
	}
	if(stdin.eof()) break;
	string ans = ;
	for(int i=0;i<7;i++)
	    for(int j=0;j<7;j++)
		if(s[i][j]=='1'&&s[i][j+1]=='1'&&s[i+1][j]=='1'&&s[i+1][j+1]=='1') ans = ;
	for(int i=0;i<5;i++)
	    for(int j=0;j<8;j++)
		if(s[i][j]=='1'&&s[i+1][j]=='1'&&s[i+2][j]=='1'&&s[i+3][j]=='1') ans = ;
	for(int i=0;i<8;i++)
	    for(int j=0;j<5;j++){
		if(s[i][j]=='1'&&s[i][j+1]=='1'&&s[i][j+2]=='1'&&s[i][j+3]=='1') ans = ;
	    }
	for(int i=0;i<6;i++)
	    for(int j=1;j<8;j++)
		if(s[i][j]=='1'&&s[i+1][j]=='1'&&s[i+1][j-1]=='1'&&s[i+2][j-1]=='1') ans = ;
	for(int i=0;i<7;i++)
	    for(int j=0;j<6;j++)
		if(s[i][j]=='1'&&s[i][j+1]=='1'&&s[i+1][j+1]=='1'&&s[i+1][j+2]=='1') ans = ;
	for(int i=0;i<6;i++)
	    for(int j=0;j<7;j++)
		if(s[i][j]=='1'&&s[i+1][j]=='1'&&s[i+1][j+1]=='1'&&s[i+2][j+1]=='1') ans = ;
	for(int i=0;i<7;i++)
	    for(int j=1;j<7;j++)
		if(s[i][j]=='1'&&s[i][j+1]=='1'&&s[i+1][j-1]=='1'&&s[i+1][j]=='1') ans = ;
	writeln(ans);
	if(stdin.eof()) break;
	auto a = readln();
	if(stdin.eof()) break;
    }
}"
D,"import std.stdio,
       std.string,
       std.conv,
       std.algorithm,
       std.array;
void main() {
    while(1) {
        auto x = readln.split.map!(x=>x.to!int).array;
        if(x == [0, 0, 0, 0])
            return;
        bool f = false;
loop:    foreach(i; 0 .. 4) {
            foreach(j; 0 .. 4) {
                if(j == i)
                    continue;
                foreach(k; 0 .. 4) {
                    if(k == i || k == j)
                        continue;
                    foreach(l; 0 .. 4) {
                        if(l == i || l == j || l == k)
                            continue;
                        auto a = [x[i], x[j], x[k], x[l]];
                        f = a.solve;
                        if(f)
                            break loop;
                    }
                }
            }
        }
        if(!f)
            0.writeln;
    }
}
bool solve(int[] a) {
    immutable ops = ['+', '-', '*'];
    foreach(x; ops) {
    foreach(y; ops) {
    foreach(z; ops) {
        char[] op = [x, y, z];
        if(calc1(a, op) == 10) {
                writefln(, a[0], op[0], a[1], op[1], a[2], op[2], a[3]);
                return true;
        } else if(calc2(a, op) == 10) {
                writefln(, a[0], op[0], a[1], op[1], a[2], op[2], a[3]);
                return true;
        }
    }}}
    return false;
}
int calc1(int[] a, char[] op) {
    return sub_calc(sub_calc(sub_calc(a[0], op[0], a[1]), op[1], a[2]), op[2], a[3]);
}
int calc2(int[] a, char[] op) {
    return sub_calc(sub_calc(a[0], op[0], a[1]), op[1], sub_calc(a[2], op[2], a[3]));
}
int sub_calc(int a, char op, int b) {
    switch(op) {
        case '+':
            return a + b;
            break;
        case '-':
            return a - b;
            break;
        case '*':
            return a * b;
            break;
        default:
            throw new Exception();
            break;
    }
}"
D,"import std.stdio, std.string, std.conv;
import std.array, std.algorithm, std.range;
void main()
{
    foreach(s;stdin.byLine())
    {
        int[10] c; foreach(n;s) ++c[n-'0'];
        bool dfs(int n, bool d)
        {
            if(n>9) return d;
            if(c[n]==0) return dfs(n+1,d);
            if(c[n]>=3)
            {
                c[n]-=3;
                auto r = dfs(n,d);
                c[n]+=3;
                if(r) return true;
            }
            if(n<=9-2 && c[n]>0 && c[n+1]>0 && c[n+2]>0)
            {
                foreach(i;0..3) --c[n+i];
                auto r = dfs(n,d);
                foreach(i;0..3) ++c[n+i];
                if(r) return true;
            }
            if(!d && c[n]>=2)
            {
                c[n]-=2;
                auto r = dfs(n,true);
                c[n]+=2;
                if(r) return true;
            }
            return false;
        }
        bool solve(int n)
        {
            if(c[n]>=4) return false;
            ++c[n];
            auto r = dfs(1,false);
            --c[n];
            return r;
        }
        auto a = iota(1,10).filter!solve().map!(to!string).join();
        if(a==) a=;
        a.writeln();
    }
}"
D,"import std.stdio;
import std.ascii;
import std.range;
import std.array;
import std.functional;
import std.algorithm;
import std.conv;
import std.container;
import std.math;
import std.numeric;
import std.string;
import std.c.string;
import std.random;
import std.regex;
import std.typecons;
class TreeMap(K, V) {
    alias RedBlackTree!(Tuple!(K, V), , false) T;
    T rbtree;
    this() {
        rbtree = new T;
    }
    V opIndex(K key) {
        return rbtree.equalRange(tuple(key, V.init)).front[1];
    }
    V opIndexAssign(V value, K key) {
        rbtree.insert(tuple(key, value));
        return value;
    }
}
struct P {
    int id, score;
}
void main() {
    
    auto map = new TreeMap!(int, int);
    string s;
    P[] ps;
    while (true) {
        s = readln.chomp;
        if (s == ) break;
        auto t = s.split().map!(to!int);
        int id = t[0],
            score = t[1];
        ps ~= P(id, score);
    }
    ps.sort!;
    int prev_score = ps[0].score;
    int cur_rank = 1;
    for (int i = 0; i < ps.length; i++) {
        if (prev_score == ps[i].score) {
            map[ ps[i].id ] = cur_rank;
        } else {
            cur_rank++;
            map[ ps[i].id ] = cur_rank;
            prev_score = ps[i].score;
        }
    }
    while (true) {
        s = readln.chomp;
        if (stdin.eof) break;
        int x = s.to!int;
        writeln(map[x]);
    }
}"
D,"import std.stdio : readln , chomp, writeln;
import std.string : split;
import std.conv : to;
const int MAX_N = 1000;
const int MAX_W = 1000;
int W;
int N;
int[] value;
int[] weight;
int[2] solve()
{
	
	foreach(ref i; done){ i[] = false; }
	search(0, W);
	int[2] res = [memo[0][W], note[0][W]];
	return res;
}
bool[MAX_W+1][MAX_N] done;
int[MAX_W+1][MAX_N] memo; 
int[MAX_W+1][MAX_N] note; 
int search(int i, int w)
{
	if(i==N){return 0;}
	if(done[i][w])return memo[i][w];
	int[] res = [search(i+1, w), w<weight[i] ? 0 : search(i+1, w-weight[i])+value[i]];
	int max = res[0]>=res[1] ? 0 : 1;
	int one = max==0 ? 0 : weight[i];
	done[i][w] = true;
	memo[i][w] = res[max];
	note[i][w] = i+1>=N ? one : note[i+1][w - one] + one;
	return res[max];
}
void main()
{
	io();
}
void io()
{
	int num = 0;
	while(true){
		W = readln().chomp().to!int();
		if(W==0)break;
		N = readln().chomp().to!int();
		value = new int[N];
		weight = new int[N];
		foreach(i; 0..N){
			string[] str = readln().split();
			value[i] = str[0].chomp.to!int();
			weight[i] = str[1].chomp.to!int();
		}
		writeln(,++num,);
		int[2] res = solve();
		writeln = res[0];
		writeln = res[1];
	}
}"
